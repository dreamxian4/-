# 链表







## 合并两个有序链表



[21. 合并两个有序链表 - 力扣（LeetCode）](https://leetcode.cn/problems/merge-two-sorted-lists/)

![image-20220909115158162](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20220909115158162.png)

```c++
迭代：
	设一个虚拟头结点；比较两个链表的头结点，将数值小的（list1）放到虚拟指针后面；虚拟指针和list1的指针向后移；继续比较，直到某个链表为空，将另一个链表加入到虚拟指针后。
```

```c++
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {
        ListNode *head=new ListNode(0);//虚拟头结点
        ListNode *p=head;//虚拟指针
        while(list1&&list2)//有链表为空时退出循环
        {
            if(list1->val<=list2->val)
            {
                p->next=list1;//将数值小的节点接到虚拟指针处
                list1=list1->next;//继续遍历该节点的下一个节点
            }else
            {
                p->next=list2;
                list2=list2->next;
            }
            p=p->next;//加进了一个节点，虚拟指针后移
        }
        if(!list1)p->next=list2;//将未遍历完的链表直接加到虚拟链表后面
        else p->next=list1;
        return head->next;//返回时抛掉虚拟头结点
    }
};
```



```c++
递归:
    终止条件：其中一个参数链表为空，返回另一个链表；
    比较两个链表，将数值小的节点返回，该链表的剩下节点和另一个链表再次进行合并；返回的节点接到现有节点的后面。
```

```c++
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {
        //其中一个为空，另一个直接返回
        if(!list1)return list2;
        if(!list2)return list1;
        if(list1->val<=list2->val)
        {
            //保留两个链表中的较小节点，剩下的和另一条链表继续合并
            list1->next=mergeTwoLists(list1->next,list2);
            //返回每一层的最小节点（接到上一层的后面）
            return list1;
        }
        else
        {
             list2->next=mergeTwoLists(list1,list2->next);
             return list2;
        }
    }
};
```





## 交换相邻节点

[画解算法：24. 两两交换链表中的节点 - 两两交换链表中的节点 - 力扣（LeetCode）](https://leetcode.cn/problems/swap-nodes-in-pairs/solution/hua-jie-suan-fa-24-liang-liang-jiao-huan-lian-biao/)

![image-20220909115131898](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20220909115131898.png)

```
递归：
每两个节点分为一组，每一层将这两个节点交换；返回交换后的排在前面的节点，接到上一层末尾结点的后面。
```

```c++
class Solution {
public:
    ListNode* swapPairs(ListNode* head) {
        //若无节点或只有一个节点；不需交换
        if(head==nullptr||head->next==nullptr)return head;
        //保存2节点的地址
        ListNode* p=head->next;
        //1的后面接交换完成的3,4节点
        head->next=swapPairs(p->next);
        //2放在1前面
        p->next=head;
        //返回2（交换后的头结点）
        return p;
    }
};
```





## 删除重复节点

[83. 删除排序链表中的重复元素 - 力扣（LeetCode）](https://leetcode.cn/problems/remove-duplicates-from-sorted-list/submissions/)

![image-20220910112153876](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20220910112153876.png)

```
定义一个指针p，指向链表的头节点；判断p的元素和下一个节点元素是否相等，相等则删掉下一个节点后重新判断；不相等则p后移。
```

```c++
class Solution {
public:
    ListNode* deleteDuplicates(ListNode* head) {
        ListNode* p=head;
        //p位置和p的下一个位置不为空
        while(p&&p->next)
        {
            //p的数值和p的下一个节点的数值相等时，删掉p的下一个节点
            if(p->val==p->next->val)
            {
                ListNode* pp=p->next;
                p->next=pp->next;
                delete(pp);
                pp=nullptr;
                //删完进入下一个循环，再次判断p和p.next的数值
                continue;
            }
            //p和p.next数值不相等，p后移
            p=p->next;
        }
        return head;
    }
};
```







## 分离奇偶链表

[328. 奇偶链表 - 力扣（LeetCode）](https://leetcode.cn/problems/odd-even-linked-list/)

![image-20220911092732901](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20220911092732901.png)

```
链表的头结点为奇链表的头，头结点的下一个节点为偶链表的头；设两个变量分别指向奇偶链表的头；遍历链表，将奇数位的节点接到奇链表的后面，偶数位的节点接到偶链表的后面；最后把偶链表接到奇链表后面。
```

```c++
class Solution {
public:
    ListNode* oddEvenList(ListNode* head) {
        //链表为空或只有一个节点，返回链表
        if(!head||!head->next)return head;
        //nehead是偶链表的头
        ListNode* nehead=head->next;
        //用于遍历的指针
        ListNode* one=head,*two=nehead;
        //用于判断当前遍历到链表的奇数位还是偶数位
        int a=1;
        while(one&&two)
        {
            if(a)//奇数位
            {
                one->next=two->next;
                one=one->next?one->next:one;
                a--;
            }
            else//偶数位
            {
                two->next=one->next;
                two=two->next;
                a++;
            }
        }
        one->next=nehead;
        return head;
    }
};
```







## 删除倒数第n个节点

[19. 删除链表的倒数第 N 个结点 - 力扣（LeetCode）](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/)

![image-20220911095354296](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20220911095354296.png)

````
法1：快慢指针：快指针比慢指针先走n步，当快指针的下一个节点是空时，慢指针的下一个节点就是待删除的节点。
````

```c++
class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        //定义一个哑结点
        ListNode* dm=new ListNode(0,head);
        //定义快慢指针
        ListNode* one=dm,*two=dm;
        //快指针先走n步
        while(n--)
        {
            one=one->next;
        }
        //快指针的下一个节点不为空时，两个指针向后移动
        while(one->next)
        {
            one=one->next;
            two=two->next;
        }
        //快指针的下一个节点为空，删除慢指针的下一个节点
        two->next=two->next->next;
        //返回哑结点的下一个节点（避免删除头结点或链表为空）
        return dm->next;
    }
};
```

```
法2：先遍历一次链表得出链表长度L，再遍历一次，删除第L-n+1个节点。
法3：入栈出栈
```







## **链表排序（归并）















# 栈





## o(1)时间查最小值



[155. 最小栈 - 力扣（LeetCode）](https://leetcode.cn/problems/min-stack/submissions/)

![image-20221009180810514](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20221009180810514.png)

```
1.建两个栈；
一个a负责正常的入栈和出栈；
一个b负责存储最小值；
在入栈的时候，a直接入栈，b如果当前值小于等于b的栈顶元素，就入栈；
在出栈的时候，a直接出栈，b如果栈顶元素和a的出栈元素相等，就出栈。
```

```c++
class MinStack {
public:
    stack<int> s;		//正常栈
    stack<int>min;		//最小值的栈
public:
    MinStack() {
        
    }
    
    void push(int val) {
        s.push(val);		//正常的直接入栈
        if(min.size()==0||val<=min.top())min.push(val);//最小值栈若为空或栈顶元素大于当前值，入栈
    }
    
    void pop() {
        if(s.top()==min.top())min.pop();//如果正常栈的出栈元素等于最小值栈的栈顶元素，最小值栈出栈
        s.pop();	//正常的直接出栈
    }
    
    int top() {
        return s.top();		//返回正常栈的栈顶
    }
    
    int getMin() {
        return min.top();	//返回最小值栈的栈顶
    }
};
```





```
2.建一个栈和一个int变量min
栈用来正常的入栈和出栈；
min用来存储最小值；
入栈时，若入栈元素小于等于min,将min入栈后再将新值入栈，更新min;
出栈时，若出栈元素等于min,将栈顶元素出栈，min等于新的栈顶元素，将栈顶元素再次出栈。
```

```c++
class MinStack {
public:
    stack<int> s;		//正常栈
    int min=INT_MAX;	//最小值
public:
    MinStack() {
        
    }
    
    void push(int val) {
        if(val<=min)	//当前值小于最小值
        {
            s.push(min);//将最小值入栈
            min=val;	//更新最小值
        }
        s.push(val);	//将当前值入栈
    }
    
    void pop() {
        if(s.top()==min)	//栈顶元素等于最小值
        {
            s.pop();		//出栈
            min=s.top();	//min等于新的栈顶元素
        }
        s.pop();			//将之前存储的最小值出栈
    }
    
    int top() {
        return s.top();
    }
    
    int getMin() {
        return min;
    }
};
```









## 有效括号



[20. 有效的括号 - 力扣（LeetCode）](https://leetcode.cn/problems/valid-parentheses/)

![image-20221009180838829](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20221009180838829.png)

```
创建一个栈，
如果是左边括号，就入栈；
如果是右边括号，就判断该右边是否与栈顶左边匹配，
如果匹配，就出栈；
如果不匹配，就返回false；
所有的都遍历之后，判断栈中是否还有元素，
如果有，就返回false；
如果没有，就返回true。
```

```c++
class Solution {
public:
    bool isValid(string s) {
        stack<char>ss;		//辅助栈
        for(int a=0;a<s.size();a++)
        {
            if(s[a]=='('||s[a]=='['||s[a]=='{')ss.push(s[a]);//左边入栈
            else if(ss.empty())return false;				//不是左边且栈为空，返回f
            else if(
                (s[a]==')'&&ss.top()=='(')
                ||(s[a]==']'&&ss.top()=='[')
                ||(s[a]=='}'&&ss.top()=='{'))ss.pop();		//是右边且和栈顶元素匹配，出栈
            else return false;							  //不匹配，返回f
        }
        if(ss.empty())return true;						  //全部匹配，返回t
        return false;									 //站内有剩余，返回f
    }
};
```







## 每日温度（单调栈）



[739. 每日温度 - 力扣（LeetCode）](https://leetcode.cn/problems/daily-temperatures/)

![image-20221009180855960](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20221009180855960.png)

```
创建一个栈（从栈底到栈顶单调递减），一个用于返回的数组v
遍历数组，
如果栈是空或当前值小于栈顶元素，当前值的下边入栈；
如果当前值大于栈顶元素，v[栈顶]等于当前值和栈顶值的差，出栈，继续比较当前值和新栈顶值。
```

```c++
class Solution {
public:
    vector<int> dailyTemperatures(vector<int>& temperatures) {
        vector<int>v(temperatures.size(),0);		//用于返回的数组
        stack<int>s;							  //单调栈
        for(int a=0;a<temperatures.size();a++)
        {
            while(!s.empty()&&temperatures[a]>temperatures[s.top()])//当前值大于栈顶值
            {
                v[s.top()]=a-s.top();				//记录差值
                s.pop();						   //出栈
            }
            s.push(a);							   //当前值下标入栈
        }
        return v;
    }
};
```











# 队列



## 优先队列（知识点）



### 底层实现



​		堆（Heap）实现：堆是一个完全二叉树，即只允许最后一排不满的树。优先队列（priority queue）可以在 O(1) 时间内获得最大值，并且可以在 O(log n) 时间内取出 最大值或插入任意值。

​		大根堆：每个节点都比父节点小

​		小根堆：每个节点都比父节点大

```c++
vector<int>heap;//大根堆

//插入:先插到最后，再上浮到合适位置
void insert_(int a)
{
    heap.push_back(a);
    up_(heap.size()-1);
}

//删除（最大值）：删掉第一个元素，将最后一个元素挪到第一个，再下沉到合适位置
void delete_()
{
    heap[0]=heap.back();
    heap.pop_back();
    down_(0);
}

//上浮：如果比父节点大((n-1)/2)，就交换
void up_(int n)
{
    while(n>0&&heap[n]>heap[(n-1)/2])
    {
        swap(heap[n],heap[(n-1)/2]);
        n/=2;
    }
}

//下沉：如果比最大子节点(n*2+1 n*2+2)小，就交换
void down_(int n)
{
    while(n*2+1<heap.size())
    {
        int i=n*2+1;
        if(n*2+2<heap.size())i=heap[n*2+1]>heap[n*2+2]?n*2+1:n*2+2;
        if(heap[n]<heap[i])
        {
            swap(heap[n],heap[i]);
        	n=i;
        }
        else break;
    }
}
```



### STL priority_queue



​		头文件：#include<queue>

​		存储整数类型的优先队列（默认大根堆）：priority_queue<int>que;

```c++
priority_queue<int>que;		
//默认：priority_queue<int,vector<int>,less<int>>que; 存储int，用vector存储，越往后越小
que.size();				//o(1)
que.push(1);			//o(lgn)
que.pop();				//o(lgn)
que.top();				//o(1)
que.empty();			//o()
```

​		

​		小根堆的优先队列：

```c++
priority_queue<int,vector<int>,greater<int>>que;
```



​		存储自定义类型，要重载大于小于号 或 用仿函数

```c++
//重载大于小于号
struct node
{
    int x,y;
    bool operator<(const node &b)
    {
        return this->x > b.x;		//小根堆
    }
};
priority_queue<node,vector<int>,less<int>>que;
//用less规则，要重载<。若返回的是>，则为小根堆；若返回的是<，则为大根堆。
//用greater规则，要重载>。

//仿函数
struct cmp
{
    bool operator()(const node&a,const node&b)
    {
        return a.x>b.x;			   //小根堆
    }
};
priority_queue<node,vector<int>,cmp>que;
```







## 合并n个有序队列



[23. 合并K个升序链表 - 力扣（LeetCode）](https://leetcode.cn/problems/merge-k-sorted-lists/submissions/)

![image-20221009180920494](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20221009180920494.png)

```
利用小根堆的优先队列，
将每个链表的头结点入队。
创建一个新链表的头结点，
将优先队列的队首连接到头结点的后面，
出队，
若出队的这个头结点后还有节点，
将头结点的下一个节点重新入队。
直到优先队列为空，
合并完成。
```

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    struct cmp				//规则函数：小根堆
    {
        bool operator()(ListNode* a,ListNode* b)
        {
            return a->val>b->val;
        }
    };

    ListNode* mergeKLists(vector<ListNode*>& lists) {
        if(lists.empty())return nullptr;
        priority_queue<ListNode*,vector<ListNode*>,cmp>que;	//优先队列
        for(ListNode* n:lists)
        {
            if(n)que.push(n);			//头结点入栈
        }
        ListNode* head=new ListNode(),*ptr=head;	//新链表的头结点
        while(!que.empty())				//队列不为空
        {
            ptr->next=que.top();		//队首入链表
            ptr=ptr->next;
            que.pop();					//出队
            if(ptr->next)que.push(ptr->next);//队首节点后面还有节点，将其入队
        }
        return head->next;				//返回头结点的下一个节点
    }
};
```







## 天际线问题（没做出...）

[218. 天际线问题 - 力扣（LeetCode）](https://leetcode.cn/problems/the-skyline-problem/)

![image-20221009180940814](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20221009180940814.png)

![image-20221009181000362](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20221009181000362.png)



## 滑动窗口最大值（双端队列）



[239. 滑动窗口最大值 - 力扣（LeetCode）](https://leetcode.cn/problems/sliding-window-maximum/)

![image-20221009181015415](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20221009181015415.png)

```
双端队列（存储下标）
最前面放当前窗口中的最大值（下标，后面亦然）
后面递减（若后加入的值比前面的值大，就把前面的值出队）
当队首不在窗口范围内时（dq.front()==a-k），队首出队
当队内元素个数满足窗口大小时，将队首元素加入数组。
```

```c++
class Solution {
public:
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        deque<int>dq;	//双端队列（单调队列）
        vector<int>vec;//答案数组
        for(int a=0;a<nums.size();a++)
        {
            if(!dq.empty()&&dq.front()==a-k)dq.pop_front();//队首不在窗口范围，出队
            while(!dq.empty()&&nums[dq.back()]<nums[a])dq.pop_back();//保持单调队列
            dq.push_back(a);//入队
            if(a>=k-1)vec.push_back(nums[dq.front()]);//满足窗口大小，入数组
        }
        return vec;
    }
};
```









# 字符串





## 字母异位词



[242. 有效的字母异位词 - 力扣（LeetCode）](https://leetcode.cn/problems/valid-anagram/submissions/)

![image-20221009181033767](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20221009181033767.png)

```
以字符做下标（26个，初始化为0）
第一个字符串的字符若出现，+1
第二个字符串的字符若出现，-1
最后遍历数组，若有不为0的，返回false
```

```c++
class Solution {
public:
    bool isAnagram(string s, string t) {
        if(s.size()!=t.size())return false;//长度不一样
        int a[26]{0};
        for(int i=0;i<s.size();i++)
        {
            a[s[i]-'a']++;//第一个+
            a[t[i]-'a']--;//第二个-
        }
        for(int i=0;i<26;i++)
        if(a[i]!=0)return false;//有不为0的，返回
        return true;
    }
};
```









## 同构字符串



[205. 同构字符串 - 力扣（LeetCode）](https://leetcode.cn/problems/isomorphic-strings/)

![image-20221011222240326](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20221011222240326.png)

```
创建两个数组（字符做下标，存储最后一次出现时在原串中的位置）
比较两个串中该字符上一次出现的位置是否相同
若相同 更新位置
若不相同 则不是同构字符串
```

```c++
class Solution {
public:
    bool isIsomorphic(string s, string t) {
        if(s.size()!=t.size())return false;
        vector<int>vs(256,-1);	//用于记录串s中元素最后一次出现的位置
        vector<int>vt(256,-1);  //用于记录串t中元素最后一次出现的位置
        for(int a=0;a<s.size();a++)
        {
            if(vs[s[a]]==vt[t[a]])		//最后一次出现的位置相等（没出现过：都为-1）
            {
                vs[s[a]]=a;		//更新
                vt[t[a]]=a;		//更新
            }
            else return false;
        }return true;
    }
};
```









## 回文子串



[647. 回文子串 - 力扣（LeetCode）](https://leetcode.cn/problems/palindromic-substrings/)

![image-20221011222255363](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20221011222255363.png)

```
中心拓展：
从第一个字符开始，判断以其为中心有多少个回文串：
分为以他为中心的奇数长度的串和偶数长度的串
```

```c++
class Solution {
public:
    int countSubstrings(string s) {
        int count=0;
        for(int a=0;a<s.size();a++)//以s[a]为中心
        {
            count+=judge(s,a,a);//奇数长度的子串
            count+=judge(s,a,a+1);//偶数长度的子串
        }
        return count;
    }

    int judge(string s,int l,int r)
    {
        int co=0;
        while(l>=0&&r<s.size())//不超出字符串的范围
        {
            if(s[l]==s[r])//是回文子串
            {
                co++;//个数+1
                //下一个子串
                l--;
                r++;
            }
            else break;
        }
        return co;
    }
};
```









## 计数二进制子串



[696. 计数二进制子串 - 力扣（LeetCode）](https://leetcode.cn/problems/count-binary-substrings/)

![image-20221011222311019](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20221011222311019.png)

```
创建一个数组，将字符串中连续出现某数的个数记录下来
遍历该数组，将相邻两个数中较小值相加，即为结果。
```

```c++
class Solution {
public:
    int countBinarySubstrings(string s) {
        vector<int>ve;			//用于存储连续0/1个数的数组
        int count=1;			//计数器
        for(int a=1;a<s.size();a++)
        {
            if(s[a]==s[a-1])count++;	//计算连续相等字符个数
            else
            {
                ve.push_back(count);	//不相等时将个数存入数组
                count=1;			   //重置计数器
            }
        }
        ve.push_back(count);			//最后一个字符的个数
        count=0;
        for(int a=1;a<ve.size();a++)
        {
            count+=min(ve[a],ve[a-1]);	//将连续两个数的较小值相加
        }
        return count;
    }
};
```











## 基本计算器



[227. 基本计算器 II - 力扣（LeetCode）](https://leetcode.cn/problems/basic-calculator-ii/)

![image-20221013222122132](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20221013222122132.png)

```
假设第一个数数值前面有一个+号
遍历字符串
若为数字，记下
若为符号，判断上一个符号是什么：
若为+-，直接将数值入栈，正数直接入栈，负数将相反数入栈
若为*/，将栈顶元素更新为*/当前数值；
最后将栈中所有元素相加。
```

```c++
class Solution {
public:
    int calculate(string s) {
        stack<long>st;		
        long num=0;
        char x='+';
        for(int a=0;a<s.size();a++)
        {
            if(s[a]>='0'&&s[a]<='9')num=num*10+s[a]-'0';//记下数字
            if((s[a]<'0'||s[a]>'9')&&s[a]!=' '||a==s.size()-1)
            {
                switch(x)
                {
                    case '+':
                    st.push(num);//直接入栈
                    break;
                    case '-':
                    st.push(-num);
                    break;
                    case '*':
                    st.top()*=num;//栈顶元素进行运算
                    break;
                    case '/':
                    st.top()/=num;
                    break;
                }
                x=s[a];//更新符号
                num=0;//更新数字
            }
        }
        while(!st.empty())
        {
            num+=st.top();//栈中元素相加
            st.pop();
        }
        return num;
    }
};
```









## 最长回文串



[409. 最长回文串 - 力扣（LeetCode）](https://leetcode.cn/problems/longest-palindrome/)

![image-20221016121222918](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20221016121222918.png)

```
字符做下标
遍历字符串，若该字符之前出现过奇数次
计数器+2，更新数组。
都遍历完后，
若计数器不等于字符串长度，return 计数器+1（aba）
```

```c++
class Solution {
public:
    int longestPalindrome(string s) {
        vector<int>ve(256,0);//计数数组
        int len=0;//计数器
        for(char a:s)
        {
            if(ve[a]%2==1)//出现过奇数次
            len+=2;//更新计数器
            ve[a]++;//更新计数数组
        }
        if(len==s.size())//等于字符串长度
        return len;//直接返回
        return len+1;//可从字符串中随便拿一个字符放在回文字符串正中间
    }
};
```











## 无重复字符的最长子串

[3. 无重复字符的最长子串 - 力扣（LeetCode）](https://leetcode.cn/problems/longest-substring-without-repeating-characters/)

![image-20221016214948925](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20221016214948925.png)

```
滑动窗口
用一个数组记下每个元素是否在窗口内
右指针右移，若当前元素没出现过，继续右移，更新数组
若当前元素出现过，左指针右移，更新数组，直到右指针所指元素在窗口中不重复为止
在每次移动左指针时，记录长度
```

```c++
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        vector<int>ve(256,0);//记录元素是否出现的数组
        int pa=0,pb=0;//左右指针
        int len=0;//子串长度
        while(pb<s.size())
        {
            if(ve[s[pb]]==0)//没出现过
            {
                ve[s[pb]]=1;//纳入窗口，更新数组
                pb++;//右指针右移
            }
            else
            {//出现过
                len=max(len,pb-pa);//更新长度
                ve[s[pa]]=0;//更新数组
                pa++;//左指针右移
            }
        }
        len=max(len,pb-pa);
        return len;
    }
};
```









## 最长回文子串



[5. 最长回文子串 - 力扣（LeetCode）](https://leetcode.cn/problems/longest-palindromic-substring/)

![image-20221023220909427](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20221023220909427.png)

```
参考“回文子串”一题，采用中心扩展方法：
在其基础上，记下每次回文子串的长度，保留下最长回文子串的开始位置和结束位置
```

```c++
class Solution {
public:
string str;//用于存储最长回文子串
int len;//记录最大长度
int l,r;//最大回文子串的首尾位置
    string longestPalindrome(string s) {
        len=0;
        l=1;
        r=0;
        str=s[0];//当字符串内只有一个元素时，其本身即为最大回文子串
        for(int a=0;a<s.size();a++)//中心扩展
        {
            judge(s,a,a);
            judge(s,a,a+1);
        }
        if(r>l)
        {
            str="";
            for(int a=l;a<=r;a++)str+=s[a];//最长回文子串
        }
        return str;
    }

    void judge(string s,int a,int b)
    {
        while(a>=0&&b<s.size()&&s[a]==s[b])//中心扩展
        {
            a--;
            b++;
        }
        if(b-a-1>len)//本次最大回文子串长度是否为最大
        {
            len=b-a-1;//更新
            l=a+1;
            r=b-1;
        }
    }
};
```







# 哈希表











## 两数之和



[1. 两数之和 - 力扣（LeetCode）](https://leetcode.cn/problems/two-sum/submissions/)

![image-20221029110531966](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20221029110531966.png)

```
创建哈希表unordered_map<数组元素，下标>
遍历数组，存入表
遍历数组，判断target-数组元素是否存在于表内
若存在：判断其是否为本身
若不是：返回答案
否则，继续遍历
```

```c++
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        unordered_map<int,int>ma;
        vector<int>ve;
        for(int a=0;a<nums.size();a++)ma[nums[a]]=a;//入表
        for(int a=0;a<nums.size();a++)
        {
            if(ma.count(target-nums[a]))//判断是否存在
            {
                if(a!=ma[target-nums[a]])
                {
                    ve.push_back(a);//输入答案
                    ve.push_back(ma[target-nums[a]]);
                    break;
                }
            }
        }
        return ve;
    }
};
```









## 最长连续序列



[128. 最长连续序列 - 力扣（LeetCode）](https://leetcode.cn/problems/longest-consecutive-sequence/)

![image-20221031162557014](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20221031162557014.png)

```
把所有元素存在unordered_set中
遍历unordered_set，每遍历一个元素，就把该元素以及和该元素连续的所有元素删除
记录删除前后的长度差，差值最大的即为答案
```

```c++
class Solution {
public:
    int longestConsecutive(vector<int>& nums) {
        unordered_set<int>uns;
        for(int a:nums)uns.insert(a);//插入
        int len=0;
        while(!uns.empty())
        {
            int yuan=uns.size();
            int a=*(uns.begin());//遍历
            uns.erase(a);//删除本身
            int pa=a-1,pb=a+1;
            while(uns.find(pa)!=uns.end())//删除比本身小的连续元素
            {
                uns.erase(pa);
                pa--;
            }
            while(uns.find(pb)!=uns.end())//删除比本身大的连续元素
            {
                uns.erase(pb);
                pb++;
            }
            len=len>yuan-uns.size()?len:yuan-uns.size();//保留最大差值
        }
        return len;
    }
};
```















# 分治





## 为运算表达式设计优先级



[241. 为运算表达式设计优先级 - 力扣（LeetCode）](https://leetcode.cn/problems/different-ways-to-add-parentheses/)

![image-20221104182159878](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20221104182159878.png)

```
//递归方法：
每当遇到运算符
就以该运算符为分界线，将本层的字符串分成两部分，分别递归设计两部分的字符串

分解：按运算符分成左右两部分，分别求解
解决：实现一个递归函数，输入算式，返回算式解
合并：根据运算符合并左右两部分的解，得出最终解
```

```c++
class Solution {
public:
    vector<int> diffWaysToCompute(string input) {
        vector<int>ans;//结果数组
        for(int a=0;a<input.size();a++)
        {
            char c=input[a];
            if(c=='+'||c=='-'||c=='*')//遇到运算符
            {
                vector<int>left=diffWaysToCompute(input.substr(0,a));//左边的所有可能结果
                vector<int>right=diffWaysToCompute(input.substr(a+1));//右边的所有可能结果
                for(int l:left)//整体结果
                {
                    for(int r:right)
                    {
                        switch(c)
                        {
                            case '+':ans.push_back(l+r);break;
                            case '-':ans.push_back(l-r);break;
                            case '*':ans.push_back(l*r);break;
                        }
                    }
                }
            }
        }
        if(ans.empty())ans.push_back(stoi(input));//字符串中无运算符
        return ans;
    }
};

```





## 两个练习









# 回溯





## 组合



[77. 组合 - 力扣（LeetCode）](https://leetcode.cn/problems/combinations/)

![image-20221202193014831](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20221202193014831.png)

```
创建一个临时存储排列的数组，
从1开始遍历，每遍历一个就把该数放入临时数组；
若临时数组的数据量达到k了，就将该数组放入答案数组中。
回溯：回到上一层，将最后一个元素删掉；继续遍历下一个元素
```

```c++
class Solution {
public:
    vector<vector<int>> combine(int n, int k) {
        vector<vector<int>>ans;//答案数组
        vector<int>vec;//临时数组
        dfs(ans,vec,n,k,1);//回溯
        return ans;
    }
    void dfs(vector<vector<int>>&ans,vector<int>&vec,int n,int k,int i){
        if(vec.size()==k){//如果临时数组的容量等于k，就放入答案数组
            ans.push_back(vec);
            return;
        }
        for(int a=i;a<=n;a++){//从1开始
            vec.push_back(a);//放入临时数组
            dfs(ans,vec,n,k,a+1);//剩下的元素进行组合
            vec.pop_back();//该元素在该位置的所有组合已经放入完毕，开始下一个元素。
        }
    }
};
```







## 单词搜索



[79. 单词搜索 - 力扣（LeetCode）](https://leetcode.cn/problems/word-search/)

![image-20221202195820136](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20221202195820136.png)

```
深度搜索+回溯：
将每个元素都看作是目标单词的第一个字符；
若当前元素和目标值匹配，则看它的四个方向上有没有下一个目标值（将当前值置为0，防止重复访问）：
若没有，将当前值恢复，重新检查下一个元素；
若有，将下一个元素看作匹配节点，检索下一个元素的四个方向...
```

```c++
class Solution {
public:
    bool exist(vector<vector<char>>& board, string word) {
        //将矩阵中的每个字符都看作匹配单词的第一个字符
        for(int x=0;x<board.size();x++){
            for(int y=0;y<board[0].size();y++){
                //若当前字符为起点匹配成功，返回true
                if(dfs(board,word,x,y,0))return true;
            }
        }
        //整体遍历过后，未匹配成功，返回false
        return false;
    }

    bool dfs(vector<vector<char>>& board, string word,int x,int y,int wh){
        //如果目标单词已匹配到最后，返回true
        if(wh==word.size())return true;
        //如果xy超范围或当前值和目标值不匹配，返回false
        if(x<0||x>=board.size()||y<0||y>=board[0].size())return false;
        if(board[x][y]!=word[wh])return false;
        
        //保留当前值
        char ch=board[x][y];
        //将当前值置为0，防止重复访问
        board[x][y]='0';
        //如果四个方向上有一个匹配成功，则成功
        if(dfs(board,word,x-1,y,wh+1)||dfs(board,word,x+1,y,wh+1)||
        dfs(board,word,x,y-1,wh+1)||dfs(board,word,x,y+1,wh+1))return true;
        //都匹配失败，恢复当前值，返回false
        board[x][y]=ch;
        return false;
    }
};
```





## N皇后



[51. N 皇后 - 力扣（LeetCode）](https://leetcode.cn/problems/n-queens/)

![image-20221202211727004](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20221202211727004.png)

```
按层递归，按列循环：
判断该层该列是否能下（纵向、斜向是否已有皇后棋）
若能下，将该处替换成Q，下一层；
若不能下，下一列。
若所有列都不能下，返回上一层，将点换回.
若已最后一层已下，将当前棋盘保存。
```

```c++
class Solution {
public:
    vector<vector<string>> solveNQueens(int n) {
        //结果数组
        vector<vector<string>> ans;
        //期盼
        vector<string>board(n);
        //初始化
        for(int a=0;a<n;a++){
            for(int b=0;b<n;b++){
                board[a]+='.';
            }
        }
        dfs(ans,board,n,0);
        return ans;
    }

    void dfs(vector<vector<string>> &ans,vector<string>board,int n,int x){
        //最后一层已下完，将当前棋盘放入结果数组
        if(x==n){
            ans.push_back(board);
            return;
        }
        //遍历当前层的每一列是否能下
        for(int a=0;a<n;a++){
            if(judge(board,x,a,n)){
                //能下，下棋，下一层，恢复，下一列
                board[x][a]='Q';
                dfs(ans,board,n,x+1);
                board[x][a]='.';
            }
        }
    }

	//判断x,y点是否可下
    bool judge(vector<string>board,int x,int y,int n){
        //竖
        for(int a=0;a<n;a++)if(board[a][y]=='Q')return false;
        //撇
        int x1=x,x2=x,yy=y;
        while(x1<n&&yy>=0)if(board[x1++][yy--]=='Q')return false;
        yy=y;
        while(x2>=0&&yy<n)if(board[x2--][yy++]=='Q')return false;
        //捺
        x1=x;x2=x;yy=y;
        while(x1>=0&&yy>=0)if(board[x1--][yy--]=='Q')return false;
        yy=y;
        while(x2<n&&yy<n)if(board[x2++][yy++]=='Q')return false;
        return true;
    }
    
};
```







# 树



## 二叉树的最大深度



[104. 二叉树的最大深度 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-depth-of-binary-tree/)

![image-20221203180410748](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20221203180410748.png)

```
递归：某一层的最大深度=1+其子节点的最大深度
```

```c++
class Solution {
public:
    int maxDepth(TreeNode* root) {
        if(root==nullptr)return 0;
        return 1+max(maxDepth(root->left),maxDepth(root->right));//返回子节点的最大深度+自己的1
    }
};
```





## 平衡二叉树



[110. 平衡二叉树 - 力扣（LeetCode）](https://leetcode.cn/problems/balanced-binary-tree/)

![image-20221203182002985](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20221203182002985.png)

```
判断二叉树的所有子树的高度差；
自底向上，子结点中某一结点已不平衡，直接返回-1
```

```c++
class Solution {
public:
    bool isBalanced(TreeNode* root) {
        if(root==nullptr)return true;
        if(height(root)==-1)return false;
        return true;
    }
    int height(TreeNode *root){
        if(root==nullptr)return 0;
        int left=height(root->left),right=height(root->right);//计算左右子树的高度
        if(left==-1||right==-1||abs(left-right)>1)return -1;//若左右子树高度差>1，返回-1；若左右子树其中一个已为-1，返回-1
        return 1+max(height(root->left),height(root->right));//左右子树平衡，返回高度
    }
};
```







## 二叉树的直径



[543. 二叉树的直径 - 力扣（LeetCode）](https://leetcode.cn/problems/diameter-of-binary-tree/)

![image-20221203183519034](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20221203183519034.png)

```
若某点的左右子树高度和>chang，更新chang
左右子树高度求法同上。
```

```c++
class Solution {
public:
    int diameterOfBinaryTree(TreeNode* root) {
        int chang=0;
        height(root,chang);
        return chang;
    }
    int height(TreeNode* root,int &chang){
        if(!root)return 0;
        int left=height(root->left,chang),right=height(root->right,chang);
        if(left+right>chang)chang=left+right;
        return 1+max(left,right);
    }
};
```







## *路径总和



[437. 路径总和 III - 力扣（LeetCode）](https://leetcode.cn/problems/path-sum-iii/)

[560. 和为 K 的子数组 - 力扣（LeetCode）](https://leetcode.cn/problems/subarray-sum-equals-k/)类似

![image-20221205204213158](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20221205204213158.png)





## 对称二叉树



[101. 对称二叉树 - 力扣（LeetCode）](https://leetcode.cn/problems/symmetric-tree/)

![image-20221205205707851](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20221205205707851.png)

```
将树分为两半，分别判断左的右和右的左、左的左和右的右
```

```c++
class Solution {
public:
    bool isSymmetric(TreeNode* root) {
        return llrr(root,root);
    }
    bool llrr(TreeNode*left,TreeNode*right){
        if(left&&right){//左右节点都有值
            if(left->val!=right->val)return false;//二者不相等，返回false
            //继续判断左的右跟右的左、左的左跟右的右是否相等
            return llrr(left->left,right->right)&&llrr(left->right,right->left);
        }
        //二者都为空，判断结束
        if(!left&&!right)return true;
        //二者其一为空，返回false
        return false;
    }
};
```





## 删点成林



[1110. 删点成林 - 力扣（LeetCode）](https://leetcode.cn/problems/delete-nodes-and-return-forest/)

![image-20221206191254638](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20221206191254638.png)

```
递归函数中处理节点的左右子树，若某节点被删，将其子节点放入答案数组
在主函数中单独处理根节点
```

```c++
class Solution {
public:
    vector<TreeNode*> delNodes(TreeNode* root, vector<int>& to_delete) {
        int a[1001]{0};//下标代表被删节点1：要删 0：不删
        for(int b:to_delete)a[b]++;
        
        vector<TreeNode*>ans;
        //处理根节点的左右子树
        bian(root,ans,a);
        //单独处理根节点
        if(root&&!a[root->val])ans.push_back(root);//根不删，把根入组
        if(root&&a[root->val]){//根删，把根的子节点入组
            if(root->left)ans.push_back(root->left);
            if(root->right)ans.push_back(root->right);
        }
        return ans;
    }
    void bian(TreeNode* root,vector<TreeNode*>&ans,int *a){
        if(!root)return;
        if(root->left){//有左子树
            bian(root->left,ans,a);//处理左子树
            if(a[root->left->val]){//若左子树要被删，将左子树的子节点入组
                if(root->left->left)ans.push_back(root->left->left);
                if(root->left->right)ans.push_back(root->left->right);
                delete root->left;
                root->left=nullptr;
            }
        }
        if(root->right){//有右子树
            bian(root->right,ans,a);//处理右子树
            if(a[root->right->val]){//若右子树要被删，将右子树的子节点入组
                if(root->right->left)ans.push_back(root->right->left);
                if(root->right->right)ans.push_back(root->right->right);
                delete root->right;
                root->right=nullptr;
            }
        }
    }
};
```





## 二叉树的层平均值



[637. 二叉树的层平均值 - 力扣（LeetCode）](https://leetcode.cn/problems/average-of-levels-in-binary-tree/)

![image-20221206193258250](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20221206193258250.png)

```
利用队列：将根节点入队，再入队一个结尾标志；每出队一个节点，如果该节点不是结尾，就将其子节点入队；如果该节点是结尾，判断队列内是否还有元素，若有，将结尾标志入队，若没有，遍历结束。
每次遍历到结尾节点时，将该曾的平均值放入结果数组。
```

```c++
class Solution {
public:
    vector<double> averageOfLevels(TreeNode* root) {
        queue<TreeNode*>que;
        vector<double>ans;
        double num=0;//每层和
        double con=0;//每层个数
        
        que.push(root);//根节点入队
        que.push(nullptr);//第一层已没有节点，入一个标记位（nullptr）
        
        while(!que.empty()){
            TreeNode* p=que.front();//保留队首
            que.pop();//出队
            if(p){//如果出队的节点不空，说明队列中至少还有一个元素（nullptr）
                if(p->left)que.push(p->left);//子节点入队
                if(p->right)que.push(p->right);
                num+=p->val;//加到本层和
                con++;//本层个数+1
            }
            else{//如果出对节点为空，说明本层已遍历完成
                ans.push_back(num/con);//将平均值放入ans
                con=0;//刷新和和个数
                num=0;
                if(!que.empty())que.push(p);//如果队列中还有元素，将结尾标志再次入队，若队列中已经没有元素，循环结束
            }
        }
        return ans;
    }
};
```







## 已知前序中序构造二叉树



[105. 从前序与中序遍历序列构造二叉树 - 力扣（LeetCode）](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/submissions/)

![image-20230111204534206](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20230111204534206.png)

```
先序遍历：根节点 左子树 右子树
中序遍历：左子树 根节点 右子树
先将前序遍历的第一个节点看作根节点；
在中序遍历序列中找到该节点，其左边的节点为根节点的左子树，右边的节点为根节点的右子树；
然后根据左右子树再两个序列中的范围分别构造其左右子树。
优化：再中序遍历序列中找根节点，正常应该遍历来找，可以空间换时间，用map存一下。
```

```c
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    unordered_map<int,int>m;
    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
        //将节点值和中序遍历的下标保存下来，以便查找根节点
        for(int i=0;i<inorder.size();i++)m[inorder[i]]=i;
        //前序序列 中序序列 前序该树范围 中序该树范围
        return build(preorder,inorder,0,preorder.size()-1,0,inorder.size()-1);
    }

    //参数都为下标
    TreeNode* build(vector<int>& preorder, vector<int>& inorder,int pleft,int pright,int ileft,int iright){
        if(pright<pleft||iright<ileft)return nullptr;//没有范围，返回空
        TreeNode* root=new TreeNode(preorder[pleft]);//根节点
        int cen=m[preorder[pleft]];//根节点在中序遍历中的位置
        int leftnum=cen-ileft;//左子树的节点个数
        int rightnum=iright-cen;//右子树的节点个数
        //构建左子树
        root->left=build(preorder,inorder,pleft+1,pleft+leftnum,ileft,cen-1);
        //构建右子树
        root->right=build(preorder,inorder,pleft+leftnum+1,pright,cen+1,iright);
        return root;//返回根节点
    }
};
```







## 恢复二叉搜索树

[99. 恢复二叉搜索树 - 力扣（LeetCode）](https://leetcode.cn/problems/recover-binary-search-tree/)

![image-20230314201956673](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20230314201956673.png)

```
中序遍历（遍历结果为从小到大）
找出不符合排列的点
第一次出现前一个数比后一个数大（错误节点为前一个数）
第二次出现（错误节点为后一个数）
如果只出现过一次（错误节点为该相邻的两个节点）
交换
```

```c
class Solution {
public:
    TreeNode* last,*next;//遍历，用于比较相邻两个节点的大小
    TreeNode* problem[2];//有问题的节点
    int flag;//标志位（用于存储问题节点）
    void zhong(TreeNode* root){
        if(root==nullptr){
            return;
        }
        zhong(root->left);
        if(next==nullptr)next=root;
        last=next;
        next=root;
        if(last->val>next->val){
            //第二次出现（错误节点为后一个数）
            if(flag==1)problem[1]=next;
            //第一次出现前一个数比后一个数大（错误节点为前一个数）
            else problem[flag]=last;
            flag++;
            //如果只出现过一次（错误节点为该相邻的两个节点）
        if(flag==1)problem[1]=next;           
        }
        zhong(root->right);
    }
    void recoverTree(TreeNode* root) {
        next=nullptr;
        flag=0;
        zhong(root);
        swap(problem[0]->val,problem[1]->val);
    }
};
```







## 修剪二叉搜索树

[669. 修剪二叉搜索树 - 力扣（LeetCode）](https://leetcode.cn/problems/trim-a-binary-search-tree/submissions/)

![image-20230314213129727](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20230314213129727.png)

```
如果root节点的值小于最小值：返回对右节点的修剪
如果root节点的值大于最大值，返回对左节点的修剪
如果root节点的值符合规定
修剪根的左子树和右子树
```

```c
class Solution {
public:
    TreeNode* trimBST(TreeNode* root, int low, int high) {
            if(root==nullptr)return root;
            if(root->val<low){
                return trimBST(root->right,low,high);
            }else if(root->val>high){
                return trimBST(root->left,low,high);
            }else{
                root->left=trimBST(root->left,low,high);
                root->right=trimBST(root->right,low,high);
                return root;
            }
    }
};
```







## 实现前缀树

[208. 实现 Trie (前缀树) - 力扣（LeetCode）](https://leetcode.cn/problems/implement-trie-prefix-tree/)

![image-20230319121116848](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20230319121116848.png)

```c
class Trie {
public:
    Trie* next[26];//子节点（代表26个字母，如果有值，说明该字母在树中）
    bool end;//该节点是否为某一单词的末尾
    Trie() {
        memset(next,0,sizeof(next));
        end=false;
    }
    
    void insert(string word) {
        Trie* node=this;
        for(int i=0;i<word.size();i++){
            int a=word[i]-'a';
            if(node->next[a]==nullptr){//如果为空 插入节点
                node->next[a]=new Trie;
            }
            node=node->next[a];
        }
        node->end=true;//末尾字母标记
    }
    
    bool search(string word) {
        Trie* node=this;
        for(int i=0;i<word.size();i++){
            if(node->next[word[i]-'a']==nullptr)return false;
            node=node->next[word[i]-'a'];
        }
        if(node->end)return true;
        return false;
    }
    
    bool startsWith(string prefix) {
        Trie* node=this;
        for(int i=0;i<prefix.size();i++){
            if(node->next[prefix[i]-'a']==nullptr)return false;
            node=node->next[prefix[i]-'a'];
        }
        return true;
    }
};

/**
 * Your Trie object will be instantiated and called as such:
 * Trie* obj = new Trie();
 * obj->insert(word);
 * bool param_2 = obj->search(word);
 * bool param_3 = obj->startsWith(prefix);
 */
```







## 翻转二叉树

[226. 翻转二叉树 - 力扣（LeetCode）](https://leetcode.cn/problems/invert-binary-tree/)

![image-20230319121352689](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20230319121352689.png)

```c
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        if(root==nullptr)return nullptr;
        //交换左右子节点
        swap(root->left,root->right);
        //翻转左子树
        invertTree(root->left);
        //翻转右子树
        invertTree(root->right);
        return root;
    }
};
```







## 另一棵树的子树

[572. 另一棵树的子树 - 力扣（LeetCode）](https://leetcode.cn/problems/subtree-of-another-tree/)

![image-20230319121546696](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20230319121546696.png)

```c
//从一相等节点触发，深度优先遍历两个数是否相等
bool equal(TreeNode* a,TreeNode* b){
    if(!a&&b)return false;
    if(!b&&a)return false;
    if(!b&&!a)return true;
    return (a->val==b->val)&&equal(a->left,b->left)&&equal(a->right,b->right);
    return false;
}

//判断原树上的节点和目标树的根节点是否相等，如果相等：判断是否为子树；如果不相等，继续判断其左右子树的的节点是否与目标树的根节点相等，只要有一个相等即可。
class Solution {
public:
    bool isSubtree(TreeNode* root, TreeNode* subRoot) {
        if(!root)return false;
        if(root->val==subRoot->val){
            if(equal(root,subRoot)){
                return true;
            }
        }
        return isSubtree(root->left,subRoot)||isSubtree(root->right,subRoot);
    }
};
```







## 左叶子之和

[404. 左叶子之和 - 力扣（LeetCode）](https://leetcode.cn/problems/sum-of-left-leaves/)

![image-20230319121957972](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20230319121957972.png)

```c
class Solution {
public:
    int sumOfLeftLeaves(TreeNode* root) {
        int sum=0;
        if(!root)return 0;
        if(root->left&&!root->left->left&&!root->left->right)sum+=root->left->val;
        return sum+sumOfLeftLeaves(root->left)+sumOfLeftLeaves(root->right);
    }
};
```







## 找树左下角的值

[513. 找树左下角的值 - 力扣（LeetCode）](https://leetcode.cn/problems/find-bottom-left-tree-value/)

![image-20230319122331035](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20230319122331035.png)

```c
//深度优先遍历，找到叶子节点，如果该叶子节点的层数大于最大深度，更新num
class Solution {
public:
    int num;
    int depth=0;
    void dfs(TreeNode* node,int p){
        if(!node)return;
        if(!node->left&&!node->right){
            if(p>depth){
                num=node->val;
                depth=p;
            }
        }
            dfs(node->left,p+1);
            dfs(node->right,p+1);
    }
    int findBottomLeftValue(TreeNode* root){
        dfs(root,1);
        return num;
    }
};
```

