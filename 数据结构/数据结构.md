

# 一、复杂度





## 1. 时间复杂度



**时间复杂度**：代码执行的次数



时间复杂度计算**遵循的原则**：

1.复杂度与具体的常系数无关

2.多项式级复杂度，需要选择最高次幂作为结果

3.O( 1 )：表示某个任务通过有限可数的资源范围内即可完成

- **注意：有限可数：与输入的数据量无关**



**经验性结论：**

1.一个顺序结构的代码，时间复杂度是O(1)

2.采用分治法的二分策略，时间复杂度为O(log2底n)

3.一个简单的循环，时间复杂度为O(n)

4.两个顺序执行的循环，时间复杂度取最高项

5.两个嵌套的for循环，O(n*n)





## 1.1 递归的时间复杂度



```
T(n)= aT(n/b)+f(n)
n:数据规模
T：time 时间消耗
计算：比较n^logba（n的log以b为底a的对数次幂）和f(n)哪个大，大的即为整体时间复杂度，若二者相同，时间复杂度为：n^logba*log2n（n的log以b为底a的对数次幂 乘以 log以2为底n的对数）

以归并排序(分治)为例：
T(n)={ 1,n=1 ; 2T(n/2)+n,n>1 }
（将整体n分成了两部分，一部分的时间为T（n/2）(b=2)，一共两份a=2,排序时需遍历，消耗为n（f(n)=n））
T(n)= 2T(n/2)+f(n)
计算：a=2 b=2 n^logba=n;  f(n)=n;  二者相同，时间复杂度为：n^logba*log2n=nlog2n;

```







## 2. 空间复杂度



**空间复杂度**

如果消耗的空间不随着输入数据量的变化而变化，则空间复杂度为O(1)













# 二、链表



## 1. 链表

```c++
typedef struct Node
{
	int val;
	struct Node* next;
}Node, * PNode;

PNode head, end;

//创建
void add()
{
	printf("输入节点个数：");
	int a;
	scanf("%d", &a);
	while (a--)
	{
		printf("输入节点数据：");
		int val;
		scanf("%d", &val);
		PNode p = (PNode)malloc(sizeof(Node));
		p->val = val;
		p->next = NULL;
		if (head == NULL)head = p;
		else end->next = p;
		end = p;
	}
}
int main()
{
	head = NULL;
	end = NULL;
	add();
    
	//遍历
	PNode p = head;
	while (p != NULL)
	{
		printf("%d ", p->val);
		p = p->next;
	}
}
```



## 2.1 链表倒置

```c++
//A -> B -> C -> D -> NULL(原)
//三个指针
//NULL <- A <- B <- C <- D(终)
// P1     P2   P3

//头插法（三指针法）时：o(n) 空：o(1)
void aa()
{
	if (head == NULL || head->next == NULL)return;
	PNode p1, p2, p3;
	p1 = NULL;
	p2 = head;
	p3 = head->next;
	while (p3 != NULL)
	{
		//断开、改项
		p2->next = p1;
		//移动
		p1 = p2;
		p2 = p3;
		p3 = p3->next;
	}
	p2->next = p1;
	head = p2;
}
```



## 2.2 链表折叠

```c++
//A-B-C-D-1-2-3-4(原)
//A-4-B-3-C-2-D-1(终)
中间断开，后半段倒置
//A-B-C-D
//4-3-2-1
合并
//三个指针
p1->A  P2->4  P3->3
```

![image-20220903191012742](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20220903191012742.png)





## 2.3 回文链表

```c++
//判断回文
//A-B-C-D-D-C-B-A
中间断开，后半段倒置。
比较
```





## 3.  复杂链表的复制



```
题目
```

![image-20220904092844186](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20220904092844186.png)

------

```
解法
```

![image-20220904094949473](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20220904094949473.png)







## 4. 链表相交



​		**判断两个单向链表是否相交；如果相交，找到交点。**

![image-20220904111905434](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20220904111905434.png)







## 5. 环 



​		**判断一个单向链表是否有环**

```
法1：变形
```

![image-20220904182626550](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20220904182626550.png)

```
法2：差值
```

![image-20220904184555133](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20220904184555133.png)

```
法2.2：快慢指针
```

![image-20220905085523383](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20220905085523383.png)

```
法3：倒置
```

![image-20220905082740061](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20220905082740061.png)









# 三、栈和队列



## 1. 栈区和堆区的区别



1. 申请空间和回收空间的方式不一样：堆区空间需要申请，手动回收；栈区定义后自动分配，自动回收。
2. 生命周期不同：栈区生命周期只在他所处的{}中；堆区生命周期从申请到释放。
3. 申请效率不同：栈区空间连续，申请很快；堆区空间不连续，通过链表遍历查找合适空间，申请效率较低。
4. 空间地址顺序：栈区空间随定义顺序先大地址，再小地址。
5. 内存碎片：栈区不会产生内存碎片；堆区会。
6. 堆区没有变量，只存储地址；栈区会存储局部变量和函数入口地址。







## 2. 堆空间的地址传递

```c++
//1.值传递，传过去的p=NULL,malloc只给p开辟空间，对q没有影响
void fun(char *p)
{
    p=(char*)malloc(100);
}
int main()
{
    char *q=NULL;
    fun(q);
    strcpy(q,"haha");//报错，q是没有指向空间的
}

//2.p接收的是ss指向的空间
struct s
{
    char *pp;
}
void fun(s *p)
{
    p->pp=(char*)malloc(100);
}
int main()
{
    s *ss=malloc(...);
    fun(ss);
    strcpy(ss->q,"haha");//可行
}
```







## 3. stack（栈）FILO



```c++
#include<stdio.h>
#include<malloc.h>
#include<iostream>
using namespace std;

//节点结构体
typedef struct node_
{
	int val;
	struct node_* next;
}node, * pnode;

//栈结构体
typedef struct stack_
{
	pnode top;
	int size;
}stack, * pstack;

//栈初始化
pstack init()
{
	pstack p = (pstack)malloc(sizeof(stack));
	p->size = 0;
	p->top = NULL;
	return p;
}

//入栈
void push(pstack p, int a)
{
	pnode ne = (pnode)malloc(sizeof(node));
	ne->val = a;
	ne->next = p->top;
	p->top = ne;
	p->size++;
}

//出栈
void pop(pstack p)
{
	if (p->top == NULL)return;
	pnode pn = p->top;
	p->top = p->top->next;
	free(pn);
	pn = NULL;
	p->size--;
}

//清空
void clear(pstack p)
{
	while (p->size) pop(p);
}

//销毁
void destroy(pstack *p)
{
	clear(*p);
	free(*p);
	*p = NULL;
}

//获取栈顶节点
pnode gettop(pstack p)
{
	if (p != NULL)return p->top;
	return NULL;
}

//站内元素数量
int getcount(pstack p)
{
	if (p != NULL)return p->size;
	return 0;
}

//判断是否为空
int empty(pstack p)
{
	if (p == NULL)return 0;
	return p->size ? 1 : 0;
}

int main()
{
	pstack p = init();
	push(p, 1);
	push(p, 2);
	push(p, 3);
	push(p, 4);
	printf("%d", empty(p));
	clear(p);
	printf("%d", empty(p));
	pnode no= p->top;
	while (no != NULL)
	{
		printf("%d", no->val);
		no = no->next;
	}
	system("pause");
}
```







## 4. queue（队列）FIFO



```c++
#include<stdio.h>
#include<malloc.h>

//尾添加，头删除
typedef struct node_
{
	int data;
	struct node_* next;
}node,*pnode;

typedef struct list_
{
	pnode head;
	pnode re;
}list,*plist;

plist init()
{
	plist p = (plist)malloc(sizeof(list));
	p->head = NULL;
	p->re = NULL;
	return p;
}

void push(plist p,int a)
{
	pnode no = (pnode)malloc(sizeof(node));
	no->data = a;
	no->next = NULL;
	if (!p->head)
	{
		p->head = no;
		p->re = no;
	}
	else
	{
		p->re->next = no;
		p->re = no;
	}
}

void pop(plist p)
{
	if (!p->head)return;
	pnode pp = p->head;
	p->head = p->head->next;
	free(pp);
	pp = NULL;
}

int isempty(plist p)
{
	if (!p->head)return 1;
	return 0;
}

int main()
{
	plist l = init();
	push(l, 1);
	push(l, 2);
	push(l, 3);
	push(l, 4);
	pop(l);
	printf("%d", isempty(l));
	pnode no = l->head;
	while (no != NULL)
	{
		printf("%d", no->data);
		no = no->next;
	}
}
```







## 括号匹配



​		一万个括号，判断他们是否匹配

```c++
//例如：((()))()(())()
如果是左括号，就入栈；如果是有括号，就出栈；
当不能再出栈或遍历完后栈内还有元素，则不匹配。
```

```c++
#include<iostream>
#include<stack>
#include<string>
using namespace std;

bool judge(string p,int len)
{
	stack<int> s;
	for (int a=0;a<len;a++)
	{
		if (p[a] == '(')s.push(a);
		else if (p[a] == ')')
		{
			if (s.empty())return false;
			s.pop();
		}
	}
	if (s.empty())return true;
	return false;
}

int main()
{
	string s = "(()())()()()()()(";
	cout<<judge(s, 17);
	return 0;
}
```







## 约瑟夫环



​		n个人排成一队，从第一个开始报数，数到3的人出队；最后一个人报完数后回到第一个人，直到队伍中只剩一个人。

![image-20220921212435467](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20220921212435467.png)



```
1.循环链表：
定义一个循环链表、一个计数器、两个遍历指针
遍历，数到3时删除节点，重置计数器
```

```
2.队列：
从头开始遍历，每遍历一个就出队；如果当前计数器不是3，就入队；是3，就删掉；直到队列中只有一个元素。
```

```c++
int yue(queue<int>que)
{
	int count = 0;
	while (que.size() != 1)
	{
		int a = que.front();
		que.pop();
		count++;
		if (count != 3)que.push(a);
		else count = 0;
	}
	return que.front();
}
```

```
3.数组：
定义两个变量，一个用来计数，一个用来存储数组内的剩余元素个数。
从头开始遍历，若计数器到3，该数组内元素置为-1，重置计数器，剩余个数-1；
当剩余个数为1时，循环结束。
```

```
4.数学解法（百度）
```







## 两个栈实现队列



```
入栈 出栈 入栈 出栈
```

```c++
#include<iostream>
#include<stack>
using namespace std;

typedef struct queue
{
	stack<int>a;
	stack<int>b;
}queue,*pqueue;


//入
void push(pqueue que,int da)
{
	while (!que->b.empty())
	{
		int n = que->b.top();
		que->b.pop();
		que->a.push(n);
	}
	que->a.push(da);
	while (!que->a.empty())
	{
		int n = que->a.top();
		que->a.pop();
		que->b.push(n);
	}
}


//出
void pop(pqueue que)
{
	if (!que->b.empty())
	{
		cout << que->b.top();
		que->b.pop();
	}
}

int main()
{
	queue que;
	push(&que,1);
	push(&que,2);
	push(&que,3);
	push(&que,4);
	push(&que,5);
	pop(&que);
	pop(&que);
	pop(&que);
	pop(&que);
	pop(&que);
}
```









## 两个队列实现栈



```
入1队 入2队 入栈 出栈
```

```c++
typedef struct stack_
{
	queue<int>q1;
	queue<int>q2;
}*pstack;

void push_(pstack p,int data)
{
	if (p->q1.size() == 0)
	{
		p->q2.push(data);
	}
	else
	{
		p->q1.push(data);
	}
}

void pop(pstack p)
{
	if (p->q1.size() == 0 && p->q2.size() == 0)return;
	if (p->q1.size() != 0)
	{
		while (p->q1.size() > 1)
		{
			int a = p->q1.front();
			p->q1.pop();
			p->q2.push(a);
		}
		p->q1.pop();
	}
	else
	{
		while (p->q2.size() > 1)
		{
			int a = p->q2.front();
			p->q2.pop();
			p->q1.push(a);
		}
		p->q2.pop();
	}
}
```









# 四、字符串





## 1.基本知识



```c++
char *p="haha";		//A
char pp[]="haha";	//B
//数组名是数组首地址
cout<<sizeof(p)<<sizeof(pp);	//5 5:字符串末尾自动添加\0，占一个字节
cout<<*p<<*pp;				   //h h
p++;						  //可以，修改指针所指向的地址
//pp++;							不可以

//普通类型数组在作为形参时，必须传长度。
//void a(int str[]){} str实质上是指针，不能通过sizeof(str/str[0])来计算长度

//字符的ASCII码值范围：0-255
//'0':48
```







## 替换空格（有时间写一下）



​		给一个空间足够大的字符串，将里面的空格都换成china

```c++
1.申请一块额外的空间，遍历原字符串；如果是字母，就存进新空间；如果是空格，就在新空间存china
```

```c++
2.先遍历一次，记下空格的个数；再从后往前遍历一次，一个一个元素挪。如：有三个空格，从后往前遍历，第一个空格前的所有元素向后移12位，遇到空格时，插入anihc。
```

```c++
```









## 单词倒置（）



​		给一串句子，把每个单词倒置

```
1.扩充空间，倒置
```

```
2.先把整个句子倒置，然后倒置每一个单词，使单词变为原始排序
```









## 字符移位



​		将字符右移k(3)位：abcdefg->efgabcd

```
1.扩充：abcdefgabcdefg 从n-k开始往后读n个：abcd efgabcd efg
```

```
2.先定义一个数组存后k个，再申请一个数组存前n-k个，再拼接在一起
```

```
3.队列：前面n-k个依次出队入队
```

```
4.整体倒置，再前k个倒置，再后n-k个倒置
```

```c++
#include<iostream>
using namespace std;
int main()
{
	//后移3位
	int n = 7;
	char s[] = "abcdefg";
	for (int a = 0; a < n / 2; a++)		//整体倒置
	{
		char c = s[a];
		s[a] = s[n - 1 - a];
		s[n - 1 - a] = c;
	}
	printf("%s\n", s);
	n = 3;
	for (int a = 0; a < n / 2; a++)		//前k个倒置
	{
		char c = s[a];
		s[a] = s[n - 1 - a];
		s[n - 1 - a] = c;
	}
	printf("%s\n", s);
	n = 7;
	for (int a = 3; a < (n+3) / 2; a++)	 //后n-k个倒置
	{
		char c = s[a];
		s[a] = s[n+3 - 1 - a];
		s[n+3 - 1 - a] = c;
	}
	printf("%s\n", s);
}
```









## KMP字符串匹配算法



​		前缀后缀：abcabc

​	前缀：a ab abc abca abcab 

​	后缀：c bc abc cabc bcabc

​	最大相等前后缀：abc



​		创建一个数组，对于每一个字符n，记录到当前位置的最大前后缀（a如果n前元素的数组值为0，则与第一个比较；若相等，即为1；若不相等，即为0。若数组值不为0，则与该值+1的字符比较，若相等，则记数值+1；若不相等，把该字符当做是前一个元素+1的位置，再回到a）

```
串：abcabcdabcabca
组：00012301234564

串：aababaaaababaab
组：010101222345673
```



​		KMP算法：用于遍历原串的变量不回头，只来回移动用于遍历匹配字符串的变量。

​		二者都从头开始遍历（pa,pb），当遇到不一样的字符时（b[n]）：查看该字符的前一个对应的数组值（arr[n-1]），匹配串的指针回到该数组值的下标位置（pb=arr[n-1]）；继续比较，直到pb=0或二者相同了，pa继续向后遍历；重复操作，直到匹配串遍历完（返回pa-b串的长度，即为匹配字符串第一次出现的位置）或原串遍历完（匹配字符串未出现）。

```
原串a：  abcabceabcabcabcabcdabcabcfabca...
匹配串b：abcabcdabcabcf
数组arr：00012301234560
```



```c++
#include<iostream>
#include<string>
using namespace std;

int KMP(string a,string b)
{
	//数组
	int *next=new int[b.size()];
	next[0] = 0;
	int i = 1, j = i - 1;
	while (i < b.length())
	{
		if (b[i] == b[next[j]])next[i] = next[j] + 1;
		else
		{
			if (next[j] == 0)next[i] = 0;
			else
			{
				j = next[j] - 1;
				continue;
			}
		}
		i++;
		j = i - 1;
	}
	//匹配
	int pa = 0, pb = 0;
	while (pa < a.length() && pb < b.length())
	{
		if (a[pa] == b[pb])
		{
			pa++;
			pb++;
		}
		else
		{
			if (pb == 0)pa++;
			else pb = next[pb - 1];
		}
	}
	if (pb == b.size())return pa - pb;
	return -1;
}

int main()
{
	string a= "abcabceabcabcabcabcdabcabcfabca";
	string b= "abcabcdabcabcf";
	cout << KMP(a, b);
}
```







## Sunday字符串匹配算法



​		从第i个（原串）开始比较，若匹配失败，从i向后数len（匹配字符串长度）个，找到该元素在匹配字符串最后出现的位置，两串“对齐”，再次比较。

```
原：wonadonnaceoawonderoaac
匹：wondero
1.wonadon
  wondero（匹配失败）找到n的下一个元素n在匹配串中最后出现的位置2,两个n对齐
2.onnaceo
  wondero（同上）a在匹配串中没有出现，跳到下一个元素
3.wondero
  wondero（匹配成功）
```

​		利用数组存储每个字符在匹配字符串中最后出现的位置，字符的范围是0-255，创建一个大小为256的数组，将字符当做下标，数据存储最后出现的位置（没出现的置为：-1（初始值为-1））。

```c++
int *next=new int[256];
memset(next,-1,sizeof(int)*256);
for(int a=0;a<match.size();a++)
    next[match[a]]=a;
```

​		完整代码

```c++
#include<iostream>
#include<string>
using namespace std;

int sunday(string str, string match)
{
    //数组
	if (str.empty() || match.empty())return -1;
	int next[256];
    //数组初始化
	memset(next, -1, sizeof(int) * 256);
    //赋值
	for (int a = 0; a < match.size(); a++)
		next[match[a]] = a;
    //匹配
	int head = 0, pm = 0, ps = 0;
	while (str[ps] && match[pm])
	{
		if (match[pm] == str[ps])
		{
			ps++;
			pm++;
		}
		else
		{
			if (head + match.size() < str.size())
			{
				ps = head + match.size() - next[str[head + match.size()]];
				head = ps;
				pm = 0;
			}
			else return -1;
		}
	}
	if (match[pm])return -1;
	return head;
}

int main()
{
	cout << sunday("wonadonnaceoawonderoaac", "ceoaw");
}
```







# 五、哈希表 HashTable



1.散列函数：key%n

```
数据：24 11 3 105 66 21 23 14 225 9 31
数组：0  1  2  3  4  5  6  7   8  9 10
     11    24 3        105
     66（冲突）
```



2.解决冲突方法：

（1）开放地址法：

​				线性探测法：一步一步往后遍历，遇空就钻

​				线性探测再散列（二次探测）：+-1，+-4，+-9，+-16，+-25......（先右1，再左1，再右4，再左4...）

- 装载因子：α=个数/表长>0.8时，需扩容，α越大，越容易发生冲突。

```
数据：24 11 3 105 66 21 23 14 225 9 31
数组：0  1  2  3  4  5   6  7   8  9 10
     11 66 24 3  23 225 105 14 31 9 21
```

（2）拉链法：

```
数据：24 11 3 105 66 21 23 14 225 9 31
数组：0  1  2  3  4  5   6  7  8  9 10
     11 23 24 3     225 105       9 21
     |        |                   |（链表）
     66       14                  31
```



完整代码

```c++
#include<iostream>
using namespace std;

//数组中存的链表
typedef struct Hash
{
	int value;
	struct Hash *next;
}hash_, * phash;

//建表
phash* createHashTable(int a[], int len)
{
	if (a == nullptr)return nullptr;
	phash* p = new phash[len];
	memset(p, 0, sizeof(phash) * len);
	for (int i = 0; i < len; i++)
	{
		phash ph = new hash_{ a[i],p[a[i] % len]};
		p[a[i] % len] = ph;
	}
	return p;
}

//搜索
bool hashsearch(phash* p, int len, int x)
{
	if (p == nullptr)return false;
	phash pp = p[x % len];
	while (pp)
	{
		if (pp->value == x)return true;
		pp = pp->next;
	}
	return false;
}


int main()
{
	int a[] = { 1,2,54,6,245,1246,68,21 };
	phash* p = createHashTable(a, sizeof(a) / sizeof(a[0]));
	cout << hashsearch(p, sizeof(a) / sizeof(a[0]),124);
}
```









# · 跳跃列表（跳表Skip List）



- 既能快速插入，又能快速查找

有序链表：随机结构

![image-20221125200056406](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20221125200056406.png)















# 六、递归



​		递归：指在函数的定义中使用函数自身的方法。

1. 必须可以分解为若干个规模较小，但与原问题形式相同的子问题，并且这些子问题可以用完全相同的解决思路来解决。
2. 递归问题的演化过程是一个原问题从大到小拆解的过程，并且会有一个明确的终点。最后从这个临界点开始，把小问题的答案按原路返回，原问题得以解决。







## 斐波那契数列



```c++
//此种方法缺点：n越大，要计算的次数越多（2^n-1次）
//解决方法：创建一个数组，将每个计算过的n都存进数组里
int F(int n)
{
	if (n == 1 || n == 2)return 1;
	return F(n - 1) + F(n - 2);
}
```









## 小青蛙跳台阶



​		问题：小青蛙一次可以跳一级台阶，也可以跳两级台阶。现在共有n级台阶，有多少种跳法？



​		此问题为斐波那契数列的变种题，当跳一步时：有1+J(n-1)，跳两步时：有2+J(n-2)，所以返回还是J(n-1)+J(n-2)

```c++
int F(int n)
{
	if (n == 1 || n == 0)return 1;
	return F(n - 1) + F(n - 2);
}
```







## 链表倒序打印



```c++
void P(pnode p)
{
    if(p==nullptr)return;
    P(p->next);
    cout<<p->data;
}
```













# 七、分治





**分治法**：把一个大规模、高难度的问题，分解为若干个小规模、低难度的小问题。再将多个小问题的解合并成大问题的解。（大数据集才有优势）

1. 问题难度随着数据规模的缩小而降低
2. 问题可分割为若干个规模较小的问题
3. 解可合并
4. 子问题的解相互独立









## 二分搜索



```
每次都和中间的值作比较，
如果比中间值大，就继续和右半部分的中间值作比较；
如果比中间值小，就和左半部分的中间值作比较。
```

```c++
//循环法
int BinaryChop2(int* a, int len, int x)
{
	int l=0,r=len-1;
	while (l <= r)
	{
		int n = l + (r - l) / 2;
		if (x == a[n])return n;
		else if (x > a[n])l = n + 1;
		else r = n - 1;
	}return -1;
}
```

```c++
//递归法
int BinaryChop(int* a, int l, int r,int x)
{
	if (l == r)return a[l] == x?l:-1;
	int n = l + (r - l) / 2;
	if (x == a[n])return n;
	else if (x > a[n])BinaryChop(a, n + 1, r, x);
	else BinaryChop(a, l, n - 1, x);
}
```









## 快速幂



​		计算x的n次幂

```
递归
确定奇偶：
偶：x^(n/2)*x^(n/2)
奇：x*x^(n/2)*x^(n/2)
```

```c++
int FastExponentiation(int x,int n)
{
	if (n == 0)return 1;
	if (n == 1)return x;
	if (n % 2 == 0)
	{
		int va = FastExponentiation(x, n / 2);
		return va * va;
	}
	else
	{
		return x * FastExponentiation(x, n - 1);
	}
}
```









## 判断一个数是否为2的次幂



```
法1.
判断该数n是否为偶数：
若为奇数，判断完成，不是2的次幂
若为偶数，n/=2，继续判断奇偶。
直到==2，是；==1，不是。
```

```
法2.
一个数为2的次幂，则该数的二进制数只有一个1，判断即可
```

```
法3.
假设该数n的二进制为
10000000
则n-1的二进制为
01111111
二者做与操作n&(n-1)
00000000
n&(n-1)==0，即为2的次幂
```













# 八、回溯法







​		**回溯法**（BackTracking）：（树形）纵向递归，横向循环

​		**适用于**: 组合问题、分割问题、子集问题、排列问题、棋盘问题



回溯模板：

```
void backTracking(参数)
{
	if(终止条件)
	{
		结果收集;
		return;
	}
	for(集合元素)
	{
		处理节点；
		递归；
		回溯；
	}
}
```







## 全排列



全排列问题有两种：

1. 得到所有排列
2. 打印所有排列（以下为该种问题的解）

![image-20221015215111948](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20221015215111948.png)

方法：

1. 标记法：遍历过得标记一下，遍历到它是跳过
2. 交换法：把每个数都和当前层的第一个交换，剩下的全排列（此下）



代码：

```c++
void arrange(int* a, int len, int n)
{
	if (n == len)
	{
		for (int x = 0; x < len; x++)cout << a[x] << " ";//结果输出
		cout << endl;
		return;
	}
	for (int x = n; x < len; x++)
	{
		swap(a[n], a[x]);//处理节点：交换
		arrange(a, len, n + 1);//递归√
		swap(a[n], a[x]);//回溯：交换回来
	}
}
```









## 正则串匹配





```
原串：abbbca

匹配串：a*·b*ca（·代表任意字符，*代表其前面的字符可出现0~n次）
```

![image-20221019105655209](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20221019105655209.png)

```
#include<iostream>
#include<string>
using namespace std;

bool zzpp(string a, string b, int pa, int pb)
{
	if (pa == a.size() && pb == b.size())return true;
	else if (pa == a.size())return false;
	else if (pb == b.size())return false;
	if (b[pb + 1] != '*')
	{
		if (b[pb] == '.' || a[pa] == b[pb])return zzpp(a, b, pa + 1, pb + 1);
		else return false;
	}
	else
	{
		if (b[pb] != '.' && a[pa] != b[pb])return zzpp(a, b, pa, pb + 2);
		else return zzpp(a, b, pa, pb + 2) || zzpp(a, b, pa + 1, pb + 2) || zzpp(a, b, pa + 1, pb);
	}
}

int main()
{
	string a = "abbbca", b = "a*b*.a";
	cout << zzpp(a, b, 0, 0);
}
```









# 九、树（Tree）





## 1. 基本概念





### 树

![image-20221021221348923](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20221021221348923.png)

```
1：根节点
2：边
3：叶子结点
4：中间节点
·对于树：高度=深度
·对于节点（B）：高度（从下往上）：3 深度（从上往下）：2
·度：当前点有几个孩子结点  B:2 E:3 A:2
·路径长度：根节点到当前节点有几条边 I:3 F:2 C:1
```









### 二叉树

![image-20221021221744099](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20221021221744099.png)

```
1：左孩子
2：右孩子
3：左子树
4：右子树
```







### 满二叉树

![image-20221021222946098](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20221021222946098.png)

```
每一层都有最多的节点
可用顺序存储结构存储
```







### 完全二叉树

![image-20221021223027277](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20221021223027277.png)

```
最后一层可以有从右到左的连续的空缺
可用顺序存储结构存储
```







### 二叉树性质



1. k层的二叉树总结点数最多有2^k-1个
2. k层的二叉树总叶子节点数最多有2^(k-1)个
3. 在任一棵树中，度为0的节点总比度为2的节点多一个

![image-20221021222824081](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20221021222824081.png)

4. 有n个节点的完全二叉树高度为log₂N的向下取整+1

​		如：n=7 h=3;n=4 h=3

5. 完全二叉树长度为n从1开始编号，编号为i的节点，若满足2i<=n，则有左孩子（2i）；若满足2i+1<=n，则有右孩子（2i+1）。父亲节点的范围0--n/2

```
问题：有124个叶子节点的完全二叉树，总结点最多有多少个？
答：248个。  124（n0）+123（n2）+1（n1max）
```









### 二叉搜索树/排序二叉树（BST）



​		树中任意节点的值都比其左子树的值大，比其右子树的值小。

![image-20221021223859555](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20221021223859555.png)

​		插入一个17

![image-20221021223958815](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20221021223958815.png)











### 平衡二叉树（AVL）

​		

​		在BST的前提下，保证每个节点左右字数的高度差<=1。







## 2. 遍历



深度遍历：

​		前序遍历：根，左，右

​		中序遍历：左，根，右

​		后序遍历：左，右，根

广度遍历：

​		层序遍历：按从上往下，从左往右依次遍历。







### 递归遍历



```c++
//先序遍历递归
void Df(pnode p)
{
	if (!p)return;
	cout << p->data << " ";
	Df(p->left);
	Df(p->right);
}

//中序遍历递归
void Dz(pnode p)
{
	if (!p)return;
	Dz(p->left);
	cout << p->data << " ";
	Dz(p->right);
}

//后序遍历递归
void Dh(pnode p)
{
	if (!p)return;
	Dh(p->left);
	Dh(p->right);
	cout << p->data << " ";
}
```





### 非递归遍历



```c++
//层序遍历(广度，队列实现)
void cengxu(pnode p)
{
	queue<pnode>que;
	if (p == nullptr)return;
	que.push(p);
	while (!que.empty())
	{
		if (que.front()->left)que.push(que.front()->left);
		if (que.front()->right)que.push(que.front()->right);
		cout << que.front()->data << " ";
		que.pop();
	}
}

//先序遍历（栈实现）
//从根节点开始遍历，若不为空，将其数据输出，入栈，遍历其左节点，重复操作
//若为空，遍历栈顶的右节点，出栈，重复上步操作
//直到栈为空
void xianxu(pnode p)
{
	if (p == nullptr)return;
	stack<pnode>sta;
	while (1)
	{
		while (p)
		{
			sta.push(p);
			cout << p->data << " ";
			p = p->left;
		}
		if (sta.empty())break;
		p = sta.top();
		sta.pop();
		p = p->right;
	}
}

//中序遍历（栈实现）
//从根节点开始遍历，若不为空，入栈，遍历其左节点，重复操作
//若为空，输出栈顶元素数据，遍历栈顶的右节点，出栈，重复上步操作
//直到栈为空
void zhongxu(pnode p)
{
	if (p == nullptr)return;
	stack<pnode>sta;
	while (1)
	{
		while (p)
		{
			sta.push(p);
			p = p->left;
		}
		if (sta.empty())break;
		p = sta.top();
		cout << p->data << " ";
		sta.pop();
		p = p->right;
	}
}

//后序遍历(栈实现)
//从根节点开始遍历，若不为空，入栈，遍历其左节点，重复操作
//若为空，遍历栈顶的右节点，若无右节点或右节点已被打印，输出栈顶节点，标记栈顶节点，出栈，重复操作；反之，对栈顶右节点进行第一步操作。
//直到栈为空
void hou(pnode p)
{
	if (p == nullptr)return;
	stack<pnode>sta;
	pnode pp = nullptr;
	while (1)
	{
		while (p)
		{
			sta.push(p);
			p = p->left;
		}
		if (sta.empty())break;
		if (sta.top()->right == nullptr || sta.top()->right == pp)
		{
			cout << sta.top()->data << " ";
			pp = sta.top();
			sta.pop();
		}
		else p = sta.top()->right;
	}
}
```



















## 3. 二叉树的构造







### 根据两个序列构造



```
前序：BAGONFRKCDM
中序：GNOABRFDMCK

首先根据前序序列，B为根节点；在中序序列中找到B，在B左边的为B的左子树，在B右边的为B的右子树；根据前序序列的第二位A，和中序序列中A在B的左边知：A是B的左子树的根节点；G是A的左子树的根节点；O是G的右子树的根节点；N是O的左子树的根节点....
```







### 二叉树的创建（链表）



​		根据前序遍历顺序创建（根左右）

```
//0为结束标志
void createTree(pnode& p)
{
	int a;
	cin >> a;
	if (a == 0)return;
	p = new node(a);
	p->left = nullptr;
	p->right = nullptr;
	createTree(p->left);
	createTree(p->right);
}
```





### 完全二叉树的创建（数组）



​		根据下标连接父子节点（父：n   子：2n+1 2n+2）

```c++
pnode p = new node[]{ 15,4,3,1,6,9,7,12 };
int a = 0;
while (2 * a + 1 < 8)
{
	p[a].left = &p[2 * a + 1];
	if (2 * a + 2 < 8)p[a].right = &p[2 * a + 2];
	a++;
}
```









## 4. 排序二叉树（BST）





### BST的创建

```
若根节点为空，则该元素为根节点
若根节点不为空，与根节点进行比较；
若比根节点小，看根节点的左子节点是否为空，若为空，则该元素为根节点的左节点；若不为空，与根节点的左节点进行比较......
若比根节点大......
```

```c++
//造BST树
//BST中序遍历的顺序为递增
pnode crea(int* a, int len)
{
	pnode root=nullptr;//根
	for (int n = 0; n < len; n++)
	{
		pnode p = root;
		pnode pnew = new node(a[n]);//创建节点
		if (root == nullptr)root = pnew;//根为空，直接赋值
		else
		{
			while (p)
			{
				if (a[n] > p->data)//大于根
				{
					if (!p->right)//右子树为空，直接赋值
					{
						p->right = pnew;
						break;
					}
					else p = p->right;//不为空，遍历右子树
				}
				else//小于根，其他同上
				{
					if (!p->left)
					{
						p->left = pnew;
						break;
					}
					else p = p->left;
				}
			}
		}
	}
	return root;//返回根
}
```









### BST的删除

```
替换删除法：
链表：1 5 4 6 7 8 9
要删除6，先找到6的位置（此时若按普通删除方法，应标记6的上一个节点4，连到7）
使用替换删除法，不用找到4的位置，直接将6的下一个节点7替换到6的位置，然后连接8（1 5 4 7 7 8 9->1 5 4 7 8 9）
```

```
先找到待删除节点的位置，
若该节点无子节点，直接删除即可
若该节点有1个子节点，将子节点与待删节点的父节点相连即可
若该节点有2个子节点，将待删节点与该节点左子树的最大值（左子树的最右边）或右子树的最小值（右子树的最左边）进行数据替换：
被替换的节点若无子节点，直接将该叶子结点删除即可
若有一个子节点，将该子节点与其爷爷节点连接即可。
```

```c++
pnode dele(pnode p,int a)
{
	pnode head = p;
	pnode pf = nullptr;
	//查找待删节点
	while (p->data != a)
	{
		pf = p;
		p = a > p->data ? p->right : p->left;
	}

	//若有两个孩子，左子树最右值替换
	if (p->left && p->right)
	{
		pnode pnew = p;
		pf = p;
		p = p->left;
		while (p->right)
		{
			pf = p;
			p = p->right;
		}
		pnew->data = p->data;
	}

	//有1个或0个孩子
	pnode pnew = p->left ? p->left : p->right;
	//待删节点不为根节点
	if (pf)
	{
		if (pf->right==p)pf->right = pnew;
		else pf->left = pnew;
		delete(p);
		p = nullptr;
		return head;
	}
	//待删节点为根节点，换根
	else
	{
		delete(p);
		p = nullptr;
		return pnew;
	}
}
```









## 如何将排序二叉树转变成有序的双向链表



```
采用中序遍历的方法，将打印换成将节点插入双向链表（排序二叉树的中序遍历为递增排列）
```

```c++
//双向链表
typedef struct
{
	pnode head;
	pnode tail;
}list_;

//转变
void zhuan(pnode p,list_ &l)
{
	if (p == nullptr)return;
	zhuan(p->left,l);
	if (l.head==nullptr)l.head = p;
	else
	{
		l.tail->right = p;
		p->left = l.tail;
	}
	l.tail = p;
	zhuan(p->right,l);
}

//遍历
void print_(list_ l)
{
	pnode p=l.head;
	while (p)
	{
		cout << p->data << " ";
		p = p->right;
	}
}

//main
list_ l;
l.head = nullptr;//必须
l.tail = nullptr;
zhuan(root,l);
print_(l);
```









## 5. 二叉平衡树（AVL）







### 右旋



![image-20221107114641414](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20221107114641414.png)

```
从下往上变（三个儿子关系，三个父亲关系）
A左E E父A
B右A A父B
X子B B父X
```

```c++
//右旋
void rightxuan(pnode p)//A
{
	if (p == nullptr || p->left == nullptr)return;
	pnode pp = p->left;//B
	//三个儿子关系
	p->left = pp->right;//A左E
	pp->right = p;//B右A
	if (p->father)//X存在
	{//子B
		if (p->father->left == p)p->father->left = pp;
		else p->father->right = pp;
	}
	else//X不存在
	{
		root = pp;//换根
	}

	//三个父亲关系
	if (p->left)p->left->father = p;//E存在，E父A
	pp->father = p->father;//B父X or nullptr
	p->father = pp;//A父B
}
```



### 左旋

![image-20221107115304258](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20221107115304258.png)

```c++
//左旋
void leftxuan(pnode p)
{
	if (p == nullptr || p->right == nullptr)return;
	pnode pp = p->right;
	//三个儿子关系
	p->right = pp->left;
	pp->left = p;
	if (p->father)
	{
		if (p->father->left == p)p->father->left = pp;
		else p->father->right = pp;
	}
	else
	{
		root = pp;
	}

	//三个父亲关系
	if (p->right)p->right->father = p;
	pp->father = p->father;
	p->father = pp;
}
```





### 左右旋、右左旋

​		左的右和右的左引起的不平衡

![image-20221107125756703](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20221107125756703.png)

![image-20221107130813857](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20221107130813857.png)







## 6. 红黑树（RBT）





### 性质



1. 每个节点的颜色，要么是黑色，要么是红色
2. 根节点必须是黑色的
3. 认为终端节点是黑色的，称之为黑哨兵
4. 树中不允许两个红节点为父子节点
5. 任意节点向下出发，所能到达的各个终端节点（黑哨兵）的各条路径上，黑节点的数目必须是完全相同的

- 因为以上五条性质的限制，导致红黑树任意一条路径的长度不会超过其他路径的两倍
- 红黑树的搜索速度很快 O(logN)
- 红黑树的中序遍历为有序数列

![image-20221107132843612](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20221107132843612.png)





### 增加节点



​		新节点默认为**红色**（原因：若新节点为黑色，当节点放在树中时，到达该节点的路径上的黑色节点一定比别的路径多，导致其他路径都要大幅修改，**造成的影响过大**；若新节点为红色，如果该节点的父节点为黑色，则直接将该节点插入树中即可，不会破坏红黑树的结构，如果父节点为红色，则需变色（具体下面说））。

​		添加节点Z（初始红）时的各种可能情况：

![image-20221108194230245](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20221108194230245.png)

```
1.根为空：Z改为黑色，Z为根，结束。
2.根不为空：
2.1：父节点为黑色：Z直接放入，结束。
2.2：父节点为红色：
2.2.1：叔叔不为空（红）：父亲变黑色，爷爷变红色，叔叔变黑色；将爷爷视作新节点，重新调整上面的（根必为黑）：新节点的父亲为黑或为根，都不用改变，直接结束；若为红色，同2.2
2.2.2：叔叔为空（黑）：
2.2.2.1：父为爷左：
2.2.2.1.1：Z为父右（<型）：父为新Z，以Z为旋转点左旋（旋转点为红色）
2.2.2.1.2：Z为父左（/型）：父亲变黑，爷爷变红，以爷爷为旋转点右旋，结束
2.2.2.2：父为爷右：
2.2.2.2.1：Z为父左（>型）：父为新Z，以Z为旋转点右旋
2.2.2.2.2：Z为父右（\型）：父亲变黑，爷爷变红，以爷爷为旋转点左旋，结束

例：13 6 1 4 2 19 26 21 20 3
层：6 2 19 1 4 13 21 3 20 26
色：0 1 1 0 0 0 0 1 1 1

例：11,2,14,1,7,15,5,8,4
层：7 2 11 1 5 8 14 4 15
色：0 1 1 0 0 0 0 1 1
```

```c++
#include<iostream>
#include<queue>
using namespace std;
#define 红 0
#define 黑 1

//节点
typedef struct node_
{
	int data;
	struct node_* left;
	struct node_* right;
	struct node_* father;
	int color = 红;
	node_(int a,node_* p)
	{
		data = a;
		left = nullptr;
		right = nullptr;
		father = p;
	}
}node, * pnode; 

//根节点
pnode root;

//左旋
void leftxuan(pnode p)
{
	if (p == nullptr || p->right == nullptr)return;
	pnode pp = p->right;
	//三个儿子关系
	p->right = pp->left;
	pp->left = p;
	if (p->father) {
		if (p->father->left == p)p->father->left = pp;
		else p->father->right = pp;
	}
	else
	{
		root = pp;
	}

	//三个父亲关系
	if (p->right)p->right->father = p;
	pp->father = p->father;
	p->father = pp;
}

//右旋
void rightxuan(pnode p)
{
	if (p == nullptr || p->left == nullptr)return;
	pnode pp = p->left;
	//三个儿子关系
	p->left = pp->right;
	pp->right = p;
	if (p->father)
	{
		if (p->father->left == p)p->father->left = pp;
		else p->father->right = pp;
	}
	else
	{
		root = pp;
	}

	//三个父亲关系
	if (p->left)p->left->father = p;
	pp->father = p->father;
	p->father = pp;
}

//增加节点
void crea(int a){
	//根为空，新节点为根
	if (!root) {
		root = new node(a, nullptr);
		root->color = 黑;
		return;
	}

	else {
		//根不空，找到该节点的位置
		pnode p = root;//本身

		while (p){

			if (a > p->data){

				if (!p->right){
					p->right = new node(a,p);
					p = p->right;
					break;
				}

				else p = p->right;
			}

			else{

				if (!p->left){
					p->left = new node(a, p);
					p = p->left;
					break;
				}

				else p = p->left;
			}
		}

		//此时P指向树中的该节点,判断是否影响树的结构

		while (p) {

			//父为黑，不影响
			if (p->father->color == 黑)return;

			//父为红
			else {
				pnode pgrandpa = p->father->father;
				pnode puncle = p->father == pgrandpa->left ? pgrandpa->right : pgrandpa->left;//叔叔

				//叔为红
				if (puncle && puncle->color == 红) {
					p->father->color = 黑;
					puncle->color = 黑;

					//爷爷是根 不变色
					if (pgrandpa == root) return;

					//爷爷不是根，变色，重新判断
					pgrandpa->color = 红;
					p = pgrandpa;
					continue;
				}

				//叔为黑
				else {

					if (p->father == pgrandpa->left) {

						// <型
						if (p == p->father->right) {
							p = p->father;
							leftxuan(p);
						}

						// /型
						p->father->color = 黑;
						pgrandpa->color = 红;
						rightxuan(pgrandpa);
						return;
					}

					if (p->father == pgrandpa->right) {

						// >型
						if (p == p->father->left) {
							p = p->father;
							rightxuan(p);
						}

						// \型
						p->father->color = 黑;
						pgrandpa->color = 红;
						leftxuan(pgrandpa);
						return;
					}
				}
			}
		}
	}
}

//遍历（层序）
void cengxu(pnode p)
{
	queue<pnode>que;
	if (p == nullptr)return;
	que.push(p);
	while (!que.empty())
	{
		if (que.front()->left)que.push(que.front()->left);
		if (que.front()->right)que.push(que.front()->right);
		cout << que.front()->data << ":" << que.front()->color << " ";
		que.pop();
	}
}

int main(){
	int a[]{11,2,14,1,7,15,5,8,4};
	for (int n = 0; n < 9; n++) {
		crea(a[n]);
	}
	cengxu(root);
}
```











### 删除节点



​		只讨论真正要删的节点（只有两种情况：**一个孩子，没有孩子**（若有两个孩子，采用替换删除法（只替换数据，不替换颜色），讨论真正要删的节点））

![image-20221111211303842](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20221111211303842.png)

![image-20221112164334857](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20221112164334857.png)

```
1.被删除节点Z为根：
1.1：没孩子，直接删，树变为空树，结束。
1.2：有一个孩子，孩子成根，变为黑，结束。
2.Z为红色（一定没有孩子）：直接删除，结束。
3.Z为黑色：
3.1：有一个孩子（孩子一定为红）：孙子变黑，爷孙相连，爸爸Z删掉，结束。
3.2：没有孩子：
3.2.1：兄弟是红色：父亲变红，兄弟变黑，以父亲为旋转点旋转（转到兄弟的下面），更新兄弟（待删节点的兄弟变成了原兄弟节点的孩子，即现父亲节点的孩子），重新判断兄弟的颜色...；
3.2.2：兄弟是黑色：
//Z在进行讨论之前删除
3.2.2.1：兄弟的两个孩子是黑色：
3.2.2.1.1：父亲是红色：父亲变黑，兄弟变红，删除Z，结束。
3.2.2.1.2：父亲是黑色：兄弟变红，父亲为新的调整节点，重新调整...（看兄弟什么色...3.2.1）；
3.2.2.2：兄弟有红孩子：
3.2.2.2.1：左侄子红，右侄子黑：
3.2.2.2.1.1：兄弟是父亲的右孩子（父兄红侄：>型）：兄红，左侄子黑，以兄弟为旋转点右旋，更新兄弟、侄子；
3.2.2.2.1.2：兄弟是父亲的左孩子（父兄红侄：/型）：父亲的颜色给兄弟，父黑，左侄子黑，删Z，以父亲为旋转点右旋，结束。
3.2.2.2.2：右侄子红，左侄子黑：
3.2.2.2.2.1：兄弟是父亲的右孩子（父兄红侄：\型）：父亲的颜色给兄弟，父黑，右侄子黑，删Z，以父亲为旋转点左旋，结束。
3.2.2.2.2.2：兄弟是父亲的左孩子（父兄红侄：<型）：兄红，右侄子黑，以兄弟为旋转点左旋，更新兄弟、侄子；
```

```c++
#include<iostream>
#include<queue>
using namespace std;

enum 颜色{black,red};

//节点
typedef struct node {
	int value;
	int color = red;
	struct node* left;
	struct node* right;
	struct node* father;
	node(int a, node* p) {
		value = a;
		father = p;
		left = nullptr;
		right = nullptr;
	}
}node,*pnode;

//根节点
pnode root;

//前序遍历
void qian(pnode p) {
	if (!p)return;
	cout << p->value << ":" << p->color << " ";
	qian(p->left);
	qian(p->right);
}

//将节点插入树中
pnode insert_(int a) {
	pnode p = root;
	while (p!=nullptr) {
		if (a > p->value) {
			if (p->right == nullptr) {
				p->right = new node(a, p);
				return p->right;
			}
			p = p->right;
		}
		else {
			if (p->left == nullptr) {
				p->left = new node(a, p);
				return p->left;
			}
			p = p->left;
		}
	}
}

//在树中找到节点
pnode find_(int a) {
	pnode p = root;
	while (p) {
		if (a == p->value)return p;
		if (a > p->value)p = p->right;
		else p = p->left;
	}return nullptr;
}

//左旋
void leftxuan(pnode p) {
	if (!p || !p->right)return;
	//三儿
	pnode pp = p->right;
	p->right = pp->left;
	pp->left = p;
	if (p->father) {
		if (p->father->left == p)p->father->left = pp;
		else p->father->right = pp;
	}
	else root = pp;
	//三父
	pp->father = p->father;
	p->father = pp;
	if(p->right)p->right->father = p;
}

//右旋
void rightxuan(pnode p) {
	if (!p || !p->left)return;
	//三儿
	pnode pp = p->left;
	p->left = pp->right;
	pp->right = p;
	if (p->father) {
		if (p->father->left == p)p->father->left = pp;
		else p->father->right = pp;
	}
	else root = pp;
	//三父
	pp->father = p->father;
	p->father = pp;
	if (p->left)p->left->father = p;
}

//RBT添加
void create_(int a) {
	if (root == nullptr) {
		root = new node(a, nullptr);
		root->color = black;
		return;
	}
	else {
		//插入树中
		pnode p=insert_(a);
		//判断父节点颜色
		while (1) {
			if (p->father->color == black)return;
			else {
				//判断叔叔颜色
				pnode pfather = p->father;
				pnode pgrdpa = pfather->father;
				pnode puncle = pfather == pgrdpa->left ? pgrdpa->right : pgrdpa->left;
				//叔叔红
				if (puncle && puncle->color == red) {
					pfather->color = black;
					puncle->color = black;
					if (root == pgrdpa)return;
					pgrdpa->color = red;
					p = pgrdpa;
					continue;
				}
				//叔叔黑
				else {
					if (pfather == pgrdpa->left) {
						// <
						if (p == pfather->right) {
							p = pfather;
							leftxuan(p);
						}
						// /
						p->father->color = black;
						pgrdpa->color = red;
						rightxuan(pgrdpa);
						return;
					}
					if (pfather == pgrdpa->right) {
						// >
						if (p == pfather->left) {
							p = pfather;
							rightxuan(p);
						}
						// \ 
						p->father->color = black;
						pgrdpa->color = red;
						leftxuan(pgrdpa);
						return;
					}
				}
			}
		}
	}
}

//RBT删除
void delete_(int a) {
	//找到a
	pnode p = find_(a);
	//找到真正要删的节点
	if (p->left && p->right) {
		pnode pp = p->left;
		while (pp->right)pp = pp->right;
		p->value = pp->value;
		p = pp;
	}
	//判断是否为根
	if (p == root) {
		root = root->left ? root->left : root->right;
		if (root) {
			root->color = black;
			root->father = nullptr;
			delete(p);
			p = nullptr;
		}
		return;
	}
	//判断是否为红节点
	if(p->color==red){
		if (p->father->left == p)p->father->left = nullptr;
		else p->father->right = nullptr;
		delete(p);
		p = nullptr;
		return;
	}
	//判断是否为有一个孩子的黑节点
	if (p->left || p->right) {
		pnode pp = p->left ? p->left : p->right;
		pp->color = black;
		if (p->father->left == p)p->father->left = pp;
		else p->father->right = pp;
		pp->father = p->father;
		delete(p);
		p = nullptr;
		return;
	}
	//删除z
	pnode pfather = p->father;
	pnode pbrother = p == pfather->left ? pfather->right : pfather->left;
	if (p->father->left == p)p->father->left = nullptr;
	else p->father->right = nullptr;
	delete(p);
	p = nullptr;
	while (1) {
		if (p) {
			pnode pfather = p->father;
			pnode pbrother = p == pfather->left ? pfather->right : pfather->left;
		}
		//判断兄弟是否为红色
		if (pbrother->color == red) {
			pbrother->color = black;
			pfather->color = red;
			if (pbrother == pfather->left) {
				rightxuan(pfather);
				pbrother = pfather->left;
			}
			else {
				leftxuan(pfather);
				pbrother = pfather->right;
			}
			continue;
		}
		//兄弟是黑色
		//兄弟没有红孩子
		if ((!pbrother->left && !pbrother->right) ||
			(pbrother->left && pbrother->left->color == black &&
				pbrother->right && pbrother->right->color == black)) {
			//父亲是红色
			if (pfather->color == red) {
				pfather->color = black;
				pbrother->color = red;
				return;
			}
			//父亲是黑色
			if (pfather->color == black) {
				pbrother->color = red;
				p = pfather;
				if (p->father == nullptr)return;
				continue;
			}
		}
		else {
			pnode pzhi = pbrother->right->color == red ? pbrother->right : pbrother->left;
			// >
			if (pzhi == pbrother->left && pbrother == pfather->right) {
				pzhi->color = black;
				pbrother->color = red;
				rightxuan(pbrother);
				pbrother = pfather->right;
				pzhi = pbrother->right;
			}
			// <
			if (pzhi == pbrother->right && pbrother == pfather->left) {
				pzhi->color = black;
				pbrother->color = red;
				leftxuan(pbrother);
				pbrother = pfather->left;
				pzhi = pbrother->left;
			}
			// \ 
			if (pzhi == pbrother->right && pbrother == pfather->right) {
				pbrother->color = pfather->color;
				pfather->color = black;
				pzhi->color = black;
				leftxuan(pfather);
				return;
			}
			// /
			if (pzhi == pbrother->left && pbrother == pfather->left) {
				pbrother->color = pfather->color;
				pfather->color = black;
				pzhi->color = black;
				rightxuan(pfather);
				return;
			}
		}
	}
}

int main() {
	int a[]{ 13 ,6, 1, 4, 2, 19, 26, 21, 20, 3 };
	int a2[]{ 11,2,14,1,7,15,5,8,4 };
	int a3[]{ 11,2,14,1,7,15,5,8 };
	for (int n = 0; n < 8; n++) {
		create_(a3[n]);
	}
	qian(root);
	cout << endl;
	delete_(1);
	qian(root);
	cout << endl;
	delete_(8);
	qian(root);
	cout << endl;
	delete_(11);
	qian(root);
	cout << endl;
	delete_(14);
	qian(root);
	cout << endl;
	delete_(2);
	qian(root);
	cout << endl;
	delete_(5);
	qian(root);
	cout << endl;
	delete_(7);
	qian(root);
	cout << endl;
	delete_(15);
	qian(root);
}
```







### 应用



1. **STL中map、set的底层都是红黑树。multiset的底层也是红黑树**；

区别：

map和set ：map是key-value；set是value。

set和 multiset ：set不允许数值的重复插入；multiset允许数值的重复插入（放在左子树的最右侧或右子树的最左侧（和重复的值挨得最近））。



2. Linux的底层内存管理
3. ...

- 利用索引进行查找的数据结构（搜索速度快）：哈希表、红黑树、B+树
- 哈希表：空间固定，适合数据量少
- 红黑树：空间不固定，适合频繁增删、数量不确定的；适合在内存中使用
- B树：多路平衡搜索树，层高低；应用在文件系统中
- B+树：B树的改良版，多路平衡搜索树，层高低；适用于磁盘寻址、mysql







## 7. B+树



### B树





​		B树：多路平衡搜索树

​		使用B树的原因：在同样数据量的情况下，多路的层高会矮，搜索速度会更快。

​		阶：几阶即几叉；二阶B树：二叉树

![image-20221114125610425](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20221114125610425.png)

限制：

1. m叉树每个节点的关键字最多有m-1个
2. 根节点最少有一个关键字
3. 每个节点最少有 ceil (m/2)-1个关键字（ceil向上取整）
4. 每个节点的关键字都按照从小到大的顺序排列，每个关键字的左子树的所有关键字都小于它；右子树的关键字都大于它
5. 所有叶子节点都位于同一层







### B树插入



```
插入：（针对键值对，在B+树中叫做记录（键值对的别名））
如果要插入的记录已经存在，用新的value替换旧的value
1.根据要插入的key，找到叶子节点并插入。
2.判断当前关键字的个数是否小于等于m-1（关键字：key）：
小于等于就放入，操作结束。
大于：当前节点发生裂变，以中间节点为中心，分裂成左右两部分，中间关键字上升至父节点中，这个关键字的左子树指向分裂后的左半部分，右子树指向分裂后的右半部分；父亲节点为新的节点，重新判断（2）。
```

![image-20221114200337818](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20221114200337818.png)







### B树删除



```
关键字：key
1.如果当前被删除key在非叶子节点，则采取替换方式，用后继key（记录）替换要删除的key，最后要删除的关键字一定在叶子节点上。
2.删除之后，当前节点的关键字个数大于等于ceil(m/2)-1，则结束。
3.删除之后，当前节点的关键字个数小于ceil(m/2)-1，看兄弟节点的个数是否大于ceil(m/2)-1:
3.1大于：将父亲节点的关键字下移至当前节点，兄弟节点的关键字上移至父亲节点。
3.2等于：父亲节点的一个关键字下移，与当前节点以及当前节点的兄弟节点合并成一个新节点。
```

![image-20221115214111370](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20221115214111370.png)

![image-20221115214735399](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20221115214735399.png)

![image-20221115215653819](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20221115215653819.png)







### B+树



**可进行范围搜索（B树不行）**搜索时间复杂度：O（logmN）

1. B+树包含两种类型节点：内部节点（索引节点）、叶子节点（key-value）；根节点既可以是内部节点也可以是叶子节点。
2. B+树和B树的区别在于：B+树的内部节点不保存数据，只用于索引，所有记录都保存在叶子节点中。
3. m阶B+树内部节点最多有m-1个关键字
4. 关键字值在节点内部从小到大排列，左子树的key都小于它，右子树的key都大于它。
5. 每个叶子节点都存有指向相邻叶子节点的指针，叶子节点本身依关键字从小到大顺序链接（链表）。



### B+树添加



```
1.空树：创建一个叶子节点，把记录放入其中，此时这个节点也是根节点。
2.根据key值可以找到对应的叶子节点进行插入，判断当前节点关键字个数：
2.1：小于等于m-1：插入结束。
2.2：大于m-1：分裂，左叶子节点包含m/2个记录，右叶子节点包含剩余的记录。第m/2+1个记录的key进位到父亲节点中（索引节点）
3.若索引节点满足关键字小于等于m-1，结束
  若不满足，接着裂变。
```

![image-20221116153007523](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20221116153007523.png)







### B+树删除



```
1.删除叶子节点中对应的key，删除后看当前节点的关键字个数
1.1：若满足大于等与ceil(m/2)-1,结束。
1.2：若小于ceil(m/2)-1,看兄弟节点中关键字个数：
1.2.1：若大于ceil(m/2)-1，向兄弟节点借一个记录，同时，用借到的记录的key替换二者父亲的key
1.2.2：若不满足上条，当前节点和兄弟节点合并成一个新节点，同时删除父亲节点中的key
1.2.2.1：若索引节点大于等于ceil(m/2)-1，结束。
1.2.2.2：若不满足上条，看索引节点的兄弟节点关键字个数:
1.2.2.2.1:若兄弟富余，兄弟的key上移，父亲的key下移到当前节点
1.2.2.2.2：若兄弟不富余，当前节点和父亲下移的key和兄弟节点合并成一个新节点
```

![image-20221116205729317](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20221116205729317.png)

![image-20221116211351545](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20221116211351545.png)











## 8. 哈夫曼树



### 基本概念



​		哈夫曼树（最优二叉树）--》哈夫曼编码（实现无损压缩和恢复）

![image-20221117093934474](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20221117093934474.png)



### 哈夫曼树的构造



```
1.将所有带权节点按照权值大小排序
2.去前两个最小的拿走，构成新节点
3.新节点放回序列，重新排序，重复以上步骤
```

![image-20221117095956671](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20221117095956671.png)

```
五个字符abcde共100个，原占长度8*100=800位
进行哈夫曼编码后，a占4位，b占3位，c占1位,d占2位，e占4位，
共占4*10+3*15+1*40+2*30+4*5=205位。
极大程度实现了压缩！！
```

- 可知任意字符的哈夫曼编码都不是其他字符的前缀（c是0，其他编码没有0开头的...），避免了解压歧异。





### 压缩文件



1. 统计出现次数
2. 根据次数进行编码
3. 编码表放在压缩文件起始位置
4. 解压：根据压缩文件起始位置的编码表进行解压







## 9. 字典树（TrieTree）



### 认识字典树



![image-20221117141146557](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20221117141146557.png)



**字典树要求**：

1. 必须有根节点（根节点相当于字典中的目录）
2. 字典树的每个节点内并不包含字符



**字典树功能：**查找、计数、排序（前序遍历有序）

- **字典树占空间很大，但搜索速度很快**



### 字典树添加



```
1.struct:
*[](指针数组)
count标记：该字母是几个单词的末尾
2.root:根节点
3.addword：添加
遍历，看对应字符是否存在
若存在，就处理下一个字符
若不存在，申请一个节点，处理下一个字符
走到字符串的末尾，更改标记
```

![image-20221117144245793](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20221117144245793.png)







### 字典树查找



```
遍历，看对应字符是否存在：
若不存在，查找失败。
若存在，查找下一个字符；
遍历到最后一个字符时，检测当前末尾标志是否存在：
若无末尾标志，查找失败。
若有末尾标志。查找成功。
```





### 代码

```c++
//字典树结构
typedef struct  trietree {
	struct trietree* arr[26]{ nullptr };
	string str;//用于遍历
	int count = 0;
}trietree,*ptrietree;

//根
ptrietree root=new trietree;

//添加
void add(string str) {
	ptrietree p = root;
	for (char a : str) {
		if (!p->arr[a - 'a'])p->arr[a - 'a'] = new trietree;
		p = p->arr[a - 'a'];
	}
	p->count++;
	p->str = str;
}

//查找
string find(string str) {
	ptrietree p = root;
	string ans = "";
	for (char a : str) {
		if (!p->arr[a - 'a'])return "未找到该单词！";
		p = p->arr[a - 'a'];
		ans += a;
	}
	if (p->count != 0)return ans;
	else return"未找到该单词！";
}

//遍历：前序遍历的结果是有序的
void qian(ptrietree p) {
	if (!p)return;
	if (p->count != 0)cout << p->str<<endl;
	for (int a = 0; a < 26; a++) {
		qian(p->arr[a]);
	}
}
```











# 十、图（Graph）



## 1.基本概念

![image-20221118134434646](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20221118134434646.png)

```
1.顶点V：vertex
2.边：edge（有向图中也称作弧，起点位弧首，终点位弧尾）
G=(V,E)图是由顶点和边构成的
```

```
边：两点确定一条边。如上图2这条边，用（V1,V2）表示。

无向图：图中的边无次序关系个方向性（如上图）（（V1,V2）和（V2,V1）指的是一条边）

有向图：图中的边有次序关系个方向性（线段之间有箭头（V1,V2）和（V2,V1）指的不是一条边）

无向完全图：图中所有顶点间所有可能存在的边都存在

有向完全图：......（同上）
```

![image-20221118194627060](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20221118194627060.png)

```
无向连通图：图中所有的顶点之间，均有路径可通

有向连通图：图中所有相异的成对顶点之间均有路径可通（顶点可通过某条路径到达其余任何顶点）
```

![image-20221118195833847](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20221118195833847.png)

```
子图：G=（V,E）；G'=（V',E'），V'∈V，E'∈E，则称G'是G的子图
```

![image-20221118201308596](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20221118201308596.png)

```
极大连通子图（连通分量）：连通图的连通分量是指该图本身

强连通分量：有向连通图本身
```

```
依附：边（V1,V2）依附于点V1和V2

简单路径：除起点和终点外，其他顶点不重复经过

度：当前顶点关联几条边
有向图还分为入度和出度，有向图的度为出度和入度之和。
入度：指向几条边
出度：被几条边指向
```









## 2.存储方式



### 邻接矩阵（二维数组）

- 适用于便很多的图（利用率高）
- 一个图对应的邻接矩阵只有一种

![image-20221119103026551](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20221119103026551.png)



### 邻接链表

- 适用于边少的图（边多了，重复节点就多了）
- 一个图的邻接链表有很多种（边的顺序可以改变）

![image-20221119103501432](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20221119103501432.png)



###  区分有向图和无向图



1. 有向：<V1,V2> 无向：（V1,V2）
2. 看有无箭头
3. 无向图的邻接矩阵是对称的







## 3.图的创建



```
//邻接矩阵法
1.vertex个数
2.创建邻接矩阵，赋初值
3.放入边
```

```c++
#include<iostream>
#include<cstdio>
#include<vector>
using namespace std;

#define N 5
int mark[5]{ 0 };

typedef struct graph {
	int v=N;//顶点数
	int e;//边数
	int m[N][N]{0};
}grapg,*pgraph;

//创建
pgraph crea() {
	pgraph p = new graph;
	cout << "输入边的条数：";
	cin >> p->e;
	cout << "输入边：起点，终点";
	int a = p->e;
	while (a--) {
		int x, y;
		scanf_s("%d,%d", &x, &y);
		p->m[x - 1][y - 1] = 1;
		p->m[y - 1][x - 1] = 1;
	}
	return p;
}

//数组遍历
void show(pgraph &p) {
	for (int a = 0; a < N; a++) {
		for (int b = 0; b < N; b++) {
			cout << p->m[a][b] << " ";
		}
		cout << endl;
	}
}

int main() {
	/*cout << "输入顶点个数：";
	int n;
	cin >> n;
	vector<vector<int>> vec(n, vector<int>(n));
	//输入边的条数...
	cout << "输入边：起点，终点";
	int a = n;
	while (a--) {
		int x, y;
		scanf_s("%d,%d", &x, &y);
		vec[x-1][y-1] = 1;
		vec[y-1][x-1] = 1;
	}
	for (int a = 0; a < n; a++) {
		for (int b = 0; b < n; b++) {
			cout << vec[a][b] << " ";
		}
		cout << endl;
	}*/
	pgraph p = crea();
	show(p);
}
```







## 4.图的遍历



### 深度优先遍历（DFS）



```
1.mark数组
2.处理顶点
（1）打印 print
（2）标记 mark
（3）遍历 ：找到有关且未被处理的节点进行处理（重复2）
```

![image-20221120093638022](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20221120093638022.png)

```c++
//DFS遍历(回溯)
void DFS(pgraph &p,int x) {
	cout << x;
	mark[x-1] = 1;
	for (int a = 0; a < p->v; a++) {
		if (p->m[x-1][a]) {
			if (mark[a])continue;
			DFS(p, a+1);
		}
	}
}
```





### 广度优先遍历（BFS）



```
1.mark数组、queue队列
2.处理顶点
（1）起始顶点，入队，标记
（2）弹出，打印，遍历（找到与当前节点有边且未被处理的节点入队2）
```

![image-20221120121505275](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20221120121505275.png)

```C++
//BFS遍历（队列）
void BFS(pgraph& p,int n) {
	queue<int>que;
	que.push(n);
	mark[n - 1] = 1;
	while (!que.empty()) {
		cout << que.front();
		for (int a = 0; a < p->v; a++) {
			if (p->m[que.front() - 1][a] && mark[a] == 0) {
				que.push(a+1);
				mark[a] = 1;
			}
		}
		que.pop();
	}
}
```







## 5.最小生成树

​		前提：连通、无闭合回路

### 克鲁斯卡尔（Kruskal）

​		看边：每次选权值最小的边，若该边的两个顶点都没在树中，就把该边放入树

![image-20221122220613678](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20221122220613678.png)





### 普里姆（Prim）

​		以一个顶点为起点，加入顶点序列；在相关边中选权值最小的，将另一个点加入序列，再选相关边中权值最小的....

![image-20221122221741718](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20221122221741718.png)





### 迪杰斯特拉（Dijkstra）

​		迪杰斯特拉（单源最短路径；贪心算法）：有向的带正权值的图中，一个点到其他所有点的最短路径

![image-20221122222141594](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20221122222141594.png)







## 6.拓扑排序



​		并不是一个纯粹的排序算法，他只针对于某一类图（有向无环（循环）图（DAG）），找到一个可执行的线性排序，即为拓扑序列。（若有环，将出现死循环）

- 如果不是DAG  ->  无拓扑
- 如果是DAG  ->  至少有一个拓扑序列
- 若存在拓扑序列  ->  一定是DAG



​		**拓扑排序的意义**：按该顺序，在每个项目开始时，能够保证他的前去活动都已完成，从而使整个工程顺利进行。

- BFS、DFS可以判断图是否为连通图
- 拓扑排序可以判断提是否有环（循环）



````
例：
课程代号：C1 C2 C3 C4 C5 C6 C7 C8 C9
前驱课程：无 无 C1C2 C3C5 C2 C4C5 C4C9 C1 C8
````

**AOV网络（Activity on vertex）=》DAG**

![image-20221122223925466](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20221122223925466.png)

入度数组：

![image-20221122224916642](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20221122224916642.png)





## 按层打印



​		将一颗二叉树按层打印，一层输出到一行上。（力扣102）

![image-20221123195651590](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20221123195651590.png)

```
法1：
使用两个队列：首先将根节点入到一个队列，只要两个队列中有一个不空，就将该不空队列的元素打印、弹出、并将其孩子放到另一个队列，判断弹出后本队列是否为空，若为空，输出换行；若不为空，继续弹出下一个....直到两个队列都为空，输出结束。
```

```
法2：
队列加标记：先将根节点入队，根入队后第一层结束，往队列里加一个结束标记；队首元素根出队、打印、子节点入队；下一个队首元素为结束标记，所以输出换行，结束标记出队再入队（该层已经结束，说明下一层不会再有新节点进入了，所以下一层已经全部入队了），继续队首节点出队...直到队列为空，输出结束。
```

```
法3：
计数：
(1)两个计数变量:第一个记录当前层的节点个数，第二个记录下一层的节点个数；队首节点出队（当前层-1）、子节点入队（下一层+子节点数）后，判断当前层是否为0，若为0，输出换行、下一层个数替换当前层个数，下一层清空；若不为0，继续队首节点出队...
(2)一个计数变量：记录当前层节点个数；节点入队，个数+1，队首节点出队，子节点入队，个数-1，若个数变为0，换行；若没变为0，继续队首节点出队；更新当前层节点个数，队首节点出队...
```

```c++
//法2
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        queue<TreeNode*>que;
        que.push(root);
        vector<vector<int>> ans;
        if(!root)return ans;
        vector<int>ans1;
        que.push(nullptr);
        while(!que.empty()){
            if(que.front()){
                if(que.front()->left)que.push(que.front()->left);
                if(que.front()->right)que.push(que.front()->right);
                ans1.push_back(que.front()->val);
                que.pop();
            }
           else{
                ans.push_back(ans1);
                ans1.clear();
                que.pop();
                if(que.empty())break;
                que.push(nullptr);
           }
        }
        return ans;
    }
};
```











# 十一、排序



## 1. 冒泡排序（Bubble Sort）



核心思想：相邻元素进行比较，如果前一个元素比后一个大，就交换。

![image-20221126153028789](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20221126153028789.png)

```c++
void bubble_sort(int *a,int len) {
	for (int n = 0; n < len-1;n++) {//共进行n-1次比较
		for (int i = 0; i < len-1-n ; i++) {//每次参与比较的最后一个元素时len-n
			if (a[i] > a[i + 1]) {
				swap(a[i], a[i + 1]);
			}
		}
	}
}
```

改进：设计一个标记变量，记录每一次进行交换的最后一个元素，这样在下一次交换时，只要比较到标记变量的前一个元素即可。

```c++
void bubble_sort(int *a,int len) {
	int flag;//标记变量：从该变量开始，后面的已排序完成
	for (int n = 0; n < len-1;) {
		flag = 0;
		for (int i = 0; i < len-1-n ; i++) {
			if (a[i] > a[i + 1]) {
				swap(a[i], a[i + 1]);
				flag = i + 1;
			}
		}
		if (flag == 0)break;
		n = len-flag;
	}
}
```





## 2. 选择排序（Select Sort）



核心思想：找最大元素放最后或找最小元素放最前

![image-20221126154955829](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20221126154955829.png)

```c++
void select(int *a,int len) {
	int max;
	for (int i = len - 1; i > 0; i--) {
		max = i;//最大元素下标
		for (int j = 0; j < i; j++) {
			if (a[j] > a[max])max = j;
		}
		swap(a[i], a[max]);
	}
}
```



## 3. 插入排序（Insert Sort）



核心思想：将待排序数据分成俩个部分，一部分无序，一部分有序，将无需元素依次插入到有序中。

适用于：元素比较少；每个元素距其最终位置不远。

![image-20221126161214471](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20221126161214471.png)

```
1.分割（有序和无序）：有序为第一个元素，无序为剩余部分
2.将无序元素插入有序（倒叙遍历有序元素）：
保留无序元素，
倒叙和有序元素进行比较：
若小于，前一个元素向后移动；
若大于，直接插入
```

```c++
void insert(int *a,int len) {
	for (int i = 1; i < len; i++) {
		int num = a[i];
		int j = i - 1;
		while (j >= 0 && a[j] > num) {
			a[j + 1] = a[j];
			j--;
		}
		a[j + 1] = num;
	}
}
```







## 4. 希尔排序（Shell Sort）



![image-20221127143708064](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20221127143708064.png)

```c++
//一组排完再排另一组
void insert(int *a,int len,int begin,int n) {
	for (int i = begin+n; i < len; i+=n) {
		int num = a[i];
		int j = i - n;
		while (j >= 0 && a[j] > num) {
			a[j + n] = a[j];
			j-=n;
		}
		a[j + n] = num;
	}
}

void shell(int* a, int len) {
	int n = len / 2;//分组：共n组
	while (n >= 1) {//大于等于1组时，进行排序
		for (int i = 0; i < n; i++) {//从第一组到第n组
			insert(a, len, i, n);
		}
		n /= 2;
	}
}

//优化：一次排完所有组（复杂度一样，只是代码优化）
void insert(int *a,int len,int n) {
	for (int i = n; i < len; i++) {
		int num = a[i];
		int j = i - n;
		while (j >= 0 && a[j] > num) {
			a[j + n] = a[j];
			j-=n;
		}
		a[j + n] = num;
	}
}

void shell(int* a, int len) {
	int n = len / 2;
	while (n >= 1) {
		insert(a, len, n);
		n /= 2;
	}
}
```





## 5. 计数排序（Counting Sort）



适用于：元素范围在一定区间内；有重复数字；数字间差值小。

核心思想：基于非比较的排序

```
//基础
1.找到最大值和最小值，确定数组范围max min
2.创建数组counting array
3.遍历数数count
4.输出或将排好序的数据放回原数组

//优化
1.找到最大值和最小值，确定数组范围max min
2.创建数组counting array
3.遍历数数count
4.累加 sum
5.创建新数组new array
6.从后向前遍历
```

![image-20221127155058446](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20221127155058446.png)

```c++
int* countsort(int *a,int len) {
	if (!a || len == 0)return nullptr;
	int min = a[0], max = a[0];
    //找最大值和最小值
	for (int n = 1; n < len; n++) {
		if (a[n] > max)max = a[n];
		if (a[n] < min)min = a[n];
	}
    //创建计数数组
	int* count = new int[max - min + 1]{ 0 };
    //计数
	for (int n = 0; n < len; n++)count[a[n] - min]++;
    //累加
	for (int n = 1; n < max - min + 1; n++)count[n] += count[n - 1];
    //排好序的数组
	int* ans = new int[len];
    //从后向前遍历
	for (int n = len - 1; n >= 0; n--) {
		ans[count[a[n] - min] - 1] = a[n];
		count[a[n] - min]--;
	}
	return ans;
}
```





## 6. 快速排序（Quick Sort）



核心思想：找一个标准值，将比标准值小的都放在标准值左边，比标准值大的都放在标准值右边，左右两半部分分别重复以上步骤。

```
法1：挖坑填补法
```

![image-20221128135050992](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20221128135050992.png)

```c++
void quick(int *a,int l,int r) {
	if (!a || l >= r)return;
	int sta = a[l];
	int i = l, j = r;
	while (i < j) {
        //从右向左
		while (a[j] > sta && i < j)j--;
		a[i] = a[j];
        //从左向右
		while (a[i] < sta && i < j)i++;
		a[j] = a[i];
	}
	a[i] = sta;
    //快排左半部分
	quick(a, l, i - 1);
    //快排右半部分
	quick(a, i + 1, r);
}
```



````
法2（优化版）：区间分割法
应用：给一组数据，奇数放一起，偶数放一起
S:待排序序列起始位置的前一个位置
sta:标准值（默认取待排序序列的最后一个）
遍历：比较大小
若比标准值小：和S的下一个位置交换，S++
若比标准值大：处理下一元素
````

![image-20221130104501643](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20221130104501643.png)

```c++
void goodquick(int* a, int begin, int end) {
	if (!a || begin >= end)return;
	int s = begin - 1, sta = a[end];//标记为起始位置的前一个，标准为末尾元素
	for (int n = begin; n < end; n++) {
        //从头向后遍历，若比标准元素小，放到标记位置的下一个，标记位置更新
		if (a[n] < sta)swap(a[n], a[++s]);
	}
    //将标准元素放到合适位置
	swap(a[++s], a[end]);
    //继续快排左右两半部分
	goodquick(a, begin, s - 1);
	goodquick(a, s + 1, end);
}
```



```
会降低效率的情况：有序，每次拿到的都是最大值或最小值
避免：取标准值时，每次取三个（最前面，最后面，最中间），三者取中间值。
```

```
快排的优化：
1.本身（上面第一个）
2.上面第二个
3.标记的选取（1.选一个 2.选三个 3.聚集）
4.当待排序序列个数小于16时，采取插入排序
5.循环+堆空间
```







## 7. 归并排序（Merge Sort）



核心思想：将多个有序数组合并成一个

应用场景：海量数据处理；计算数组中有多少逆序对（9 6 8 10 逆序对：9 6，9 8）

```
1.分割：二分，将当前数据分成两部分
2.合并：合成两个有序数组
```

![image-20221130135009836](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20221130135009836.png)

```c++
void mergesort(int* a, int begin, int end) {
	if (!a || begin >= end)return;
	//分割
	int mid = (begin + end) / 2;
	mergesort(a, begin, mid);
	mergesort(a, mid + 1, end);
	//合并
	merge(a, begin, mid, mid + 1, end);
}

void merge(int* a, int onebe, int oneen, int twobe, int twoen) {
	int* b = new int[twoen - onebe +1];//保留排好的数据
	int n = 0;
	int nn = onebe;
	while (onebe <= oneen && twobe <= twoen) {//将两段按从小到大放到新数组
		if (a[onebe] < a[twobe])b[n++] = a[onebe++];
		else b[n++] = a[twobe++];
	}
    //若有剩余，直接放入新数组
	if (onebe > oneen)while (twobe <= twoen)b[n++] = a[twobe++];
	else while(onebe<=oneen)b[n++] = a[onebe++];
	n = 0;
    //将新数组的元素依次放入原数组的适当位置
	for (nn; nn <= twoen; nn++)a[nn] = b[n++];
    //释放新数组的空间
	free(b);
	b = nullptr;
}
```









## 8. 堆排序（Heap Sort）



逻辑上符合完全二叉树；

大根堆：父亲都比孩子大（兄弟间无要求）

小根堆：父亲都比孩子小（兄弟间无要求）

```
1.建初始堆 create heap
从后往前，先和兄弟节点（n+1）比较，大的与父亲节点（n/2）比较，若比父亲节点大，则交换
2.排序：sort
堆顶（0）和最后一个节点交换，则当前最后一个元素就是最大值；
继续将当前堆顶移到合适位置。
```

![image-20221201115200025](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20221201115200025.png)

```c++
//父子间的比较和移动(传父节点)
void move(int* a, int n,int len) {
	while (n * 2 + 1 < len) {
		int max = n * 2 + 1;
		if (n * 2 + 2 < len) {
			max = a[n * 2 + 1] > a[n * 2 + 2] ? n * 2 + 1 : n * 2 + 2;
		}
		if (a[max] < a[n])break;
		swap(a[max], a[n]);
		n = max;
	}
}

void heap(int *a,int len){
	//建堆(父亲节点范围：0---len/2-1)
	for (int n = len / 2 - 1; n >= 0; n--) {
		move(a, n, len);
	}
	//排序
	for (int n = len - 1; n > 0; n--) {
		swap(a[n], a[0]);
		move(a, 0, n);
	}
}
```







## 9. 桶排序（Bucket Sort）



​		**桶排序：针对小数，位数相同**（可用于海量数据）

- 将数据分成多个组，各组之内各自排序
- 适用于：
- 1. 数据很容易分成n个桶，且桶与桶之间有着天然的大小关系；
  2. 当前数据在各个桶内分布均匀

![image-20221202122702868](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20221202122702868.png)

```
1.找最大值最小值max min
2.创建桶（数组）bucket
3.将当前元素放入桶put
4.各桶内进行排序sort
5.将元素放回原数组pushback
```

```c++
typedef struct node {
	int val;
	struct node* next;
	node(int a) { val = a; next = nullptr; }
}node,*pnode;

void bucket(int* a, int len) {
	if (len == 0)return;

	//获取位数
	int n = a[0], cou = 1;
	while (n /= 10)cou *= 10;

	//获取最大值最小值
	int min = a[0], max = a[0];
	for (n = 1; n < len; n++) {
		if (a[n] < min)min = a[n];
		if (a[n] > max)max = a[n];
	}

	//创建桶数组+排序
	int len2 = max / cou - min / cou + 1;
	pnode* bucket = new pnode[len2];
	memset(bucket, 0, sizeof(pnode) * len2);
	for (n = 0; n < len; n++) {
		pnode pnew = new node(a[n]);
		pnode p = bucket[a[n] / cou - min / cou];
		if (!p || pnew->val < p->val) {
			pnew->next = bucket[a[n] / cou - min / cou];
			bucket[a[n] / cou - min / cou] = pnew;
		}
		else {
			while (p->next && pnew->val > p->next-> val)p = p->next;
			pnew->next = p->next;
			p->next = pnew;
		}
	}
	//for (n = 0; n < len2; n++) { if(bucket[n])cout << bucket[n]->val << " "; }

	//放回原数组
	int i = 0;
	for (n = 0; n < len2; n++) {
		pnode p = bucket[n];
		while (p) {
			a[i] = p->val;
			i++;
			p = p->next;
		}
	}
	

	//释放新申请的空间
	for (n = 0; n < len2; n++) {
		pnode p = bucket[n];
		while (p) {
			pnode pnext = p->next;
			free(p);
			p = pnext;
		}
	}
	free(bucket);
	bucket = nullptr;
}
```







## 10. 基数排序（Radix Sort）



​		基数排序：利用数字规律排序O（d*(n+r)）（d：最大值的位数  n：元素个数  r：桶的个数）

LSD ：低位优先（下）

MSD ：高位优先（用的少）

![image-20221202123021302](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20221202123021302.png)

```
1.最大值位数
2.按位处理：
个->表头（10）：按位入桶（尾添加）->放回原数组
十->...
百->...
...
```

```c++
typedef struct node {
	int val;
	struct node* next;
}node,*pnode;

void radix(int *a,int len) {
	//最大值的位数
	int max = a[0];
	for (int n = 1; n < len; n++) {
		if (a[n] > max)max = a[n];
	}
	int cou = 1;
	while (max /= 10)cou*=10;

	//按位排序
	for (int wei = 1; wei <= cou; wei*=10) {
		//排序数组
		pnode b[10]{ 0 };
		//放到桶内
		for (int n = 0; n < len; n++) {
			pnode pnew = new node{ a[n], nullptr };
			pnode p = b[a[n] / wei % 10];
			if (!p)b[a[n] / wei % 10] = pnew;
			else {
				while (p->next)p = p->next;
				p->next = pnew;
			}
		}
		//按桶放回原数组
		int i = 0;
		for (int n = 0; n < 10; n++) {
			pnode p = b[n];
			while (p) {
				a[i++] = p->val;
				p = p->next;
			}
		}
		//释放空间
		for (int n = 0; n < 10; n++) {
			pnode p = b[n];
			while (p) {
				pnode pp = p;
				p = p->next;
				free(pp);
				pp = nullptr;
			}
		}
	}
}
```

















## 11. 排序算法的时间复杂度



![image-20221203114947925](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20221203114947925.png)

![image-20221201125727140](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20221201125727140.png)





## 12. 语言中的sort排序



STL中的sort：

​	在数据量<16时，采用插入排序

​	在数据量>16时，采用快速排序；若快排时左右两边严重不均匀，将采用堆排序



C++中的sort：

​	在数据量<4时，采用插入排序

​	数据量比4大，但还是较少，采用归并排序

​	数据量较多时，采用快排（3数取中值优化法）

一旦递归层数较多，会采用堆空间模拟递归（循环加空间消耗模拟）







## 排序查找汇总题



1. 高考分数排序：计数排序
2. 10万个电话号码排序（11位）：基数排序（桶排序的话要申请很多桶，空间消耗很大）
3. 10 G 数据，内存不足：分为多个文件，文件内排序（快排），再合并；桶排序
4. 给一堆 IP ，快速定位某一 IP ：

```
1.若IP为字符串，可建字典树，对字符串进行搜索
2.IP由四个在0-255范围内的数字组成，在无符号字符的范围内；可将其转换为无符号整数（int 四个字节），对整数进行排序
```

5. 获取数据流的中位数（数据流：时刻有新数据来）：建两个堆，一个大顶堆，一个小顶堆，保证大顶堆的最大值小于小顶堆的最小值，维护两个堆的个数差不大于1，则中位数就在两个堆顶之间。









# 十二、动态规划（DynamicProgramming）



## 1. 基本概念



**动态规划**：将一个大问题拆解成几个子问题，分别求解这些子问题，即可推断出大问题的解。

**无后效性**：一旦f（w）确定，如何凑出f（w）就不关心了。

**最优子结构**：大问题的最优解可以由小问题的最优解推出。

- 满足以上三条，可使用DP

```
分治要求子问题间相互独立，DP不要求，所以不满足分治第四个条件（相互独立）的，可用DP来解
```

![image-20221204095201790](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20221204095201790.png)

```
其中：
f(14) f(10) f(4)称为f(15)的子问题
第②条也叫做无后效性。
```

```
通用步骤：
1.分阶段（大问题->小问题）
2.找状态（子问题的最优解）
3.状态转移方程
4.寻找终止条件
```



## 凑元数



给1、2、5元钱，凑n元钱，最少需要多少张？

![image-20221204103022623](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20221204103022623.png)







## LIS（最长递增子序列）



![image-20221204110846288](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20221204110846288.png)

```
实现：
```

![050CFE1FF81FAA3A9EF89F681DE76720](D:\文件\2480454254\Image\C2C\050CFE1FF81FAA3A9EF89F681DE76720.jpg)





## 捡苹果



​		M*N个格子，每个格子里有苹果，从左上角出发，每次只能向下或向右移动一格，问走到不能再走，最多能捡多少个苹果。

![8BEA6F6394B43A55805148FDE1CB09B1](D:\文件\2480454254\Image\C2C\8BEA6F6394B43A55805148FDE1CB09B1.jpg)







## LCS（最长公共子序列）



![7343C7B541DECD568159AE1CBB58ACA4](D:\文件\2480454254\Image\C2C\7343C7B541DECD568159AE1CBB58ACA4.jpg)











# 十二、异或



**适用于：**

1. 一组数据中有一个出现一次，其余出现两次
2. 1~n丢一个或多一个

利用异或进行交换（不可以是相同物理地址的）

在优化时，_ ^= _ 比 _ = _ ^ _ 的系统效率要高

位运算的优先级比较低，在底层运算速度较快

```
if(x!=y)的底层实现(x^y)!=0
```

- 清零：自己异或自己





**不用加减乘除实现加法运算：**

```c
#include<staio.h>

int add(int a,int b){
	while(a){
         //不需要进位的位
		int temp=a^b;
         //需要进位的位
		a=(a&b)<<1;
         //当a等于0时，b即不需要进位的位也就是结果
		b=temp;
         //结果位不需进位的位个需要进位的位相加，即重复上述操作
	}
	return b;
}

int main(){
	int a=13;
	int b=28;
	printf("%d\n",add(a,b));
	
	return 0;
}
```









# 十三、格雷码



 

**给定一个数n，需要重复以下操作多少次才可以把他变成0：**

- 翻转当前数字对应的二进制位里最右侧的一位
- 如果二进制里的第i-1位为1，第i-2位至第0位均为0，可以翻转第i位

翻转：0->1 1->0

```
例：8
1000->1001->1011->1010->1110->1111->1101->1100->0100->0101->0111->0110->0010->0011->0001->0000(15次)
例：3
11->01->00（2次）
```

- **这个问题实际上时二进制与格雷码的转换**



**二进制转格雷码：Binary->Graycode：**

```
1.B的最高位是G的最高位（最高位相同）
2.次高位G：B的最高位异或B的次高位
G=B^(B>>1)
```

![image-20230321221935589](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20230321221935589.png)



**格雷码转二进制：Graycode->Binary：**

```
1.G的高位是自然B的高位
2.次高位的二进制码：高位B和次高位G异或
while(G>>1)B^=G;
```

![image-20230321222129105](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20230321222129105.png)

![image-20230321222142559](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20230321222142559.png)







# 十四、最大流



- 无权有向图如何找到图中点与点之间的最短路径？BFS

**最大流问题**：一种组合化问题，充分利用装置的能力，使运输的流量达到最大化。（有边、有权重）

> 最多有多少水从s->t ？（边可看作管道，权值是该管道的容量）

![image-20230322121346678](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20230322121346678.png)

OG（Origin Graph）：原图

RG（Residual Graph）:残量图/空闲图

LG（Level Graph）：按步数

瓶颈值：一条路线中最小的权值



## 简单算法（Nalve Algorithm）：



1. 构建RG（init：和OG一样）

2. 随机找一条S->T简单路径（除起点终点外，无重复顶点），找当前路径瓶颈值（最小权重）减去瓶颈值；重复2操作

![image-20230322121739318](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20230322121739318.png)

3. 直到RG中无简单路径，OG-RG=Flow

![image-20230322121902469](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20230322121902469.png)



- 算法存在的问题：找到的简单路径是随机的，又可能求到的流不是最大流（求到的是阻塞流）
- 阻塞流（Blocking Flow）：不能有更多的水从s->t
- 最大流一定是阻塞流，阻塞流不一定是最大流。





## Ford-Fulkerson Algorithm



1. 构建RG（init：和OG一样）
2. 找一条简单路径，找瓶颈值
3. 更新RG：减瓶颈值
4. 添加反向路径，继续2操作
5. 没有简单路径存在，取出所有的反向路径
6. OG-RG=MaxFlow

![image-20230322122313803](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20230322122313803.png)



- 存在问题：时间复杂度：O（f*m）

![image-20230322122933363](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20230322122933363.png)



- 改进：Edmonds-Karp Algorithm：fulkerson的特例O（m^2*n）

不找简单路径，找最短路径

Bfs：O（m）

f：m*n





## Dinic's Algorithm



时间复杂度：O（m*n^2）

- f：n-1轮
- 每轮生成阻塞流：O（m*n）



1. 构造RG（init:和OG一样）
2. 根据RG画出LG（步数：同级之间不会有边）
3. 在LG中找一个阻塞流
4. 让阻塞流流过RG
5. 更新RG，继续2操作
6. 直到无阻塞流
7. OG-RG=MaxFlow

![image-20230322123624619](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20230322123624619.png)







# 十五、二分图



二部图/二分图（Bitartite）：当前节点可以被分到两个阵营中

G=（u,v,E）u:点1	 v:点2	 E：边		u和v内部不可以有边



## 判断二分图（着色Bfs）



**连通图的二分图判定**（采用Bfs（队列））：

1. 先涂一个色
2. 找其相邻点：若相邻点无色，涂相反色；

​							 若相邻点有色：若为同色，不是二分图

​														 若为反色，不做处理

3. 重复2操作
4. 遍历结束，无冲突即为二分图



**非连通图的二分图判定**：

​		和连通图一个判定方法，若遍历个数小于图中顶点总数，在未遍历的殿中找一个继续着色遍历，直到图中所有点都被遍历过。

![image-20230322124511713](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20230322124511713.png)







## 无权二分图最大匹配



无权二分图最大匹配：Maximum-Cordinality Bipartite Matching（MCBM）

匹配：边的集合，边的顶点不能相同（B2 C1 D3...）

最大匹配：所有匹配中边的数量最大



**宠物领养：左边是人，右边是宠物，有边表示人对该宠物有兴趣**

- 可以看作是最大流问题，没人可以领养一个宠物，每个宠物只能被一个人领养，求S->T的最大流，权值可看作1.

![image-20230322124755034](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20230322124755034.png)







## 有权二分图最大匹配



最大匹配：权值最大的匹配

步骤：1. 将权值取反		2. 找最小匹配



**匈牙利算法：O（n^3）：**

![image-20230322125130063](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20230322125130063.png)

前提：uv两个集合中顶点个数相同

1. 找每行中最小值
2. 每行元素减去当行最小值
3. 找每列中最小值
4. 每列元素减去当列最小值
5. 划线：只能横竖画，用最少的线将所有0覆盖住
6. 若线的条数小于顶点数，所有未被覆盖的数减去其中最小值，线的交叉点加上最小值，继续划线
7. 遍历：找到只有一个0的一行，该0必须存在；将此列上其他0剔除，重复7操作。
8. 直到每行都只有一个0，即为最小匹配的边。

![image-20230322125500158](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20230322125500158.png)

# 十六、稳定婚配



​		稳定婚配：没有人可以找到比当前更好的配偶

![image-20221203100306738](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20221203100306738.png)

Gale - Shapley 算法 O（n^2）：

```c
1.所有男孩向第一顺位的女孩求婚
1.1：若女孩未婚且只有一人向其求婚，则结婚
1.2：若女孩未婚且有多人向其求婚，则在追求者中选最喜欢的结婚
1.3：若女孩已婚，则在追求者和配偶之间选最喜欢的结婚
//拒绝过自己的和跟自己离婚的接下来都不再追求
```

![image-20230322125638073](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20230322125638073.png)







# 十七、银行家算法



**用途：**避免死锁



**前提：**

1. 固定数量的进程共享固定数量的资源
2. 每个进程预先指定完成工作所需的最大资源数量
3. 每个进程不能申请比系统可用资源总数还多的资源
4. 进程等待资源的时间是有限的
5. 进程在优先的时间内使用资源后将资源归还给系统



**需要存储的数据：**

1. 系统可分配资源A
2. 进程已得到的资源B
3. 进程所需最大资源C
4. 进程还需要的资源D
5. 每一次的需求E
6. 可用资源总数量F（用于检查）



**进程提出资源申请的处理步骤：**

1. 判断E<=D 否则报错

2. 判断E<=A 否则等待

3. 假设系统给了E

   更新：A=A-E

   ​			B=B+E

   ​			D=D-E

   检测安全性：1. 判断进程是否被检查过（需要个标记）

   ​						2. D<=F











# 精英班

c++11和c++14标准

json数据封装和数据收发

lvs负载均衡相关算法

实现游戏平台

爬虫智能机器人

算法加深

真题实战







# 问题



1. 字符串的全排列

2. 数组前面单调递减，后面单调递增，如何找到最小值，以及相反的

3. 字符串反转

4. 哈希表的增删查时间消耗

   ~~~
   O(1)
   ~~~

5. 二叉树的非递归的中序遍历

6. 如何不用中间变量，实现两个变量的交换

   ~~~c++
   //1.利用加减法：a=a+b b=a-b a=a-b;
   //2.利用位运算：异或：相同为0，相异为1
   //a=a^b b=a^b a=a^b;(异或满足交换律和结合律，所以所以能成立)
   //b=a^b=a^(b^b)=a^0=a;
   //a=a^b=a^b^a=b^0=b;
   //注意：使用这种方法前，应该先判断a和b是否相等，如果相等，则这种方法会将a和b的值都置零
   ~~~

7. 不用加减乘除，实现加法运算

   ~~~
   //1.将各位值相加(不带进位)，二进制相加相当于各位做异或运算
   //2.
   ~~~

8. 数组和链表的区别

   ~~~c++
   //1.在内存中，数组是一块连续的区域，而链表不要求连续
   //2.数组需要预留空间，使用前要先申请占用内存的大小，不方便扩展，当数组空间不够时，需要重新定义数组；而链表则不需要指定大小，便于扩展
   //3.数组的插入和删除效率比较低，每当插入或删除时，这个位置后面的所有元素都需要相应的移动；链表插入和删除数据则比较容易，只需要修改元素中的指针即可
   //4.数组的随机读取效率很高，利用索引可以直接取到相应数据；链表查找数据效率比较低，不具有随机访问性，且不论访问哪个位置的元素都需要从第一个元素开始往后遍历，直到找到相应元素为止
   ~~~

9. 数组和链表的优缺点

   ~~~c++
   //数组的优点：随机访问性强，查找速度快
   //数组的缺点：插入和删除效率低，可能浪费内存，内存要求空间高，必须有足够且连续的内存空间，数组大小确定，不能动态扩展
   //链表的优点：插入删除速度快，内存利用率高，不会浪费内存，大小不固定，扩展较为灵活
   //链表的缺点：不能随即查找，必须从第一个元素开始遍历，查找效率低
   ~~~

10. n个节点的无向图至少有多少个节点才是连通图

11. 哈希冲突

    哈希冲突就是两个不同值的东西，通过哈希函数计算出来的哈希值相同，这样他们存在数组中的时候就会发生冲突，这就是哈希冲突

12. 哈希冲突的解决方法和优化

    开放地址法：发生冲突时，就去寻找下一个空的地址把数据存入其中

    拉链法：

13. 堆和栈的区别：

    ~~~c++
    //1. 申请空间的方式和回收不一样，堆区的空间需要向系统申请，申请之后才会分配，申请方式malloc和new，栈只要定义了就会自动分配空间
    //2. 栈的回收方式不用管，系统会自动回收，堆区申请的空间必须主动释放掉，否则会造成内存泄漏
    //3. 栈的生命周期，就是在它所在的大括号里，堆的生命周期，从你主动申请到主动释放，如果想返回一块空间，多数会选择返回堆区，而不是返回栈区，因为理论上栈区的空间已经被回收掉了
    //4. 分配效率，栈区是一块连续的空间，堆区是一块一块离散的空间，把他们利用起来，串联到一起(底层是由链表实现的，把当前空间的大小和地址存储在链表的结点里)，堆区比栈区的分配效率要慢一点(堆区底层有一个链表遍历的过程，会找到最符合你要求的一块空间分配给你)
    //5. 在栈区进行空间申请的时候，空间申请的生长方向是从大到小生长的，堆区刚好相反
    //6. 堆区会产生内存碎片，而栈区不会
    //7. 堆区的存储内容：可以往里面放数据，地址（堆区没有变量，堆区永远是被别的变量指向的）；栈区：主要是变量，函数的入口地址
    ~~~

14. 两个队列实现栈

    将queue1用作进栈出栈，queue2作为一个中转站

    入栈时，直接压入queue1中

    出栈时，先将queue1中的元素除最后一个元素外依次出队列，并压入队列queue2中，将留在queue1中的最后一个元素出队列即为出栈元素，最后还要把queue2中的元素再次压入queue1中

15. 两个栈实现队列

    将stack1作为存储空间，将stack2作为临时缓冲区，入队时，直接压入stac1，出队时，将stack1中的元素依次出栈压入stack2中，再将stack2的栈顶元素弹出，最后将stack2中的元素再倒回给stack1

16. 全局变量和静态变量的区别

    ~~~c++
    //全局变量定义在全局区，默认初始化为0
    //静态变量：在局部范围内定义静态变量，只定义（初始化）一次，并且会在其作用域内保存其值
    ~~~

17. 给一组数据，如何创建一个完全二叉树

18. 括号匹配，给出一对括号，如何判断是否匹配

19. 约瑟夫环变体

20. 如何判断一个给定的序列是不是BST的后序序列

21. 迪杰斯特拉是如何实现的

22. 二叉树层序遍历如何实现

23. 邻接矩阵和邻接链表的区别

24. B和B+树的区别

25. 二叉树的第五个性质

26. 如何在一堆字符串中统计其中某个字符串出现的次数

27. 有n级台阶，小青蛙每次跳1或2级，问有多少种跳法

28. 判断一个数是不是2的幂

29. 求一个数的n次方（快速幂）

30. 如何判断一个字符串种另一个字符串出现的位置

31. 从右侧向左侧看一棵二叉树，看到的是哪些节点

32. 一个数组有n个元素，在0 - n-1之间，判断是否有重复元素

    ~~~c++
    //1.利用哈希表，首先遍历数组，判断set中是否存在当前数组元素，如果不存在则将数组元素插入到set中，否则返回当前元素，此元素就是重复元素
    //2.申请一个新数组，将数组初始化为0。遍历原数组，把原数组的元素作为新数组的索引，出现几次，新数组对应索引的值就相应的加几次，直到原数组遍历结束。再遍历新数组，判断新数组元素是否有大于等于2的，有则代表有重复元素，无，则代表没有重复元素
    ~~~

33. 找到一个单向链表的倒数第k个节点

34. 有k层的二叉树，总的节点个数最多有多少，高度

35. 一个点到其他各个点的最短距离怎么计算

36. 给一个前序和一个后序能不能确定一个二叉树

37. 合并有序链表如何实现？如何将n个有序链表合并成一个有序链表？

38. 倒置链表

39. 如何将BST变成一个有序的双向链表

40. 复杂链表的复制

41. 如何判断一个单向链表是否是回文链表

42. 链表折叠

43. 将两个数相加和以链表形式存储

44. 判断两个单向链表是否相交，如果相交，找到交点

45. 判断单向链表是否有环？有的话找到入口节点

46. 给一个空间足够大的字符串，实现把空格替换成给定的字符串

47. 单词倒置only loves left alive

48. 字符移位 abcdefg -> efgabcd

49. KMP

50. Sunday

51. 如何找到一个字符串中第一个只出现一次的字符

52. 二分查找

53. 求一个数字的n次方

54. 二叉树的性质

55. 只给前序遍历和中序遍历构造二叉树

56. 给一组数据，如何构造完全二叉树？

57. B树的定义

58. 排序二叉树如何实现

59. RBT的添加如何实现

60. RBT的删除如何实现

61. 如何实现哈夫曼编码

62. 字典树

63. DFS和BFS如何实现

64. 最小生成树是如何生成的

65. AOV和AOE

66. 在一个有序数组种查找某个数字，如何查找？二分

67. DAG

68. 拓扑排序怎么实现

69. 什么样的问题能用分治法来解决

70. 什么样的问题可以用递归来解决

71. 计算复杂度的三个要求

72. 二叉树的右旋

73. 哈希表是如何创建的

74. 什么时候使用哈希表什么时候使用红黑树

75. 在BST种搜索和为S的整数

76. 斐波那契数列的实现

77. atoi函数如何实现的

78. 如何计算有n个节点的二叉树中某一个节点的高度

79. 强连通分量

80. b+相对于b有哪些优点

81. 数组实现循环队列，实现push和pop，头和尾要怎么移动

82. vector和list的区别

83. 如何找二叉树中何为某一个值的路径

84. 二叉树的右视图
