#  手写printf



```c
//VA_LIST 是在C语言中解决变参问题的一组宏，  va_list ap;
//所在头文件：#include <stdarg.h>，用于获取不确定个数的参数。
//VA_START宏，获取可变参数列表的第一个参数的地址
//（ap是类型为va_list的指针，v是可变参数最左边的参数）va_start(ap,v)
//VA_ARG宏，获取可变参数的当前参数，返回指定类型并将指针指向下一参数
//（t参数描述了当前参数的类型） va_arg(ap,t)
//比如下一个参数是 const char*  
//那么使用  const char* s = va_arg(ap, const char* );获取
//VA_END宏，清空va_list可变参数列表 va_end(ap) 

//putchar  打印字符  也可以使用  write  stdout 
//itoa  整数转换为字符串  itoa( 整数 , 缓冲区, 进制 )

#include <stdarg.h>
#include <stdlib.h>
#include <stdio.h>

int myprintf( char* fmt , ...)
{
	const char *s;
	int d;
	char buf[16];

	va_list ap;
	va_start(ap, fmt);
	while (*fmt) {
		if (*fmt != '%') {
			putchar(*fmt++);
			continue;
		}
		switch (*++fmt) {
			case 's':
				s = va_arg(ap, const char *);
				for ( ; *s; s++) {
					putchar(*s);
				}
				break;
			case 'd':
				d = va_arg(ap, int);
				itoa(d, buf, 10);
				for (s = buf; *s; s++) {
					putchar(*s);
				}
				break;
			case 'x':
				d = va_arg(ap, int);
				itoa(d, buf, 16);
				for (s = buf; *s; s++) {
					putchar(*s);
				}
				break;
				/* Add other specifiers here... */             
			default: 
				putchar(*fmt);
				break;
		}
		fmt++;
	}
	va_end(ap);
	return 1;   /* Dummy return value */
}
```





# 手写shared_ptr

```c
#include<iostream>

using namespace std;

//引用计数的实现
template<class T>  //class -> typename
class Counter  //是智能指针的成员
{
private:
	T * ptr;  //共用的堆区空间
	int cnt; //引用计数
	
	//加智能指针可以使用私有的友元
	template<class T>
	friend class myshared_ptr;
	
	Counter( T* p) {
		ptr = p;
		cnt = 1;
	}
	~Counter( ){
		delete ptr; //方便回收堆区空间
	}
};

//智能指针实现
template<class T>
class myshared_ptr
{
private:
	Counter<T> *ptr_cnt; // 引用计数的指针
public:
	myshared_ptr( T*p ) //从智能指针的使用考虑  
	{
		ptr_cnt  = new Counter<T>( p );
	}
	//拷贝构造 拷贝构造的时候 引用计数 +1 
	myshared_ptr( const myshared_ptr & sptr )    //因为共用 浅拷贝 
	{
		 ptr_cnt = sptr . ptr_cnt;
		 ptr_cnt->cnt ++;
	}
	//赋值的重载操作符  A = B;   A原来对应的空间 引用计数-- (判断归0) B原来的空间引用计数++
	myshared_ptr&  operator= ( const myshared_ptr & sptr )     
	//赋值之后 A指向的空间变为B指向的空间.
	{
		//判断是不是自己  引用计数不动
		if( this == &sptr )  return *this; //返回对象自己
		this->ptr_cnt->cnt--;
		if( this->ptr_cnt->cnt == 0 ) delete ptr_cnt;
		ptr_cnt = sptr .ptr_cnt;//赋值之后 A指向的空间变为B指向的空间.
		sptr .ptr_cnt->cnt++;
		return *this;
	}
	//析构   引用计数-1 , 判断当引用计数归0 , 回收空间
	~myshared_ptr(){
		ptr_cnt->cnt--;
		if( ptr_cnt->cnt == 0) delete  ptr_cnt;
	}
	int use_count(){  return ptr_cnt->cnt; }
	T* get() {
		return  ptr_cnt->ptr;
	}
};

//智能指针 不能保证 申请的堆空间的线程安全 要保证引用计数的线程安全 
//原子锁  InterLockedIncrement( &(ptr_cnt->cnt));   +1的原子锁
// InterLockedDecrement( &(ptr_cnt->cnt));   -1的原子锁

class AA
{
public:
	AA( string str ){
		this->str= str;
		cout << "AA(str):"<< str.c_str()<<endl; 
	}
	void say(){
		cout << str.c_str()<<endl; 
	}
	~AA(){
		cout << "~AA()" << endl;
	}
private:
	string str;
};

int main()
{
	{
		myshared_ptr<AA> sptr1( new AA("AA1"));
		cout << "AA1 use_count:"<<sptr1.use_count() <<endl;
		{
			myshared_ptr<AA> sptr2 = sptr1;
			cout << "AA1 use_count:"<<sptr1.use_count() <<endl;
			cout << "AA1 use_count:"<<sptr2.use_count() <<endl;
		}
		cout << "AA1 use_count:"<<sptr1.use_count() <<endl;

		sptr1.get()->say();
	}

	getchar();
	return 0;
}
```





# 内存泄漏的检查方法

![C++内存泄露检查的5个方法](F:\笔记\Typora\my\其他\C++内存泄露检查的5个方法.png)



# C



## 基础



一、变量的命名

> **typedef int (*PFUN)(int,int);		PFUN：函数指针类型（不是函数指针）**



二、数据类型

1. 一个字节=8位

2. ```
   int 4字节 2^32个数
   short 2字节 65536个
   char 1字节 256个
   float 4字节
   double 8字节
   int16_t 2字节
   int32_t 4字节
   int64_t 8字节
   int* 4/8(32位/64位)
   long 4/8(32位/64位)
   long long 8字节
   unsigned int 4字节 0~2^32-1
   unsigned short 2字节 0~65535
   unsigned char 1字节 0~255
   ```



三、进制转换

> 十进制、八进制（0）、十六进制（0x）、二进制的转换
>
> **如果数字特别大：先转成十六进制**
>
> **算法题：使用位运算**



四、原码、反码、补码

> 计算机以补码形式进行存储



五、大小端存储

> 计算机：小端存储（低地址存低字节）
>
> 网络字节序：大端存储（低地址存高字节）



六、类型转换

> 隐式类型转换（小类型=大类型：发生截断；大类型=小类型：值保持不变）和显式类型转换
>
> **sizeof size_t 都是无符号类型的，和有符号类型进行运算时，有符号类型会隐式转换成无符号类型**
>
> ```c
> int a=-5;
> unsigned int b=2;
> if(a+b>1)return true;else return false;//true:a转换成了无符号类型，符号位的1有实际数值，变得很大
> ```



七、scanf printf

> **scanf("%s",&a)不能获取到空格，gets可以获取空格**
>
> **scanf结束的返回值时EOF，while(scanf("%d",&a)!=EOF)**
>
> 各种%的用法



八、位运算

> ~ ^ & | << >>
>
> 左移补0，**右移：无符号类型补0，有符号类型补的跟符号位相同。**
>
> 按位取反是包括符号位的，返回值为有符号类型
>
> **判断是否为奇数：a&1	但是a&1==0不能判断是否为偶数，因为==的优先级大于&**
>
> **按位取反会操作32位，没有就补位；按位取反后，类型会变为有符号int**（习题63）



**九、优先级（没标的为自左向右）**

> **优先级从高到低：前导操作符>单目运算符>双目运算符>三目运算符>赋值>逗号**
>
> **前导操作符：() [] -> .** 
>
> **单目运算符：& * ++ -- (type) ! （自右向左：相同优先级时从右向左看）**
>
> **双目运算符：运算>位移>关系>位运算>逻辑**
>
> > **运算：+ - * / %**
> >
> > **位移：<< >>** 
> >
> > **关系：< > <= >= != ==**
> >
> > **位运算：& | ^ ~** 
> >
> > **逻辑：&& ||** 
>
> **三目运算符：? :（自右向左）**
>
> **赋值：=（自右向左）**
>
> **逗号：,**

- 短路语句：a&&b，a为假， b不执行；a||b ，a为真，b不执行
- a=b=c=1; a++||b++&&c++(211)
- printf()从后往前计算



栈检测是否越界是在return程序退出时检测的





## 不基础



一、流程结构

> 顺序、选择、循环（**goto语法**）

> if(a=17)
>
> else配对原则



二、预处理和宏定义

> #define PWORD char*
>
> PWORD p1,p2;sizeof(p1);sizeof(p2);		（41）
>
> **带#的操作：头文件，宏定义，pragma once，if define**
>
> ```c
> //可以用来进行函数切换和调用
> #ifdef a
> #define fun1
> #else
> #define fun2
> #endif
> ```
>
> **空指针：c++ NULL（0） c NULL（(void*)0）  c++11 nullptr**
>
> > define 的字符串用法
> >
> > define #转换为字符串 ##拼接
> >
> > ```c
> > #define str(m) #m
> > str(m);//"m"
> > 
> > #define RootPath "c:/path"
> > #define haha(a,b) a##b
> > haha("Root","Path");//"c:/path"
> > ```



三、数组

> 类型相同，地址连续
>
> 数组名是首元素地址，是个常量，不能数组名++
>
> sizeof(a)是数组空间大小
>
> 指针+1等于原地址+1*sizeof(a)
>
> **0x10+16=0x20（先转换为16进制再相加）**
>
> &数组名：数组指针int(*p)[n]
>
> &数组名+1：移动整个数组
>
> ```c
> int a[4]={1,2,3,4};
> int *p=(int*)&a;
> int (*p)[4]=&a;
> char* p3=(char*)&a;
> *(p+1);			//2
> *(*(p1+1)-1);	//4
> *(p3+1);		//0
> ```
>
> **数组下标为什么是从0开始的，而不是1 ？？？	为了提高效率，减少运算**



四、二维数组



五、函数与指针

> **为什么使用指针？因为代码不能一直在一个函数中写，要使用函数封装，让一个函数不能太长，但是有一些量需要跨函数，那么就需要使用地址间接使用变量，因而出现指针。**
>
> 值传递、地址传递
>
> 当数组作为参数时，要传长度（**char*以\0结束，可以获取长度，但是要经过一次遍历，没有传长度效率高**）
>
> 函数指针
>
> **回调函数：把用过的函数和参数保存起来，要用的时候再回去调用（应用：线程池），一般的写法时函数的参数是一个函数指针，在函数中通过函数指针调用函数；还有一种写法，是将函数提前登记，在需要时执行，比如线程池的写法。**
>
> **调用约定：约定参数怎么传递，谁来管理出栈，编译后名字的修饰方式**
>
> > 常见的调用约定：__ cdecl(scanf printf)  __ stdcall __fastcall
> >
> > c++调用约定：thiscall
> >
> > **为什么c++中有函数重载？因为c++编译时有参数列表，其中记录了返回值参数等信息**
> >
> > **c++在声明c头文件时，加入extern "C" ,保证函数会根据c的形式去编译，避免识别不到**
> >
> > ```c
> > extern "c"{
> > 	#include<add.h>
> > 	...
> > }
> > ```
>
> 函数的递归调用：**注意如果递归层数过多，会导致栈溢出。**



六、字符串和指针

> 字符数组和字符指针的区别
>
> **strlen()不包括\0，sizeof包括\0**
>
> 字符串函数 **strcpy（正常拷贝）.sprintf（格式化）.memcpy(拷内存)**...



七、结构体

> **不可以在结构体内部定义自己的对象，但是可以定义指针（类也一样，类成员不能是自己的对象）**
>
> 结构体字节对齐
>
> **栈区未初始化的地址用0xcc占位，堆区用0xfeee**
>
> 特殊情况：结构体内部套结构体
>
> > **成员拿过来，找一个最大的对齐；注意结构体之间要隔开，不能合并在一个对齐单元。**
>
> ```c
> //64位系统
> struct a{
> 	int32_t b;//4
> 	char* c;//8
> };/16
> struct d{
> 	int32_t a;//4
> 	char b;//1
> 	int32_t* c;//8
> 	int32_t e;//4
> 	struct a* f;//8
> 	char g;//1
> 	struct a h;//16
> 	//以8个字节位单位；（4a+1b）8+(c)8+（4e）8+(f)8+（1g）8+（4h.b）8+(h.c)8=56
> }
> ```



八、联合体

> 找对齐单位-最大的类型，属性共享空间
>
> ```c
> union a{
> 	int a;//最大类型，以四字节位单位对齐
> 	char b[6];
> };//8
> ```



九、文件操作

> 各种函数：fopen fclose fread fwrite fgetc fputs fseek ftell



十、存储区

> 堆、栈、全局区、代码段
>
> 栈堆的区别
>
> malloc new free delete的区别



十一、思考题：

1. c环境下，写一个存储结构，让他既能存char型数组，又能存int数，又能存int数组（也能知道存的类型，并读取）
2. c环境下实现一个函数，用来交换，可以是两个int交换，也可以是两个char交换，也可以是其他相同类型的两个变量

> ```c
> //1.
> struct a{
>     int type;//a-1 b-10 c-100 d-1000
>     union{
>         char a[100];
>         int b;
>         int c[100];
>         char d;
>     }u;
> }
> ```
>
> ```c
> //2.
> //法1：回调函数，写好每种类型的交换函数，在调用接口函数时传入待交换的值和函数地址
> void swap(void* a,void* b,void (*p)(void*,void*)){p(a,b);}
> //法2：宏替换
> #define SWAP(Type) void swap_##Type
> //法3：空间拷贝
> void swap(void* a,void* b,int nlen){
>     void* tmp=malloc(nlen);
>     memcpy(tmp,nlen,a);
>     memcpy(a,nlen,b);
>     memcpy(b,neln,tmp);
>     free(tmp);
> }
> ```







## 习题



1. **简述const的作用，const和#define相比，有什么优点**

   > c语言环境下，ocnst修饰只读变量，内容只不可更改
   >
   > #define enum 定义不可修改的值，const有类型的检查，且会占用空间

   

2. **头文件中的 ifndef define endif干什么用？**

   > 防止重复包含
   >
   > 等价于#pragma once
   >
   > 和头文件相互包含不是同一回事:a.h:#include"b.h"	b.h:#include"a.h"
   >
   > > **如何避免相互包含？**
   > >
   > > 能不包含就不包含，写类声明即可class a;源文件里面涉及到类的方法时，源文件.cpp包含头文件



3. **区别：**

   > char *p：p可变， *p可变 
   >
   > const char *p：p可变， *p不可变
   >
   > char* const p：p不可变， *p可变
   >
   > const char* const p：p不可变， *p不可变



4. **局部变量能否和全局变量重名**

   > 可以，在局部变量的作用域，局部变量会覆盖全局变量
   >
   > 使用全局变量：c++ "::"	c "extern + 变量声明"



5. **请简述typedef int(*PFUN)(int x,int y)及其作用**

   > typedef时给变量起别名，PFUN是一个参数为int int返回值为int的函数指针类型
   >
   > 作用：可以用于定义变量



6. **c语言中main函数的返回值有什么用**

   > 将程序是否正常退出的结果返回给系统



7. **VC中有哪些方法避免c编程的头文件重复包含**

   > 详见第二题



8. **将程序一直到不同的的32位cpu中，经常出现结构体字节对齐和大小端的问题，有哪些方法避免**

   > 可以指定的对齐数：#pragma pack(4) 按照四字节对齐；32位系统尽量4字节对齐 64位系统尽量8字节对齐
   >
   > 大小端的问题：写判断大小端的函数，如果一致，就不会有问题；如果不一致，就需要写转换函数，将数据进行转换



9. **sizeof**

> ```c
> struct{
> 	short a;
> 	long b;
> 	char c;
> }d;
> sizeof(d)为什么在不同平台上得到的值不一样
> ```
>
> long在32位（x86）是4字节（12），在64位（x64）是8字节（24）



10. **strcpy()为什么会造成缓冲区溢出？可用哪个函数代替？**

> strcpy(a,b) 复制字符串，一直到b的结束也就是找到\0，把这段空间复制到a对应的空间，a的空间如果较小就会溢出。
>
> strcpy_s(a,len,b) len表示a可以赋值的空间大小
>
> memcpy 也可以，长度传的是strlen(b)+1



11. **strcat的效率问题，有没有更好的解决方案**

> 拼接函数的问题：需要遍历到尾部然后再拼接
>
> 解决：重写函数加标记，法1.：传这个末尾地址；法2：起始位置+偏移 把字符串长度传入



12. **Heap和Stack有什么区别**

 [c基础知识点.docx](其他\c基础知识点.docx) 



13. **简述大端字节序和小段字节序的概念，设计一个小程序来判断当前操作系统的字节序**



14. **全局变量和static变量有什么区别**

> 全局变量和静态全局变量的区别：static只在当前文件有效
>
> 全局变量和静态局部变量的区别：作用域不同



15. **二进制数11101101转换为十八进制数是多少？**

> D3



16. **在函数体内声明char *str ="abc";和 char str[]={'a','b','c'}有什么区别**

> 前者可以修改指针的指向，但不能修改字符串的单个字符*str
>
> 后者是一个数组，不是一个字符串，str是数组首元素地址，不可变；但可以改变数组内的字符（*str）



17. **strcpy memcpy sprintf的区别**



18. **define的使用**

> 1. **使用define定义一年有多少毫秒**（int范围:10位数）
>
>    #define a 365 * 24 * 3600 * 1000LL	//（long long类型，输出使用%ld）
>
> 2. **使用define 定义max函数**
>
>    #define max(a,b) ((a)>(b))?(a):(b)
>
> 3. **define中为何经常会用do{}while(0) 来包装多条语句代码**
>
>    使宏内的语句变成一个整体，保证一起执行（否则：若跟在for循环后面，有可能只循环执行一条语句）
>
>    ```c
>    #define MM i++;i++;
>    main(){
>    	int i=0;
>    	for(int j=0;j<5;j++)MM
>    }
>    ```



19. **实现一个死循环**

> while(1);



20. **什么是预编译**



21. **头文件的尖括号和引号有什么区别？**

> 尖括号：找系统文件
>
> 引号：先找工程路径，再找系统



22. **写出三种交换整形a和b的方法**

> 1. int c=a;	a=b;	b=c;
> 2. a=a^b;     b=a^b;    a=a^b;          或         a^=b;    b^=a;    a^=b;
> 3. a=a+b;    b=a-b;    a=a-b;



23. **若x,y均是int型变量，则执行以下语句后，写出x,y的值**

```c
for(y=1,x=1;y<=50;y++){
	if(x>=10)break;
	if(x%2==1){
		x+=5;
		continue;
	}
	x-=3;
}
```

> x,y:1,1;6,2;3,3;8,4;5,5;10,6
>
> x=10     y=6



24. **写出以下代码段的输出结果**

```c
void swap(int m,int n){
    int temp;
    temp=m;m=n;n=temp;
}
main(){
    int m=7,n=5;
    swap(m,n);
    printf("m=%d,n=%d",m,n);
}
```

> m=7,n=5



25. **说明下面例子中const的用途**

```
1.const int d=100;
2.const char* pstr1="ABCD";
3.char* const pstr2="abcd";
4.int func1(int value)const;
5.const int func2(int value);
```

> 1. 只读变量不可变
> 2. pstr1指向字符串常量 *pstr1不可变
> 3. pstr2不能指向其他字符串
> 4. 常函数
> 5. 返回值lei'xing



26. **写出以下程序的运行结果**

```c
int count(int data){
	int mask=1;
	int i,count=0;
	for(i=0;i<sizeof(data)*8;i++){
		if(data&mask){
			count++;
		}
		mask<<=1;
	}
	return count;
}
data=0x3,count=?
data=0x12345678;count=?
```

> 求32位int里面二进制1的个数
>
> 0x3:count=2
>
> 0x12345678:count=13



27. **下面程序的运行结果是**

```c
#define ADD(a,b) a+b
main(){
    printf("%d\n",5*ADD(3,4));
}
```

> 19



28. **再C语言程序中，要给绝对地址0x100赋值，我们可以用：*(unsigned int *)0x100=1234;那么，要是想让程序员跳转到绝对地址0x100的位置上执行（比如：一个函数的地址是0x100，程序执行这个函数，就是跳到0x100地址执行）。怎样用一段代码实现**

> 定义函数指针，指向0x100的地址，执行
>
> typedef void (*PFUN) ();
>
> PFUN p=(PFUN)0x100;
>
> p();



29. **在c语言中，若要定义一个只允许本源文件中所有函数适用的全局变量，则该变量应该加什么关键字修饰**

> static



30. **经过下列运算后，i和a的值分别是**

```c
int i=4,a=0;
for(;i>0;i--){
	if(i==2){
		continue;
	}
	a++;
}
```

> i=0		a=3



31. **执行完下面程序后x[0]至x[5]的值应为**

```c
int x[6]={5,7,4,6,3,8};
int i,k,t;
for(i=0;i<5;i++){
    for(k=(i+1);k<6;k++){
        t=x[i];
        x[i]=x[k];
        x[k]=t;
    }
}
```

> 逆序 836475



32. **写出结果及原因**

**问题1：**

```c
unsigned char endian[2]={1,0};
short x;
x=*(short*)endian;
运行后，x的值是多少？
```

> 1

**问题2：**

```c
int i=1;
if(*(char*)&i==0)return true;
else return false;
```

> false



33. **x=5858,下面函数的返回值是**

```c
int foo(int x){
    int c=0;
    while(0!=x){
        ++c;
        x=x&(x-1);
    }
    return c;
}
```

> 32位整型二进制数1的个数（每次去除二进制位为1的为里面最右面的1 ）



34. **以下程序的输出结果为**

```c
char a[]="hello world";
char* p=a;
cout<<sizeof(a)<<endl;
cout<<sizeof(p)<<endl;
void func(char c[100]){
    cout<<sizeof(c)<<endl;
}
```

> a:12		p:4		c:4



35. **多个正整数相加得出一个整数K，并且这些整数的乘积要最大。如果这个整数K等于12，那么乘积是**

> 81
>
> 力扣 剑指offer14减绳子
>
> 分水岭4：2*2最大	比4小：3 2 *1	2 1 * 1		比4大：尽量分出3 



36. **在int b [ ] [3] = {{1},{3,2},{4,5,6},{0}};中，sizeof(b)等于多少**

> 4 * 3 * 4



37. **写出下面代码的输出结果**

```c
void main(){
    int a[5]=(1,2,3,4,5);
    int *ptr=(int*)(&a+1);
    printf("%d,%d",*(a+1),*(ptr-1));
}
```

> 2,5



38. **在64位机器下的输出为**

```c
int(*p[10])(int);
fprintf(stderr,"%d",sizeof(p));
```

> 10*8



39. **在little_endian（小端）机器，以下代码的输出是**

```c
union{
    int i,j;
    char a,b;
}x;

int main(){
    x.a=1;
    x.b=2;
    x.j=x.a+x.b;
    x.i=x.a+x.j;
    printf("0x%x\n",x.i);
    return 0;
}
```

> 0x8



40.  **如果x=2014，下面的函数的返回值是**

```c
int fun(unsigned int x){
    int n=0;
    while(x&255){
        n++;
        x=x&(x-1);
    }
    return n;
}
```

> 低8位二进制1的个数：6



41.

```c
#include<staio.h>
main(){
    FILE* fp;
    int i,a[4]={1,2,3,4},b;
    fp=fopen("data.dat","wb");//解释
    
    for(i=0;i<4;i++){
        fwrite(&a[i],sizeof(int),1,fp);//解释
    }
    
    fclose(fp);
    fp=fopen("data.dat","rb");
    fseek(fp,-2L*sizeof(int),SEEK_END);//解释
    
    fread(&b,sizeof(int),1,fp);//解释
    
    fclose(fp);
    printf("b=%d\n",b);
}
```

> 1. 以只写二进制形式打开文件"data.dat"，如果文件不存在，就创建；如果存在就清空，返回一个文件指针，赋值给fp。
> 2. 向fp指向的文件流，写入a[i]的二进制数，每次写4字节，写一次
> 3. fp指向的字节流从文件尾向前偏移2个四字节
> 4. 从fp指向的文件流中取四个字节的数据，读取一次，存到变量b中
> 5. b=3



42. **程序中如果有如下宏定义，#define RECTANGLE_AREA(a,b) a *b；如果int i=3,j=4;那么请问：RECTANGLE_AREA（i+5,i+j）的结果是**

> 3+5*3+4



43. **程序的局部变量存在于（栈区）中，全局变量存在于（全局区）中，动态申请数据存在于（堆区）中。**



44. **若一个视频中图像分辨率为1920*1080，每像素采样精度为16-bit，每秒25帧图像，则每秒图像占内存（25 *1920 *1080 *2）byte。(所有数据连续存放)**

- 分辨率表示有这么多像素点，每个像素点2字节



45. **请写出“得到两参数中较小值”的宏**

> #define MIN(a,b) ((a)>(b))?(b):(a)



46. **请写出"判断是否为2的次幂"的宏**

> #define IS_POWER_OF_2(a) ((a)&(a-1))==0?1:0



47. **int16_t x=32767;x++;printf("%d",x);输出的结果为：**

    > -32768



48. **下面程序的输出结果为**

```c
main(){
    char a[]="phoerix",b[]="finance";
    char* pa,*pb;
    int i;
    pa=a;
    pb=b;
    for(i=0;i<7;i++){
        if(*(pa+i)==*(pb+i)){
            printf("%c",*(pa+i));
        }
    }
}
```

> 空



49. **a=1;a+=++(a++);此时a的值为多少**

    > ++（a++）编译不通过



50. **a=0xf0;b=0xf1;c=1<<((a&b)^(a|b));c的值是多少**

    > 2



51. **count_ones是计算非零整数x的二进制表示下，有多少个bit是1.例如：10=(1010)2,则返回2，填写空行**

```c
int count_ones(unsigned int x){
    assert(x>0);
    int ones=1;
    while(______)ones++;
    return ones;
}
```

> assert();断言，为真：跳过这句话，继续执行；为假：程序会弹窗一个错误，然后程序退出
>
> x=x&(x-1)



52. **在一个64位的PC机器上存储0x12345678，如果该机器为小端，从高位到低位存储的字节顺序是（0x12345678），如果为大端，从高位到低位存储的字节为（0x12345678）**



53. **请实现32位大小端转换宏**

    > 把0x12345678转换成0x78563412
    >
    > 思路：通过和注入0xff000000等进行位与操作，可以拿到每一个字节；通过位移然后位或，将结果拼接（(size_t)(x)转化为无符号，右移补0）
    >
    > #define swap32(x)  (((size_t)(x)&0xff0000)>>24)|(((size_t)(x)&0x00ff0000)>>8)|(((size_t)(x)&0x0000ff00)<<8)|(((size_t)(x)&0x000000ff)<<24)



54.**32位机器，以下代码的输出结果**

```c
char* p;
char*q[20];
char m[20][20];
int(*n)[10];//指针
struct Mystruct{
    char dda;
    double dda1;
    int type;
};
Mystruct k;
printf("%d,%d,%d,%d,%d",sizeof(p),sizeof(q),sizeeof(m),sizeof(n),sizeof(k));
```

> 4,80,400,4,24



55. **int a[]={2,8,16,24};char* p1=a;char* p2=&a[3];那么p2-p1等于**

    > 12
    >
    > 偏移多少单位=地址的偏移/sizeof(指向类型)



56. **以下代码的执行结果是**

```c
int main(){
    int i=-2147483648;
    return printf("%d,%d,%d,%d\n",~i,-i,1-i,-1-i);
}
```

> 2147483647，-2147483648，-2147483647，2147483647（底层运算是用补码进行）



57. **十进制123转成十六进制（7B）**

    **十六进制F3转成十进制（243）**

    **八进制456转成十六进制（12E）**

    **十进制64表示成七进制（121）**



58. **下列程序的运行结果是**

```c
int main(){
    int a[5][2]={0,1,2,3,4,5,6,7,8,9};
    int* p=a;
    int(*p2)[2]=&a[1];
    ++p;
    ++p2;
    printf("%d\n",*p);
    printf("%d\n",**p2);
    printf("%d\n",p2[1][2]);
    return 0;
}
```

> 1
>
> 4
>
> 8



59. **32位x86系统，4字节对齐，下列代码的结果是**

```c
union uni{
    struct{
        char* p1;
        int n2;
        char c;
    }s1;
    struct{
        int n3;
        char* p4;
    }s2;
};
int main(){
    union uni u;
    printf("%d %d %d %d \n",sizeof(u),sizeof(&u),
           (int*)&u.s2.p4-(int*)&u.s1.p1,
          (char*)&u.s2.n3-(char*)&u.s1.p1);
}
```

> 12 4 1 0



60. **用变量a给出下面的定义**

    > 一个整型数：int a;
    >
    > 一个指向整型的指针：int * a;
    >
    > 一个指向指针的指针，它指向的指针是指向一个整型数：int **a;
    >
    > 一个有10个整型数的数组：int a[10];
    >
    > 一个有10个指针的数组，该指针式指向一个整型数：int *a[10];



61. **用变量a给出下面的定义**

> 一个指向有10个整型数数组的指针：int (*a)[10];
>
> 一个指向函数的指针，该函数有一个整型参数并返回一个整型数：int (*a)(int);
>
> 一个有10个指针的数组，该指针指向一个函数，该函数有一个整型参数并返回一个整型数：int (*a[10])(int);



62. **设typedef struct{char flag;short len;char* pdata;}CMD_PKT;**

    **CMD_PKT pkt=(0xFF,8,"12345678");//结构体初始化**

    > 在32位x86cpu环境下，sizeof(CMD_PKT)为**8**，sizeof(pkt)为**8**
    >
    > 在64位x64cpu环境下，sizeof(CMD_PKT)为**16**，sizeof(pkt)为**16**



63. **在32为x86cpu环境下，下列三行语句结束后，result的值为**

```c
unsigned char port=0x5a;
unsigned char result;
result=(~port)>>4;
```

> 0xfa
>
> **按位取反会操作32位，没有就补位；按位取反后，类型会变为有符号int**



64. **设**

```c
int arr[]={6,7,8,9,10};
int *ptr=arr;
*(ptr++)+=123;
printf("%d,%d",*ptr,*(++ptr));
```

> 输出：8，8
>
> **printf()从右向左计算**



65. **下面程序，求count的值**

```c
int func(){
    int count=0;
    unsigned int a=1;
    int b=-5;
    while(b++<=5){
        if(a+b>5){
            count++;
        }
        return count;
    }
}
```

> count=5
>
> a+b会发生类型转换，结果转成了无符号类型（数很大），b=-1 0 1 2 3 4时+1<5



66. **位运算（32位x86平台）**
    1. 0x321 & 0x2f=0x21
    2. 0x321 ^ 0x3f=0x31e
    3. ~0x321=cde



67. **请描述下面代码的运行结果，并说明原因**

```c
#include<stdio.h>
int main(){
    int i=0;
    int name[10]={1,2,3,4,5,6,7,8,9,10};
    for(i=0;i<=10;i++){
        name[i]=0;
       	printf("ok\n");
    }
    return 0;
}
```

> 输出11个ok，程序崩溃
>
> **栈检测是否越界是在return程序退出时检测的**



68. **下面的数据声明代表什么？**

    float(**def)[10]：def是一个指针，指向一个数组指针，该数组指针指向有10个元素的float型数组。

    double*( *gh)[10]：gh是一个指针，指向一个有10个double *类型的指针数组

    double (*f[10])()：f是一个保存10个函数指针的数组，函数的返回值时double类型，无参数

    int*(( *b)[10])：b是一个数组指针，指向 int *[10]，int *[10]是一个有10个int *元素的数组

    long(*fun)(int)：fun是一个函数指针，指向返回值long,参数int类型的函数

    int(*( *f)(int,int))(int)：f是一个函数指针，指向的函数参数是int,int,返回值是一个函数指针，指向的函数参数是int，返回值是int。



69. **下面程序的输出结果为**

```c
#include<stdio.h>
int main(){
    int v[2][10]={{1,2,3,4,5,6,7,8,9,10},{11,12,13,14,15,16,17,18,19,20}};
    int(*a)[10]=v;
    printf(**a);
    printf(**(a+1));
    printf(*(*a+1));
    printf(*(a[0]+1));
    printf(*(a[1]));
    return 0;
}
```

> 1 11 2 2 11



70. **下面程序的输出结果为**

```c
int fun(int *p){
    *p=*p*2;
    return *p++;
}
main(){
    int a=1;
    int sum=0;
    int i;
    for(i=0;i<3;i++){
        sum+=fun(&a);
    }
    printf("%d",sum);
}
```

> 14



71. **程序的运行结果为？**

```c
unsigned char* p1;
unsigned char* p2;
p1=(unsigned char*)0x801000;
p2=(unsigned char*)0x810000;
p1+5=?
p2+5=?
    
int *p1=(int*)0x801000;
p1+5=?
```

> 0x801005 0x810005 0x801014



72. **程序的运行结果为**

```c
unsigned char a,b,c,d;
a=30;
b=a++;
c=++a;
d=10*(a++);
printf("%d,%d,%d\n",b,c,d);
```

> 30,32,64(320-256)



73. **请写出下面表达式的值**
    1. (a=1)?2:3 				   2
    2. !!(0x12345678)          1
    3. 0x12345678 & ~0x1000       0x12344678
    4. 0x12345678 & ~0xfff           0x12345000



74. **解释下列输出结果**

```c
char shr1[]="abc";
char str2[]="abc";
const char str3[]="abc";
const char str4[]="abc";
const char* str5="abc";
const char* str6="abc";
char* str7="abc";
char* str8="abc";
cout<<(str1==str2)<<endl;
cout<<(str3==str4)<<endl;
cout<<(str5==str6)<<endl;
cout<<(str7==str8)<<endl;
```

> 0(栈区) 0(栈区) 1(字符常量区) 1(字符常量区)



75. **下述函数的作用是：消除字符串首尾空白符（仅指跳格符'\t'和空格符' '），中间的连续空白符合并为一个空格，请补充其中缺失的行**

```c
#define ISWHITE(x) (_______)
void trim(char* pstr){
    char* pr=pstr;//r 读指针
    char* pw=pstr;//w 写指针
    while(ISWHITE(*pr)){
        ++pr;
    }
    for(;;){
        while(___){
            *pw++=*pr++;
            if(*pr=='\0')break;
        }
        while(____){
            ++pr;
            if(*pr=='\0')break;
        }
        __________;
    }
    _________;
}
```

> do{x=='\t'||x==' '?1:0}while(0)
>
> !ISWHITE(*pr)
>
> ISWHITE(*pr)
>
>  if(*pr=='\0')break; else *pw++= ' ';//跳过空白符，多个变成一个
>
> *pw='\0'



76. **下面表达式的计算结果是**

    int i=0xf0000000,i>>=1;						i=0xf8000000

    unsigned int i=0xf0000000,i>>=1		  i=0x78000000

    signed char c -1;int i=(int)c					i=-1

    unsigned char c=-1;int i=(int)c				i=255

    int i=(int)(3 *1.0/2 *3);							i=4

    int i=3;i=!!i;											i=1

    int i=3 || 2 && 0;									i=1

    int i=(3&5)?6:7										i=6

    

    77. **32位x86平台，4字节对齐，下列代码的执行结果是**

    ```c
    struct{
        int *p;
        int val1;
        int val2;
    }a={&a.val1};
    int* p=(int*)&a;
    p[0]=(int)&a.val2;
    p[2]=2;
    printf("%d,%d,%d",*a.p,a.val1,a.val2);
    ```

    > 2,0,2
    >
    > a.p指向a.val2的地址

    

    78. **写出下列函数的运行结果**

    ```c
    #include"stdafx.h"
    #include<iostream>
    using namespace std;
    void main(){
    	int a=0,b=0,c=0;
        b=++a&&a--;
        c=++a||a--;
        cout<<"a="<<a<<endl;
        cout<<"b="<<b<<endl;
        cout<<"c="<<c<<endl;
    }
    ```

    > 1 1 1

    

    79. **在IA32架构下，下面的union结构的sizeof大小位**

    ```c
    union PageLatout{
        struct{//可以看作变量，只是占地方的
            int page_index;
            char key[5];
        };
        char dummy[10];
        /*
        struct node{
            int page_index;
            char key[5];
        };
        char dummy[10];
        如果是这种写法：在c中，还是12个字节，它可以看作变量
        在c++中，是10字节，他被看做是内部类，是一个类型，不占空间
        */
    };
    ```

    > 12

    

    80. **运行结果**

    ```c
    #define equal(a,b) a==b
    int a=3,b=7;
    printf("%d",equal(a&3,3&&b));
    ```

    > 1

    

    81. **写出下面代码在32位和64位操作系统下的输出结果**

    ```c
    void test(){
        char x[]="10jqka";
        char y[20]="10jqka";
        wchar_t wch[]=L"10jqka";//每个字符占两个字节
        
        printf("%d,%d,%d,%d,%d,%d,%d,%d",
              sizeof(char),sizeof(char*),
              sizeof(x),strlen(x),
              sizeof(y),strlen(y),
              sizeof(wch),wcslen(wch));
    }
    ```

    > 32:1，4，7，6，20，6，14，6
    >
    > 64:1，8，7，6，20，6，14，6

    

    82. **阅读以下代码，说明main函数打印了什么值，并简述各子函数的含义**

    ```c
    unit32_t process(const char* pvalues,unit32_t num,const unit32_t* NUMBERS){
        unit32_t retValue=0;
        for(unit32_t i=0;i<num;i++){
            retValue+=NUMBERS[pvalues[i]];
        }
        return retValue;
    }
    unit32_t process2(unit8_t value){
        unit32_t count=0;
        while(value!=0){
            if((value&1)!=0){
                ++count;
            }
            value>>=1;
        }
    }
    int main(char** args,int num){
        unit32_t NUMBERS[256];
        for(unit32_t i=0;i<=255;i++){
            NUMBERS[i]=process2(i);
        }
        const char* pvalues ="aAbBcC";
        unit32_t processvalue=process(pvalues,strlen(pvalues),NUMBERS);
        fprintf(stdout,"%d\n",procesvalue);
        return 0;
    }
    ```

    > process2计算：下标值32位二进制1的个数
    >
    > process计算：pvalues中各字符二进制位1的个数之和

    

    83. **指针a与b，不用中间变量，实现a与b所指向的内容交换的程序**

    > 异或，判断地址是否相等



84. **运行的结果，以及会出现的现象，并解释原因**

```c
//a.c
#include<stdio.h>
char blueBall[10]="blueBalls";
void modifyAndShowBall(char* ball){
    printf("\r\n%s",ball);
    ball="BIGBLUE";
    printf("\r\n%s",ball);
}
void showThisBall(){
    printf("\r\n%s",blueBall);
    modifyAndShowBall(blueBall);
    printf("\r\n%d",blueBall);
}
void showAnyBall(char* blueBall){
    printf("\r\n%s",blueBall);
}

//main.c
#include<stdio.h>
extern char* blueBall;//声明extern 修饰的变量，链接同名的已经存在的变量空间
extern void showThisBall();
extern void showAnyBall();
int main(){
    showThisBall();
    showAnyBall(blueBall);
    printf("%s",blueBall);
    return 0;
}
```

>  extern char* blueBall;相当于blueBall保存了a.c数组的地址
>
> 在main.c中不能使用a.c文件中的地址，会崩溃。
>
> 原来是10各元素的数组，现在当成指针了



85. sizeof()返回结果是无符号整数，放在表达式里，其他的也会变成无符号类型（a<=sizeof(b)-c）a也会转换成无符号类型





















# c++



## 基础



一、c/c++的比较

> 面向对象三大特性：封装、继承、多态（会展开）
>
> **面向对象、面向过程的区别：面向过程侧重高效解决问题（代码越精简越好），面向对象侧重复用、维护、扩展。**
>
> c/c++结构体比较：c++结构体有类的特性（展开）
>
> c++ struct 与类的比较：默认访问属性不同
>
> new malloc的区别
>
> 指针、引用的区别
>
> 指针的引用:int* &p=a;//对		int& *p=a;//错



二、类

> **概念：具有相同行为（函数）和属性（成员变量）的个体（对象）的抽象（类）**
>
> 访问权限

1. 构造函数

> 默认构造：当没有写任何构造函数（包括拷贝构造），系统会生成默认的无参构造，并且访问属性为共有访问
>
> 默认拷贝构造：当没有任何的拷贝构造，系统会生成默认的拷贝构造-》浅拷贝
>
> 浅拷贝和深拷贝：主要针对指针成员的赋值
>
> 浅拷贝造成的后果
>
> **浅拷贝和shared_ptr**
>
> 拷贝构造的写法：参数时引用原因：**如果用对象传参，还要给参数进行拷贝构造，会陷入循环。**
>
> **拷贝构造的使用场合：1. 用一个已存在对象初始化另一个对象。2. 传参（形参是一个对象）3. 返回值是对象 4. list<a>lst;lst.push_back(A);调用拷贝构造list<A*>不调用**



2.初始化列表

> 初始化列表内容：父类的构造，成员（对象成员，const成员，成员初值）的构造或给初值赋值
>
> 顺序：父类构造先于成员构造或给初值（成员按照声明先后顺序）
>
> ```c
> chass a{
> 	a(){cout<<"a";}
> };
> class b{
>     b(){cout<<"b";}
> };
> class c:public a{
>     c(){cout<<"c";}
>     B b;
> };
> //abc
> ```
>
> ```c
> class a{
> 	a(int val):b(val),a(b){}
>     int a;
>     int b;
> };
> //a是随机值，b是val（按声明顺序）
> ```

3.析构

> ~类名 没有参数 没有返回值
>
> 虚析构的问题：析构函数用virtual修饰
>
> 父类指针=子类对象；delete父类指针：如果父类是虚析构，先调用子类析构，再调用父类析构；父类不是虚析构，只调用父类析构。

4.const修饰

> 修饰类内成员变量，类内成员函数，变量，对象，类外函数
>
> **c++const修饰的是常量，cconst修饰的是只读变量**
>
> >  修饰成员属性：常量，再初始化参数列表里初始化
> >
> > 修饰成员函数：常函数，修饰this指针 const a* const this
> >
> > 修饰类外对象：常对象，常对象只能调用常函数，不能调用普通函数；**如果想调用普通函数：去常转换 const_cast<类型>(待转换量)，或者用强制类型转换**

5.static

> 修饰类内成员变量，类内成员函数，变量，对象，类外函数
>
> > 修饰成员属性：不依赖对象，类共用的，不可以被继承，类外初始化；**不能在.h文件里初始化（重定义的问题），要在.cpp文件初始化**
> >
> > 修饰成员函数：没有this指针，可以不依赖对象使用，类公用的，**不可以声明为虚函数**，不能直接调用类中的非静态成员，可以利用对象调用静态成员函数。
> >
> > 全局变量和静态变量的区别：静态全局和全局：静态不能跨文件；静态局部和全局：作用域不同
> >
> > 修饰类外函数：只能在当前文件可见
> >
> > 修饰类外变量：只能在当前文件可见，修饰全局和局部，是全局/局部静态变量，生命周期到程序退出时结束（存在全局区），无论全局还是局部，都是初始化一次，没有初始化默认为0.

6.virtual

> 修饰虚函数，实现动态多态
>
> 不可以修饰的函数：构造函数，static，inline，friend，类外的普通函数

7.inline

> 内联函数：在执行的位置直接展开函数，省去调用的时间（空间换时间）
>
> 使用情况：...，常将构造和虚构设置为内联函数
>
> **虚析构不可以使用inline的原因：虚函数是用于多态的，他的实现代码是不确定的（执行什么函数在运行时才能确定），不能直接拿过来展开**

8.friend

> 使其他类或函数可以调用自己的私有和保护成员
>
> ```c
> class a{
>     private:
>     int b;
>     void c(){}
>     friend class aa;
>     friend voic aaa();
> }
> class aa{
>     void fun(){a A;A.c();}
> }
> void aaa(){
>     a A;
>     A.c();1
> }
> ```
>
> **友元不可以被继承：父类中有友元函数，可以被其他类访问；子类不继承父类的友元函数，其他类不可以访问子类**
>
> **友元类和友元函数并不是类内的函数和类；所以不能直接使用类的成员，可以通过对象来使用成员。**
>
> **优点：访问使用保护和私有，使用更方便。缺点：破坏了封装，安全性差。（平时可以使用公共的get方法来获取）**

9.纯虚函数

> 纯虚函数：虚函数=0
>
> **抽象类：含有纯虚函数的类**
>
> **接口类：类内函数全是纯虚函数**
>
> 含有纯虚函数的类不能实例化，在子类实现了所有纯虚函数之后，才能实例化对象。

10.重载操作符

> **operator=赋值重载操作符（只能类内重载）**
>
> 与拷贝构造的比较

**11.内部类**

> **如果一个类B定义在另一个类A的内部，这个类B就叫做内部类，类A叫做外部类**
>
> **性质：**
>
> **1.内部类是独立的，不属于外部类，更不能通过外部类的对象去调用内部类。**
>
> **2.内部类就是外部类的友元类，内部类可以通过外部类的对象来访问外部类中的所有成员。**
>
> **3.外部类不是内部类的友元**
>
> ```c
> class outer{
> 	public:
> 	class inner{
> 		public:
> 		void say(outer* p){
> 			cout<<p->a<<endl;//可以访问，因为内部类是外部类的友元类
>         	cout<<s<<endl;//可以直接访问外部类的static成员不用类名和对象
>         }
>         private:
>         int i;
> 	};
>     void speak(inner* ie){
>         //cout<<ie->i<<endl;外部类不是内部类的友元类，不可访问
>     }
>     private:
>     int a;
>     static int s;
>     class private_inner;
> };
> 
> //内部类可以在类外定义
> class outer::private_inner{
>     public:
> 		void say(outer* p){
> 			cout<<p->a<<endl;//可以访问，因为内部类是外部类的友元类
>         	cout<<s<<endl;//可以直接访问外部类的static成员不用类名和对象
>         }
>         private:
>         int i;
> };
> 
> int main(){
>     outer o;
>     outer::inner ir;
>     //outer::private_inner pi;不可以定义外部类对象
>     //在堆中创建内部类
>     outer::inner*pi=new outer::inner;
>     delete pi;
>     
>     cout<<sizeof(o)<<endl;//4 内部类是类型，不占空间
> }
> ```
>
> **注意：**
>
> **1.内部类可以定义在外部类的public,protected,private都是可以的，如果内部类定义在public，则可以通过 外部类名::内部类名 来定义内部类的对象。**
>
> **2. 内部类可以直接访问外部类中的static，枚举成员，不需要外部类的对象/类名。**
>
> **3. 内部类可以在外部类类外定义。 **
>
> **4. sizeof(外部类)=外部类，和内部类没有关系。**
>
> **5.定义堆区内部类对象的方法 outer::inner pi=new outer::inner;**

12.

> **空类中一定包含的函数：析构，拷贝构造，默认无参构造，重载=操作符，重载&操作符**
>
> **空类的大小：sizeof(a);	1**
>
> **不可复制的类**
>
> ![image-20230331130304542](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20230331130304542.png)

13.

> **多继承：一个子类继承多个父类**
>
> ```c
> class b:public a1,public a2{}
> ```
>
> **性质：虚表a1 a2 都会有一份，b里面就应该有来自a1 a2的两个虚表，如果子类增加特有的虚函数，那么要在第一个虚表中添加。**
>
> 
>
> **菱形继承（钻石继承）：两个子类继承同一个父类，一个孙子继承两个子类**
>
> **问题：爷类有一个变量，两个父都给他初始化，在孙类会产生二义性，编译不会通过**
>
> **解决：采用虚继承**
>
>  
>
> **虚继承：主要解决多重继承中的菱形继承问题**
>
> ```c
> class a{
> public:
> 	virtual void fun(){}
> };
> 
> class b:virtual public a{
> public:
> 	virtual void fun1(){}	
> };//b包含两个虚表
> ```
>
> **特性：**
>
> **1. 父类和子类在空间上是一种倒置关系（与普通继承相比）**
>
> **2. 子类特有的虚函数，会有自己的虚表，就会有自己的虚指针，class b有两个虚表**
>
> **3. 子类存在指向虚基类（虚继承里面的基类）的虚基表，子类会有虚基表的指针vbptr，它指向这个虚基表，虚基表里面的内容是指向自己及虚基类的地址偏移量。**
>
> **4.最底层的子类，完成虚基类的构造**
>
> ![image-20230331123352835](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20230331123352835.png)
>
> ![image-20230331124125411](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20230331124125411.png)
>
> ![image-20230331124947099](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20230331124947099.png)



三、类之间的关系

> 横向（组合、依赖、关联、聚合）、纵向（继承）
>
> 继承方式，默认私有



四、多态

> 多态：代码不变，功能可变（函数指针）；分为静态多态和动态多态
>
> 静态多态：是编译时确定执行什么函数，可任意通过函数重载，模板方法来实现静态多态。
>
> 动态多态：通过继承和虚函数实现，在运行时确定。
>
> **虚指针：指向虚函数列表的指针，虚指针是对象的前四个字节，通过取前四个字节，就能找到虚函数数组的入口点。**
>
> 动态多态的实现过程：1.父类要有虚函数，就有一个虚函数列表。2.子类继承父类，子类就有一个虚函数表，子类重写虚函数，就会覆盖虚函数表里面的虚函数地址。3.定义子类对象，子类对象的前4个字节就会有一个虚指针，虚指针指向虚函数表，父类指针指向子类对象。4.父类指针调用虚函数，就会根据子类对象的前四个字节，得到虚指针，进而得到虚函数表的入口地址，通过遍历虚函数表调用虚函数。
>
> 解决多态类问题：首先看调用函数是不是虚函数，是的话，看子类的虚表，看有没有重写。如果不是，指针是什么类型，就到哪个类里面执行。
>
> **虚函数多态可以利用引用实现**
>
> ```c
> class B:public A
> B b;
> A &a=b;
> ```
>
> 虚函数多态优缺点：
>
> > 优点：可以代码不变，功能可变，具有良好的拓展和复用
> >
> > 缺点：空间消耗，运行效率会相对低一些，破坏封装；虚函数多态没有办法调用子类特有的虚函数。
>
> 重载和重写
>
> 手写实现多态，实现通过虚表调用虚函数（用到了类成员函数指针）
>
>  
>
> 继承方式：默认私有
>
> 类内的static const变量是要在声明的时候初始化的
>
> const要在初始化列表初始化
>
> static要在类外初始化





习题知识点：

> **结构体是默认属性位私有的类，可以继承，可以有虚函数。**
>
> **使用指针调用类函数：**
>
> > **看是否为虚函数：**
> >
> > **如果是，找对象（看对象类型，不是指针类型）前四个字节的虚函数表；如果是父类指针指向子类对象，看子类是否重写了虚函数**
> >
> > **如果不是，看指针类型，到那个类找函数**
>
> A a; A b; b=a;是=运算符重载
>
> A a; A b=a;是拷贝构造
>
> 
>
> 虚函数、模板类是迟后编译的（在使用的时候不知道他是什么类型，会等类型确定下来才进行编译）
>
> 模板类的定义和声明要在同一个文件内
>
> 迟后编译：模板类实际时不完整的类型，需要等指明模板参数类型之后，才是完整的类型，在编译时会跳过（即在没有使用模板类的时候，就算模板类内部有错误，也不会编译报错）
>
> 
>
> 虚函数重写（覆盖）有一种特殊情况是协变：返回值可以不同，父类返回父类指针，子类返回子类指针
>
> 
>
> 泛化：继承的反向，通过子类反推父类
>
> 
>
> **构造函数和析构函数中调用虚函数采用静态联编（？），没有办法实现多态（在构造函数执行的时候，虚表还没有构建，在析构函数执行的时候，虚表已经释放）；对析构函数的调用可以采用动态联编。**
>
> 
>
> 类内不能有类本身的对象，但可以有类本身的引用（在用this指针来初始化）：
>
> A &a;	A():a(*this){};
>
> 
>
> c++的多态性分为编译时的多态和运行时的多态（静动？），编译时多态可以通过函数重载实现，运行时多态可以通过虚函数实现。
>
> 
>
> m是A类的成员属性，a是A的一个对象，使用成员变量指针将a.m赋值为5
>
> int A::*p=&A::m
>
> a.*p=5;
>
> 
>
> 父类的虚函数在子类中也是虚函数，无论加不加virtual（不手动加的话会系统添加）
>
> 
>
> static变量不能继承，原因：static变量是公用的，子类继承父类后可以修改父类中静态变量的值；而继承关系中子类不能修改父类的变量。
>
> 静态函数也不能申请为虚函数，因为也是共用关系。
>
> 
>
> 有虚函数就有虚表，有虚表就有虚指针，虚指针占字节
>
>  
>
> 若形参是对象，实参传了整型或其他类型：
>
> ```c
> B play(B b){return b;}
> play(5);
> ```
>
> 相当于B b=5;即B b(5);即调用了有参构造，发生了隐式类型转换。（explicit避免隐式类型转换）
>
> **如果有两次拷贝构造，中间有临时对象，编译器会优化，构造执行一次（即不产生临时对象）**
>
> （5244）（如果不是拷贝，而是赋值：等号重载1524344）
>
> ![010E0FC1401DE9D1A26391D8C5DA2AA1](D:\文件\2480454254\Image\C2C\010E0FC1401DE9D1A26391D8C5DA2AA1.jpg)
>
> 



> 函数栈：后进先出，定义两个对象，先构造的后析构
>
> c++不能嵌套定义：在函数中定义函数



> c++中malloc和new不能互相代替，虽然他们都是在堆上开辟空间，但是malloc如果用来申请对象的地址，是不会执行构造函数的。
>
> delete不是只能回收new出来的对象，也可以回收malloc出来的
>
> **malloc动态分配内存 new动态创建对象**



> vector没有push_front()，不可以头插入
>
> STL中list（双向循环链表）使用的迭代器是双向迭代器。
>
> vector使用的是随机访问迭代器（++一次可以移动多下，能够用下标访问）
>
> STL不是线程安全的
>
> stack是配置器，是用deque实现的



> 指针类型的引用：int* b;	int* &a=b;

















## c++11



一、auto

二、基于范围的for循环

三、lambda表达式

> 函数作为一个参数出现时，需要在函数外写函数的实现，以前无法在函数内实现另一个函数
>
> lambda表达式，定义匿名函数，又称lambda函数，可以在函数内部实现函数定义
>
> ```c
> auto 函数名=lambda表达式；可以通过函数名，调用函数
> sort(vec.begin(),vec.end(),[](int a,int b){return a>b;});//作为匿名函数使用
> []()mutable->type{}
> ```



四、智能指针

> 智能指针：万物皆可对象、指针封装-》类 构造 析构 -》回收指针所指向的空间（自动回收空间）
>
> std四个智能指针 auto_ptr c++98标准以后：unique_ptr	 shared_ptr 	weak_ptr
>
> 智能指针头文件:#include<memory>
>
> ```c
> class AAAA{
> 	AAAA(string a){b=a;}
> 	string b;
> 	void get(){cout<<"get";}
> };
> //auto_ptr
> //创建对象
> auto_ptr<AAAA> ap1(new AAAA("auto_ptr"));//法1
> auto_ptr<AAAA> ap2;//法2
> ap2.reset(new AAAA("auto_ptr2"));//先清空原来的，再set新的
> auto_ptr<AAAA> ap3;//法3
> ap3=ap1;//用ap1给ap3赋值后，ap1清空，为空指针
> 
> //使用对象
> ap3.get()->say();//法1
> ap3->say();//法2
> ap3.reset();//主动回收对象，析构
> ap3.release();//赋空
> 
> //存在的问题：使用交出的太随意了，交出后，原指针为空，失效：ap1->say()会出问题，ap1析构不会有问题
> ```
>
> ```c
> //unique_ptr 唯一所有权智能指针
> //和auto_ptr的创建方式是一样的
> unique_ptr<AAAA> up3;
> up3=std::move(up1);//使用权传递：把up1的使用权传给up3
> //缺点：使用权传递的方式要求太严格
> ```
>
> ```c
> //shared_ptr 共享所有权智能指针
> //多个指针指向同一个堆空间，通过引用计数（use-xounts），来记录所有权的指针个数；当引用计数为0时，回收这个堆空间
> //定义对象
> shared_ptr<AAAA>sp1(new AAAA("ha"));
> //shared_ptr<AAAA>sp1=shared_ptr<AAAA>(new AAAA("ja"));
> shared_ptr<AAAA>sp2;
> sp2.reset(new AAAA("ka"));
> shared_ptr<AAAA>sp3;
> sp3=make_shared<AAAA>("ha");
> {
> 	shared_ptr<AAAA>sp4;
> 	sp4=sp3;
> 	cout<<sp4.use_count()<<endl;//2
> }
> //使用
> sp3.get()->say();
> sp3.say();
> sp3.use_count();//查看引用计数
> ```
>
> ```c
> //weak_ptr 弱引用计数的共享使用权的智能指针，指向同一空间，引用计数不会+1
> //它的提出主要是解决shared_ptr存在循环引用的问题
> ```



五、右值引用

> 右值对象一般是临时对象
>
> 引用：左值引用，右值引用，常引用
>
> &&
>
> ```c
> Data data;
> Data& data1=data;//ok，左值引用
> Data& data1=Data();//no,不能做右值的引用
> Data&& data2=Data();//ok,右值引用
> Data&& data2=data;//no,不能做左值的引用
> Data&& data2=std::move(data);//ok,move将左值转为右值(在编译期告诉编译器返回值是一个右值，在运行七不做任何事)
> 
> //常引用
> const int& a=3;
> const Data& b=Data();
> ```
>
> 常引用和右值引用的异同：
>
> 同：通过右值引用/常引用初始化的右值，都可以将生命周期扩展到绑定该右值的生命周期
>
> 异：初始化时绑定了右值后，右值引用可以修改引用的右值，而常引用不能修改
>
>  
>
> 作用：
>
> 1. 为了实现转移语义（对象之间的赋值）和完美转发，消除两个对象交互时不必要的对象拷贝（return std::vector<>&&）
>
> 2. 能够简洁明确地定义泛型函数（精确传参 const int& --int b     int&&--2）
>
>    ![image-20230328194310171](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20230328194310171.png)
>
> **push_back()会有临时对象的创建；emplace_back()使用了右值引用，没有临时对象**



六、四种类型转换 [type_cast.cpp](其他\type_cast.cpp)  

> static_cast<类型>(待转换量)
>
> 编译时确定，相关内容的转换 数与数之间int short long之间 int*和void *；继承中对象的向上和向下转换（向下转换没有校验，可能出问题：兄弟之间的转换）
>
> 不相关的不能转换int* 和char *不能

> dynamic_cast<类型>(待转换量)
>
> **只适用于**继承链上的两个类之间转换（向下转换有检验：不安全：兄弟之间的转换（？父类指针指向子类对象，要转换成兄弟），返回结果为空；安全：父类本来指向子类，恰巧还要转成该子类、父类指向孙子类，可以转成子类），向下转换，父类中必须包含虚函数

> const_cast<类型>(待转换量)
>
> 去常转换，去const 或volatile
>
> reinterpret_cast<类型>(待转换量)
>
> 重解释类型转换，啥都能转







## 设计原则

一、单一职责

> 功能单一，方便组合和复用



二、开闭原则

> 对扩展开放，对修改关闭



三、里氏代换原则

> 任何基类可能出现的地方，子类一定出现（简单工厂）



四、依赖倒转原则

> 针对接口编程，依赖于抽象而不依赖具体（网络封装）



五、接口隔离原则

> 使用多个隔离的接口，比使用单个接口更好



六、迪米特法则（最少知道原则）

> 一个实体应当尽量少的和其他实体之间发生相互作用，使得系统功能模块相对独立（飞机大战的子弹 ）



七、合成复用原则

> 尽量使用合成/聚合的发生，而不是使用继承

低耦合：降低彼此的依赖

高内聚：职责尽量单一







## 设计模式（要会类图）



一、单例模式

> 为什么用它？避免复刻，该类只需要一个对象
>
> 如何实现？构造析构拷贝构造私有，提供静态公有的获取对象的方法



二、简单工厂

> 例子：写一个四则运算+-*/，使用简单工厂
>
> 运算类operator：运算数A 运算数B virtual int getResult();（写四个类(+-//)继承运算类）
>
> 简单工厂factor：创建运算类（父类）operator* o(string opr)，根据opr的不同，new不同的子类。



三、工厂方法模式

> 例子同上
>
> 运算类operator：运算数A 运算数B virtual int getResult();
>
> 工厂：创建运算类virtual operator* o=operator(string opr)，写四个类继承工厂类（+-*/工厂）



四、中介者模式

> 用一个中介对象来封装一系列的对象交互（网络中的mediator类就是个中介者）
>
> 中介者使对象不需要显式地相互引用，从未使其耦合松散，而且可以独立地改变他们之间的关系



五、观察者模式

> 又叫发布-订阅模式
>
> 定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主体对象
>
> 这个主体对象在状态发生改变时，会通知所有观察者对象，是他们能够自动更新自己
>
> 例子：酒店和会员



六、策略模式

> 定义了算法家族，分别封装起来，让他们之间可以互相替换。此模式让算法的变化，不会影响到使用算法的用户。
>
> 例子：商场打折， 有满100减10， 有打七折， 有满200返30
>
> 优点：方便扩展新的策略功能的实现
>
> 缺点：使用简单工厂的逻辑，添加新实现，需要修改工厂逻辑的代码



七、抽象工厂模式





## STL

一、六大组件

容器：序列容器 vector list deque 关联容器 map set unordered_map

迭代器：输入输出迭代器，向前迭代器，双向迭代器，随机迭代器

算法：sort find merge random_shuffle

仿函数：类重写() 对象() ->实现函数

配接器：容器 算法 迭代器 提供一些可以修改的接口

​				stack queue 是通过deque去变化而来的

配置器：空间配置器 主要是空间的配置管理



二、问题

数据结构->底层

不同数据结构的使用场景、优缺点

集中容器的比较：vector list、map hash_map

迭代器失效的问题：vector list deque 插入删除

*STL不是线程安全的，项目中涉及到需要加锁；或者自己重写数据结构，让其线程安全





## 逻辑题



1. **n从1开始，每个操作可以选择n加1或者对n加倍，若想获得整数2014，最少需要多少个操作。**

   > 法1：将大数缩成小数：2014--1007--1006--503--502--...1（偶数除二，奇数减一）
   >
   > 法2：二进制（例如：获得整数10）：1要变成1010，左移两位，加一，左移一位，即可得到；
   >
   > ​	左移的次数：最终数的二进制位-1，加一的次数为：最终数的二进制中1的个数

2. **一个池塘，养龙虾若干，想一个办法尽量准确的估算其中有多少龙虾**

> 标记重补法

3. **S先生，P先生，Q先生他们知道桌子的抽屉里面有16张扑克牌，红桃A Q 4，黑桃J 8 4 2 7 3，草花K Q 5 4 6，方块A 5 ，约翰教授从这16张扑克牌中抽出一张牌，并把这张牌的点数告诉P先生，把这张牌的花色告诉Q先生，这时的约翰教授问P先生和Q先生，你们能从已知的点数和花色中推知这张牌是什么牌吗？**

   **P：我不知道这张牌**（1）

   **Q：你不说我也知道你不知道这张牌**（2）

   **P：现在我知道这张牌了（3）**

   **Q：我也知道了（4）**

   **请问是什么牌？**

   > （1）p不知道这张牌，说明该牌的点数出现不止一次：A Q 4 5
   >
   > （2）q知道p不知道这张牌，说明该牌的花色中全是不知出现一次的：红桃、方块
   >
   > （3）p知道了，说明p该牌的点数在红桃和方块中是唯一的：Q 4 5
   >
   > （4）q也知道了，说明在排除A后，该花色的牌只剩一个了：方块5

4. **有16瓶水，其中一瓶水有毒，小白鼠喝一滴之后一小时后会死。请问最少用多少只小白鼠，在一小时内一定可以找出那瓶有毒的水？**

   > 四只
   >
   > 1：喝前八瓶
   >
   > 2：喝前八瓶的前四瓶和后八瓶的前四瓶
   >
   > 3：和前四瓶的前两瓶和第二个四瓶的前两瓶和第三个四瓶的前两瓶和最后四瓶的前两瓶
   >
   > 4：喝第1 3 5 7 9 11 13 15瓶
   >
   > **变体：有两瓶水有毒，一小时找到**
   >
   > ​			**一瓶水有毒，两小时找到**
   >
   > 可以将瓶子数转换成二进制，1代表喝，0代表不喝，每一位代表一个小白鼠，可以保证喝每瓶水的小白鼠组合都不一样（16（0000）->4位二进制，4只小白鼠）

5. **烧一根不均匀的绳子需要一个小时，给你两根这样的绳子，能判断出一段15分钟的时间吗？**

   > 第一根两头一起烧，同时第二根从一头开烧（第一根烧完，过了半小时），第二根两头一起烧，烧完为15分钟

6. **五个海盗分一百个金币，每个人可以提出一个方案，大多数人同意方案才能通过，如果哪个人提出的方案没有通过就扔到海里喂鱼，他们抽签决定各自的顺序，然后一次提出自己的方案（1号最先提出，2.3.4.5）问：1号怎么能保住自己的小命，又能获得最大利润。**

   > 从最后一个人开始看（同意率大于50%才通过）
   >
   > 5：想独占一百各金币，必不会同意4号的方案，这样4号喂鱼了，自己就独占了
   >
   > 4：为了保命，必会同意三号的方案
   >
   > 3：4号一定同意自己的方案，一定会通过，分：100 0 0
   >
   > 2：需要除自己外的两个人支持自己，3号一定不会同意，不给3号，需要买通4号5号，只需要比3号给的多即可：98 0 1 1
   >
   > 1：需要除自己外的两个人支持自己，2号一定不会同意，不给2号，买通345的中的两个，3号不支持1的话，一个都得不到，因此给3一个就买通了，四号五号能获得一个，因此给他们任意一个两个金币就能买通：97 0 1 2 0或97 0 1 0 2

7. **四兄弟一个比一个大一岁，他们四个年龄之积是3024，问每个兄弟几岁**

   > (x-1)x(x+1)(x+2)=3024;
   >
   > 3024=4 *756 = 4 *7 *108 = 4 *7 *4 *27 =  4 *7 *4 *3 *9（7 *9 *8 *6）

8. **宿舍内5各同学玩对战游戏，每场比赛有一些人作为红方，另一些人作为蓝方。请问至少需要多少场比赛，才能使任意两个人之间有一场红方对蓝方（1：3）和蓝方对红方（3：1）的比赛**

   > 可以一对四     四对一     二对三    三对二
   >
   > 一对四：4对
   >
   > 二对三：6对
   >
   > 5名同学，共4*5=20对，虽少需要4场比赛

9. **ABCDEFG七人站队，要求A必须在B的左边（可不相邻），共有多少种排法**

   > A要么在B左边，要么在B右边，总共7！种排法，则A在B左边的排法为7！/2
   >
   > ​	**在上面的条件下，AB必须相邻，有多少种排法**
   >
   > AB堪称一个整体，有6！种排法

10. **公司组织团建，每个员工可以带家属来，一次活动共有20个人（含员工和家属）参加，一致如果随机选取3位员工以及该3位员工的家属，一共有220组合，问如果每次随机选取4各员工及该四位员工的家属，会有多少组合？**

    > 选了员工，其家属一定出席，所以220种组合即为从所有员工中选3个是220种：C3x=220
    >
    > 求C4x

11. **2012!的末尾有多少个0？**

    > 0的来源：5的倍数

12. **一个5升的水桶，一个3升的水桶，问如何和得到准确的4升水**

13. **房间里有50盏灯（编号为1-50）和50个开关（编号为1-50），当按下i号开关时，所有i的倍数的deng就变换一下状态（亮-熄，熄-亮）。比如按下2号开关时，2 4 6 8号等变更状态。小明走进房间，发现所有灯全熄着，于是依次按下了1 2 3 ...50所有开关，请问最后有多少盏灯亮着？**

    > 平方数亮着

14. 0204-4（数据库复习还有两道逻辑题）







# 数据库database

