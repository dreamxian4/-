





# ----相关函数

## vs



```c++
//换行：\0

//线程相关头文件
#include<Windows.h>
//线程函数
DWORD WINAPI ThreadProc01(LPVOID IpParameter){}
//创建线程
//立即执行 ExitThread退出线程 系统自动调用
HANDLE hand = CreateThread(NULL,0,&ThreadProc01,(VOID*)80,0,NULL);
//挂起
HANDLE hand = CreateThread(NULL,0,&ThreadProc01,(VOID*)80,CREATE_SUSPENDED,NULL);
//会回收c++运行时库函数开辟的空间的创建线程方式 _endthreadex系统自动调用
_beginthreadex(NULL, 0,&recvthread ,this , 0, NULL);
//获取当前线程ID
GetCurrentThreadId();
//线程挂起
SuspendThread(hand);
//线程恢复
ResumeThread(hand);
//等待线程执行100秒
if(WaitForSingleObject(hand, 100) == WAIT_TIMEOUT){}
//杀死线程
TerminateThread(hand, -1);
//关闭句柄
CloseHandle(hand);
//关键段
CRITICAL_SECTION cs;
//初始化关键段
InitializeCriticalSection(&cs);
//删除关键段
DeleteCriticalSection(&cs);
//进入关键段
EnterCriticalSection(&cs);
//离开关键段
LeaveCriticalSection(&cs);
//加载库
#include"./lib/pch.h"
#pragma comment(lib,"./lib/StaticLib1.lib")
//给别人使用的函数 动态库
_declspec(dllexport) int add(int a, int b);
//网络相关头文件
#include<winsock2.h>
#pragma comment(lib,"Ws2_32.lib")
//加载库
WSAStartup(wVersionRequested, &wsaData);
//设置版本号
MAKEWORD(2, 2);
//卸载库
WSACleanup();
//获取错误码
WSAGetLastError();
//创建套接字
//UDP
socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
//TCP
socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
//关闭套接字
closesocket(sock);
//端口号格式化
htons(12345);
//绑定IP地址
bind(sock, (SOCKADDR*)&service, sizeof(service));
//接收消息
//UDP
recvfrom(sock, recvBuf, recvBufLen, 0, (SOCKADDR*)&addrClient, &addrSize);
//TCP
recv(sockClient, recvBuf, recvBufLen, 0);
//发送消息
//UDP
sendto(sock, sendBuf, sizeof(sendBuf), 0, (SOCKADDR*)&addrClient, addrSize);
//TCP
send(sockClient, sendBuf, sizeof(sendBuf), 0);
//监听
listen(socklisten, 10);
//接收连接
accept(socklisten, (sockaddr*)&addClient, &nAddClientSize);
//发送连接
connect(sock, (SOCKADDR*)&addserver, sizeof(addserver));
//IP字符串转u_long
inet_addr("192.168.244.1");
//long转IP字符串string
inet_ntoa(addrClient.sin_addr);
//有限广播权限
setsockopt(sock, SOL_SOCKET, SO_BROADCAST, (char*)&bval, sizeof(bval));
//将套接字设为非阻塞
err=ioctlsocket(sock,FIONBIO,&iMode);
//获取缓冲区大小
//接收缓冲区
getsockopt(sock, SOL_SOCKET, SO_RCVBUF, (char*)&nRecvBufSize, &bufsize);
//发送缓冲区
getsockopt(sock, SOL_SOCKET, SO_SNDBUF, (char*)&nSendBufSize, &bufsize);
//关闭Nagle算法
setsockopt(sock,IPPROTO_TCP,TCP_NODELAY,(char*)&value);
//不包含头文件使用其他文件的类方式：加声明
class INetmediator;
//按字节复制
memcpy(pack, recvbuf, nrecvNum);
//获取主机名字
gethostname(rq.szName,_DEF_NAME_SIZE);
//取地址前四个字节的数据
int nType=*(int*)buf;
//通过名字获取IP地址列表
gethostbyname(hostName);
//打开文件资源管理器，将选择的文件信息放入file
GetOpenFileNameA(&file);//file:OPENFILENAMEA 结构体
//打开文件资源管理器，选择一个路径来保存文件
BOOL flag = GetSaveFileNameA(&file);
//获取系统时间
GetLocalTime(&time);//time：SYSTEMTIME类型
//将光标移到文件末尾
fseek(pFile,0,SEEK_END);
//将光标移到文件开头
fseek(pFile, 0, SEEK_SET);
//获取文件大小：把光标移到末尾才能计算文件大小
rq.szFileSize=_ftelli64(pFile);//64为操作系统_ftelli64，32位_ftell
//将数据写入数组
sprintf(str,"nihao");
//vs改变程序入口
#pragma comment("linker","实际入口函数的名字");
//mysql查询
list<string> resultList;
char sqlBuf[1024] = "";
sprintf(sqlBuf, "select id,password from t_user where tel = %s;", rq->tel);
if (!m_sql.SelectMysql(sqlBuf, 2, resultList)) {
	cout << "selectMysql error:" << sqlBuf << endl;
	return;
}
```



## qt

```c++
/*
.pro
加载库
LIBS += -lWs2_32
使用网络相关函数
QT += network
包含
INCLUDEPATH += ./net
INCLUDEPATH += ./mediator
*/

/*
信号和槽的绑定位置：槽类中new信号类的后面
*/

//显示窗口
//区别：
//show函数是调出窗口，即在窗口关闭之前都不会执行第二次（最小化时窗口还是存在的，所以再次调用show函数窗口不会显示）
//showNormal函数是显示窗口，调用时不管窗口是何种状态，都会将窗口显示到屏幕上。
m_mainWnd->show();
chat->showNormal();
//隐藏窗口
m_mainWnd->hide();
//输出函数名
qDebug()<<__func__;
//弹出提示框
#include<QMessageBox>
QMessageBox::about(this,"提示","开始");
//询问提示框
if(QMessageBox::question(this,"提示","是否关闭")==QMessageBox::Yes){}
//...
QString("来自[%1]的信息").arg(QHostAddress(htonl(lSendIP)).toString());
//使用信号和槽的前提：继承QObject类
//继承QObject后不允许在头文件中写函数的实现
//连接槽函数
connect(m_thread,SIGNAL(SIG_processbar(int)),this,SLOT(SLOT_processbar(int)));
//发送信号
Q_EMIT SIG_processbar((i++)%101);
//设置标题
setWindowTitle(QString("与[%1]的聊天").arg(ip));
//获取当前时间并转成时分秒格式字符串
QTime::currentTime().toString("hh:mm:ss");
//char*=string char*=QString
//QString转string
toStdString();
//string转char*
c_str();
//忽略事件
event->ignore();
//重写关闭窗口事件
#include<QCloseEvent>
void closeEvent(QCloseEvent* event);
void LoginDialog::closeEvent(QCloseEvent *event)
{
    //1.接收关闭时间
    event->accept();
    
    //2.给kernel发信号，通知kernel窗口关闭
    Q_EMIT SIG_Close();
}


//utf-8和GB2312编码的转换
//QString->GB2312
#include<QTextCodec>
void CKernel::utf8ToGB2312(char *gbBuf, int nlen, QString &utf8)
{
    QTextCodec* gb2312=QTextCodec::codecForName("gb2312");
    QByteArray ba=gb2312->fromUnicode(utf8);
    strcpy_s(gbBuf,nlen,ba.data());
}
//GB2312->QString
QString CKernel::GB2312ToUtf8(char *gbBuf)
{
    QTextCodec* gb2312=QTextCodec::codecForName("gb2312");
    return gb2312->toUnicode(gbBuf);
}


//线程相关
#include <QThread>
//开始线程
m_thread->start();
//判断线程是否还在执行
m_thread->isRunning();
//杀死线程
m_thread->terminate();


//组件：进度条Progress Bar
//设置数值
ui->progressBar->setValue(value);

//组件：Table Widget
//获取行数
ui->tw_friend->rowCount();
//设置行数
ui->tw_friend->setRowCount(ui->tw_friend->rowCount()+1);
//添加行内容
ui->tw_friend->setItem(ui->tw_friend->rowCount()-1,1,item2);
//获取row行0列的数据
ui->tw_friend->item(row,0)->text();

//组件：text edit
//取出文本
QString content=ui->te_chat->toPlainText();
//清空
ui->te_chat->clear();

//组件：text browser
//换行追加
ui->tb_chat->append(QString("haha"));

//QT添加图片
//添加新文件->QT->资源文件
    
//组件：push button
//设置头像(彩色)
#include<QIcon>
ui->pb_icon->setIcon(QIcon(iconPath));
//设置头像（灰色）
#include<QBitmap>
QBitmap bmp;
bmp.load(iconPath);
ui->pb_icon->setIcon(bmp);
//重绘
this->repaint();

//组件：line edit
//获取文本
QString tel=ui->le_tel->text();
//设置文本
ui->le_tel_register->setText("");

//组件：tab widget
//垂直布局的层
#include<QVBoxLayout>
QVBoxLayout* m_layout;
//初始化QVBoxLayout                                   
m_layout=new QVBoxLayout;                          
m_layout->setContentsMargins(0,0,0,0);  //控件上下左右的间距
m_layout->setSpacing(3);        //设置每个控件彼此间的距离     
//设置控件的层                                           
ui->tab_3->setLayout(m_layout);    
//往层上添加控件
m_layout->addWidget(userItem);

//菜单
#include<QMenu>
QMenu* m_menu;
//创建菜单对象，指定父控件，父控件负责子控件的回收
m_menu=new QMenu(this);
//添加菜单项
m_menu->addAction("添加好友");
m_menu->addAction("系统设置");
//绑定菜单项的点击事件和处理函数
connect(m_menu,SIGNAL(triggered(QAction*)),
        this,SLOT(slot_dealMenu(QAction*)));
//显示菜单在x,y坐标处
m_menu->exec(QPoint(p.x(),p.y()));
//获取点击位置的文本
if(action->text()=="添加好友"){}		//QAction* action

//鼠标点击位置
#include<QPoint>
#include<QCursor>
QPoint p=QCursor::pos();
m_menu->exec(QPoint(p.x(),p.y()));		//将点击处的坐标作为左上角（若想让菜单在上方出现，需计算出左上角的坐标（y坐标位点击处-菜单高度））
//获取菜单的绝对高度
QSize size=m_menu->sizeHint();
m_menu->exec(QPoint(p.x(),p.y()-size.height()));

//弹出带输入的窗口
//弹出窗口，输入好友的昵称
QString strName=QInputDialog::getText(m_mainWnd,"添加好友","输入好友名字");
```

```C
//保存成安装包
构建时选择release->编译->在文件夹中找到后缀为release的build文件进入->进入release文件夹->有.exe文件->（会提示说没有.dll文件）
搜索qt进入命令行->输入cd/d +release文件夹的路径（如：cd/d F:\Qt\net\feiQ\build-FeiQ-Desktop_Qt_5_14_2_MinGW_32_bit-Release\release）->回车
输入windeployqt +.exe文件的名字（如：windeployqt FeiQ.exe）->回车
//还是报错...(浅改了下环境变量...)
```

![image-20221227180557394](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20221227180557394.png)

![image-20230203210215070](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20230203210215070.png)







```
列表画法：被弹簧挤压的控件需要设置最小大小（弹簧hui'j）
```

![image-20230201104931804](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20230201104931804.png)![image-20230201105047539](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20230201105047539.png)![image-20230201105241483](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20230201105241483.png)



## cmd



```
查询域名对应的IP地址命令 ：nslookup

计算机中各线程正使用的协议、端口号等 : netstat -ano

查看xxx线程是哪个应用 : tasklist|findstr"xxx"

查看IP : ipconfig

加载QT库文件 ：cd/d +release文件夹的路径（如：cd/d F:\Qt\net\feiQ\build-FeiQ-Desktop_Qt_5_14_2_MinGW_32_bit-Release\release）->windeployqt +.exe文件的名字（如：windeployqt FeiQ.exe）->回车
```



**游戏项目：太空杀、老爹汉堡店0.0**







# 一、多线程和Qt





## 1. 线程的创建与销毁



 [线程创建和销毁.cpp](CPP\线程创建和销毁.cpp)

一、

**进程**：是系统进行**资源分配和调度**的一个独立单位。由程序、数据、进程控制块三部分组成。

**线程**：**CPU调度和执行的基本单元**。一个进程可能含有多个线程。

- 线程之间可以共享进程的资源
- 在线程之间进行切换的效率很快

```C++
//头文件
#include<Windows.h>

//线程函数 IpParameter时一个void*类型，可以转换成我们想要的类型(LP:指针 VOID：void)
DWORD WINAPI ThreadProc01(LPVOID/* void* */ IpParameter) {}

//创建线程函数:返回一个句柄，若创建成功，返回该线程的句柄；若创建失败，返回NULL
//createThread 当函数中有c++运行时库 函数开辟空间，在退出线程时不会回收空间
//createThread和ExitThread时同时使用的，ExitThread函数是系统自动调用的
//_beginthreadex和_endthreadex一起使用，_endthreadex函数是系统自动调用的（头文件process.h）
//_endthreadex里面是先回收c++运行时库函数开辟的空间，然后再调用ExitThread退出线程
HANDLE hand = CreateThread(NULL,//安全级别描述
		0,//线程栈大小，默认1MB
		&ThreadProc01,//线程函数的地址
		(VOID*)80,//线程函数的参数
		0,//创建线程的初始状态（0：创建即执行 CREATE_SUSPENDED:创建即挂起）
		NULL//线程ID
	);
```



二、

**内核对象**：每创建一个线程，操作系统都会在内部为线程分配一个内核对象。是线程和操作系统间的接口，需**手动回收**。

​		**创建线程时**，引用计数器+1，**内核分配了内核对象**，引用计数器又+1；也就是说，我们在创建了一个线程后，引用计数器会**+2**。**当线程执行完毕后（若不能自动运行结束，可手动退出）**，引用计数器-1，**在手动通过句柄释放对象后**，引用计数器又-1；当引用计数器清0时，就完成了空间回收。

​		**退出线程的两步操作：1.让线程执行结束 2. closehandle**

- 在主程序退出后，其他线程会自动结束；若主程序有system("pause");函数，在主程序运行结束后，其他线程还可继续运行，直到有任意键被按下，执行结束。
- 调试时若想调试主函数之外的线程，要在被调试的**线程内部下断点**

```c++
//等待线程执行函数
//第一个参数时句柄，第二个参数是等待多少ms，WAIT_TIMEOUT超时
//等待100ms，若线程还在，就强制杀死线程
WaitForSingleObject(hand, 100) == WAIT_TIMEOUT;

//退出线程函数
//第一个参数是要退出线程的句柄，-1表示异常退出
TerminateThread(hand, -1);

//关闭句柄
CloseHandle(hand);
hand = NULL;

//将线程挂起（挂起计数+1）：一次挂起对应一次恢复（挂起两次需恢复两次才会执行线程）；一次挂起也可恢复多次，对程序没影响。
SuspendThread(hand);

//将挂起的线程恢复（挂起计数-1，计数=0时，立即执行）
ResumeThread(hand);
```





## 2. 线程的状态转换和锁



一、

线程间的状态转换：

![image-20221206091916846](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20221206091916846.png)



二、

线程的生命周期：

![image-20221206091935997](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20221206091935997.png)



三、

 [线程锁.cpp](CPP\线程锁.cpp) 

**并发问题**：由于多个线程同时操作同一块内存空间，可能会造成操作错误或结果不正确。

**线程同步**：通过**协调线程执行的顺序**解决并发问题。

**同步方式**：原子访问、**关键段**、事件、互斥量、条件变量、信号量

- 关键段可以**跨进程**使用吗？  不能，没有提供各线程间的接口

```c++
//关键段的实现
//CRITICAL_SECTION
class mylock {
private:
	CRITICAL_SECTION cs;
public:
	mylock() {
		InitializeCriticalSection(&cs);//初始化关键段
	}
	~mylock() {
		DeleteCriticalSection(&cs);//销毁关键段
	}
	void lock() {
		EnterCriticalSection(&cs);//进入关键段
	}
	void unlock() {
		LeaveCriticalSection(&cs);//离开关键段
	}
}ml;//如果被锁的对象是全局的，则关键段对象也要定义成全局的
```





## 3. 	Qt复习和进度条实现



![image-20221206105315811](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20221206105315811.png)

一、

1. 创建项目：新建 -- application -- x_widgets_x -- ... -- qmake -- baseclass : qweight -- kitselection : WINGW32 -- 完成（注：目录中不能有中文）

2. 在.ui界面拖动组件，右键进度条修改属性，双击按钮改名

![image-20221206104550519](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20221206104550519.png)![image-20221206104622493](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20221206104622493.png)

3. 右键按钮，转到槽，跳转到槽函数（如果要改组件的名字，要在生成槽函数之前改；否则槽函数将失效，需把槽函数和头文件中的槽函数声明一起删掉，重新添加）

```c++
//cpp文件中的槽函数
void PROWidget::on_start_clicked(){}
void PROWidget::on_pause_clicked(){}
void PROWidget::on_resume_clicked(){}
void PROWidget::on_stop_clicked(){}
```

4. 在槽函数中编写对话框函数，点击运行后结果如下

```c++
#include<QMessageBox>
QMessageBox::about(this,"提示","开始");
QMessageBox::about(this,"提示","暂停");//以下略
```

![image-20221206110515345](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20221206110515345.png)

5. 在开始按钮的槽函数中写入如下代码，控制进度条的数据（由于在类外使用了类的成员，需要把类传进去，将ui成员改成共有属性）

```c++
//该种写法会导致程序进入死循环，不能响应其他操作
int i=0;
while(1){
    ui->progressBar->setValue((i++)%100);
}
//应把上述函数放入到另一个线程中
//工作者线程：不允许直接操控组件（自己定义的线程）
```

6. **正确操作（以开始操作为例，其他操作可在此基础上利用全局函数完成）：**添加一个线程文件：右键项目 -- 添加新文件 -- C++ class -- baseclass : QObject-- 完成（实际应该继承QThread，但选项中没有，可手动在代码中改）

```c++
//修改父类workthread.h
#include <QThread>

class workthread : public QThread
{
    Q_OBJECT
public:
    explicit workthread();

signals:

};

//workthread.cpp
workthread::workthread()
{

}
```

7. 在工作者线程中写入信号和run()函数，当该线程start()时，会自动调用run函数

```c++
//workthread.h
signals:
    void SIG_processbar(int value);
public slots:
    void run();

//workthread.cpp
void workthread::run(){
    int i=0;
    while(1){
        Q_EMIT SIG_processbar((i++)%101);
        msleep(100);
    }
}
```

8. 在用户线程创建一个工作者线程的成员变量，写一个用于接收信号的槽函数，在构造函数中初始化、并连接信号和槽

```c++
//mainweight.h
void SLOT_processbar(int value);
workthread* m_thread;

//mainweight.cpp
//构造函数
m_thread=new workthread;
connect(m_thread,SIGNAL(SIG_processbar(int)),this,SLOT(SLOT_processbar(int)));
//槽函数
void mainWidget::SLOT_processbar(int value){
    ui->progressBar->setValue(value);
}
//开始按钮的槽函数
void mainWidget::on_start_clicked()
{
    m_thread->start();
}
```

9. 回收线程：在用户线程的析构函数中回收线程（terminate）和new出来的对象（delete）

```c++
if(m_thread){
    //执行停止操作
    //关闭线程：不需要closehandle，封装的QThread类会自动完成该操作
    if(m_thread->isRunning()){
        m_thread->terminate();
    }
}
delete m_thread;
exit(0);//退出整个程序
```



二、

用户界面线程：ui

工作者线程：用户感知不到的进程（用来进行大量计算，防止用户界面无响应）





## 4. 静态库和动态库（linux叫共享库）



![image-20221207104613758](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20221207104613758.png)

**一、**

库有两种：**静态库（.a .lib）和动态库（.so .dll）**。所谓静态、动态是指链接。

- 静态库、动态库的区别来自**链接阶段**如何处理库，链接成可执行程序。分别称为静态链接方式（只链接一次）和动态链接方式（每次执行都要进行链接）。



**二、** 

文件：静态库[StaticLib1](..\..\..\..\vsprj\网络\静态库\StaticLib1)   测试静态库[testlib](..\..\..\..\vsprj\网络\静态库\testlib) 

**创建静态库的步骤**：Windows下vs使用lib.exe，将目标文件压缩到一起，并且对其进行编号和索引，以便于查找和检索。

**静态链接库：**

- 编译时期完成的链接
- 程序运行的过程中与库再无关系，移植方便
- 浪费空间和资源



```
vs中静态库的创建：
```

![image-20221207110828880](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20221207110828880.png)

```
在该项目的头文件中写入函数声明，在.cpp文件中实现函数；写完后点击生成--重新生成解决方案（不能运行），在项目文件夹的debug文件夹中就有对应的.lib文件了
```

![image-20221207113630440](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20221207113630440.png)

```
在其他项目中使用该库函数：将.lib文件和对应的头文件都复制到要使用该库的项目文件中
```

![image-20221207113751947](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20221207113751947.png)

```
使用
```

```c++
#include<iostream>
#include"./lib/pch.h"//2
using namespace std;

//使用依赖库：0.拷贝库文件和头文件到当前工程下 1.导入依赖库 2.添加以来头文件 3.调用函数
#pragma comment(lib,"./lib/StaticLib1.lib")//1


int main() {
	cout << add(1, 2);//3
}
```



**三、**

**静态库的缺点：**

1. 空间浪费

2. 静态库对程序的更新、部署和发布也会带来麻烦。如果静态库用 libxxx.lib 更新了，所有使用它的应用程序都需要重新编译、发布给用户（对于玩家来说，只是一个很小的改动，却导致整个程序重新下载，全量更新）。



**四、**

 [Dll1](..\..\..\..\vsprj\网络\动态库\Dll1) 

 [testdll](..\..\..\..\vsprj\网络\动态库\testdll) 

动态库：动态库在内存中只存在一份拷贝，避免了静态库浪费空间的问题。

```
vs创建动态库
```

![image-20221207120502704](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20221207120502704.png)

```c++
//在要给别的项目用的函数前面加_declspec(dllexport)，没加的函数别人用不了
_declspec(dllexport) int add(int a, int b);
int sub(int a, int b);
```

```
在其他项目中使用该库函数：将.lib文件（索引）和.dll文件（实现）和对应的头文件都复制到要使用该库的项目文件中；将.dll文件复制到和要使用该库的项目的.exe文件同一目录下。
```

![image-20221207121527912](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20221207121527912.png)![image-20221207121556974](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20221207121556974.png)

![image-20221207121624517](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20221207121624517.png)

```
实现
```

```c++
#include<iostream>
#include"dll/framework.h"
using namespace std;

#pragma comment(lib,"./dll/Dll1.lib")

int main() {
	cout << add(1, 2) << endl;
	//cout << sub(2, 1); erroer:无法解析的外部符号
}
```

```
库的修改：在库文件中修改好代码--重新生成解决方案--用新的.dll文件替换和.exe文件同目录的.dll文件--不用重新编译，直接点击.exe文件，其使用的就是修改后的库文件
```



静态lib，直接链接到exe中

- 优缺点：如果lib发生修改，要重新生成exe并且exe较大

动态dll lib(引入库)

- 动态库的使用：动态库引入库添加到项目包含头文件
- 运行时需要动态库DLL文件，要放在exe同级的目录下面，或者添加到环境变量
- 优点：dll exe运行加载，要修改dll，不用重新编译exe，只需要修改dll，方便更新升级
- exe没有那么大
- 缺点：运行时要加载，一定要有这个文件，并且需要时间





# 二、网络基础知识



## 1. 网络基本模型

- 协议（protocol）：网络计算机的终端间要想正确的传输信息和数据，必须再数据传输的顺序，数据格式和内容等方面，有一个约定或规则，这种约定或规则，称之为协议。（**json**）

- IP地址：是指互联网协议地址，又译为网际协议地址。

- 端口（port）：可以认为是设备与外界通讯交流的出口。端口可分为虚拟端口和物理端口，其中虚拟端口指计算机内部或交换机路由器内的端口，不可见。

- 交换机：交换机工作再mac层，也称为二层网络设备；交换机根据mac地址表查找mac地址，然后将信号发送到相应的端口。

  > 当mac地址表找不到指定的mac地址怎么办？**arp协议**

- 路由器：是基于ip设计的，俗称三层网络设备；路由器的端口具有mac地址，因此它就能够称为以太网的发送方和接收方；同时还具有ip地址，从这个意义上来说，它和计算机的网卡是一样的。当转发包时，首先路由器端口会接收发给自己的以太网包，然后路由表查询转发目标，再由相应的端口作为发送方将以太网包发送出去。

- ARP协议

- DNS协议

- **如何创建广域网项目：**写一个客户端，然后写一个服务器，现在当前是这种任意修改ip地址，是私有ip，这种其他机器是找不到的，那么可以在网上租一服务器，他有公有ip，然后就连接那个ip地址。

- 子网划分

- 各种协议：udp tcp ip 帧

- 端口号：

  端口号范围：0-65536；

  知名端口号：0-1023不建议使用；

  动态端口号：1024-5000

  预留端口号：5000-65535

- 网络IO模型，阻塞，非阻塞IO，信号驱动，IO多路复用，异步；阻塞非阻塞同步异步的区别

**epoll是同步模型**

- tcp有队头阻塞问题，他是按顺序执行请求的

- http请求 [http.docx](..\其他\http.docx) 

  > **由哪些部分组成**
  >
  > **常用的http方法有哪些**
  >
  > **get方法与post方法的区别**
  >
  > **http请求报文与响应报文格式**
  >
  > **常见的http相应状态码**
  >
  > **http1.0 1.1 2.0**
  >
  > **http 和 https**
  >
  > **quic**
  >
  > **cookie和session有什么区别？**
  >
  > > 1. 由于http协议是无状态的协议，服务端需要记录用户的状态时，就需要用某种机制来识别具体的用户，这个机制就是session，典型的场景比如购物车。
  > >
  > >    当点击下单按钮时，由于http协议无状态，所以并不知道是哪个用户操作的。
  > >
  > >    所以服务器端要为特定的用户创建特定的session，用于表示用户，跟踪用户，才知道购物车里有几本书。
  > >
  > >    session是保存在服务端的，有唯一标识。在服务端保存session的方法很多，如内存、数据库、文件集群的时候也要考虑session的转移，在大型的网站，一般会有专门的session服务器集群，用来保存用户会话，此时session信息都是放在内存的，使用缓存服务器比如memcached之类的来放Session
  > >
  > > 2. 那么服务端如何识别特定的用户？cookie就登场了。
  > >
  > >    每次http请求的时候，客户端都会发送相应的cookie信息到服务端。实际上大多数的应用都是用cookie来实现session跟踪的，第一次创建session的时候，服务端会在http协议中告诉客户端，需要在cookie里面记录一个sessionID，以后每次请求都把这个会话ID发送到服务端，就知道是谁了。
  > >
  > >    **如果客户端的浏览器禁用了cookie怎么办？**
  > >
  > >    一般在这种情况下，会使用一种叫做URL重写的技术来进行会话跟踪，即每次HTTP交互，URL后面都会被附加上一个诸如sid=xxxx这样的参数，服务端据此来识别用户。
  > >
  > > 3. cookie话可以用在一些方便用户的场景下。如：登陆过一个网站，下一次不想再次输入帐号了，怎么办？这个信息可以写道cookie里面，访问网站的时候，网站页面的脚本可以读取这个信息，就自动帮你把用户名给填了，能够方便用户。
  > >
  > > 4. 总结：
  > >
  > >    1. sessiom是在服务端保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中。
  > >    2. cookie是客户端保存用户信息的一种机制，用来记录用户的一些信息，也是实现session的一种方式。
  >
  > **握手**
  >
  > **当键入网址后，到网页显示，期间发生了什么？**小林图解网络

- ftp协议：文件传输协议，tcp族协议，应用层协议

- 网络安全：加密（对称式加密，非对称式加密），解密，https ssl握手，wlan拦截，app异地登录，网络欺诈，恶意攻击

- SQL注入：通过把SQL命令插入到表单提交或请求的字符串中，最终达到欺诈服务器执行恶意的SQL命令。（攻击思路：1. 寻找SQL注入位置 2. 针对不同的服务器和数据库特点进行SQL注入攻击）

  > 例如：登录界面中，可能出现免账号登录
  >
  > 用户名：'or1=1--'（--是注释）
  >
  > 密码：xx
  >
  > 注入进去后，密码部分被注释掉，前面1=1一定为真，就登上去了。

- 攻击类问题解决方法：过滤

- 外挂类问题解决方法：验证

- 分布式和负载均衡：nginx服务器，反向代理的负载均衡；正向代理 反向代理 

- LVS负载均衡-NAT DR TUN

- **怎么保证服务器高可用（24小时不关机）？**使用负载均衡、主从复制









一、

**七层网络模型（ISO/OSI）理想模型**

**应用层：**HTTP（80）、 HTTPS（443）、 FTP（21）、 DNS（53）、 DHCP（68）、 Telent（23）、 sMTP（25）、 SSH（22）。（**网络服务与用户的接口**）

```c++
//HTTP：
最常使用HTTP协议的是浏览器。HTTP协议传输的数据都是未解密的，因此使用该协议传输隐私信息非常不安全。
//HTTPS：
是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比HTTP协议安全。
//FTP：
file transfer protocal文件传输协议，包括FTP服务器和FTP客户端两个部分。其中FTP服务器用来文件，用户可以使用FTP客户端访问位于FTP服务器上的资源。在开发网站的时候，通常使用FTP协议把网页或程序传到Web服务器上。此外，由于FTP传输效率非常高，在网络上传输大的文件时，一般也采用此协议。想要访问FTP服务器，必须要有该FTP服务器授权的账号，也就是用户名和密码。
//DNS：
后面专门讲。
//DHCP：
是一种获取IP地址的服务，因为IP地址是不可以重复的，所以有一个协议是专门用来给设备份分配IP地址的。
```

**表示层：**数据加解密、数据解压缩、图片/视频编解码。（**数据的表示，安全和压缩**）

**会话层**：session会话管理、服务器验证用户登录、断点续传。（**建立，管理，中止会话**）

**传输层：TCP、UDP** 、线程、**端口、socket**。（**定义传输数据的协议端口号，以及流控和差错校验**）

```c++
//TCP:
传输控制协议，提供一种面向连接的、可靠的、基于字节流的传输层通信协议，有流量控制和差错控制，使用TCP协议的应用比如右键的接收与发送、文件传输、远程登陆。需要数据稳定和完整性比较高的场景多使用TCP协议。
//UDP:
用户数据报协议，提供一种无连接的、高效率、低可靠性的数据传输服务，使用UDP协议的比如音视频聊天、在线游戏、工业物联网数据传输等。需要数据时效比较高的场景多使用UDP协议。
//端口：
执行cmd命令，
输入netstat -ano命令，可看到计算机中各线程正使用的协议、端口号等。
输入tasklist|findstr"xxx"，可查看xxx线程是哪个应用（|管道符号：在前面命令的基础上执行后面的命令）
```

![image-20221208110608347](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20221208110608347.png)

```c++
//socket
套接字，是通信的基石，是支持TCP/IP协议的网络通信的基本操作单元，包含进行网络通信必须的五种信息：连接使用的协议、本地主机的IP地址、本地进程的协议端口、远地主机的IP地址、远地进程的协议端口。
```

**网络层（IP数据报）**：防火墙、**IP**、路由器、ARP、SARP。（**进行扩及地址寻址，实现不同网络之间的路径选择**）

```
IP:cmd->ipconfig查看IP
```

![image-20221208111936520](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20221208111936520.png)

**数据链路层（数据帧）：**交换机、网卡（MAC地址：唯一的、不可更改的）。（**建立逻辑连接，进行硬件地址寻址，差错校验**）

**物理层：**光缆、**电缆**。（**建立，维护，断开物理连接**）



二、

![image-20221208112250978](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20221208112250978.png)



三、

TCP/IP网络模型 现实模型

应用层 -- 应用层、表示层、会话层

传输层 -- 传输层

网络层 -- 网络层

物理层 -- 数据链路层、物理层



四、

C/S和B/S的区别

C/S ：Client/Server 客户端/服务器 可使用任何协议

B/S ：Browser/Server 浏览器/服务端 使用HTTP:80 HTTPS:443



五、数据包在传输过程中的变化过程

![image-20221209133351915](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20221209133351915.png)





## -----基于UDP的C/S实现



做小买卖的一天：

S: [UDPserver1.cpp](CPP\UDPserver1.cpp) 

选项目  --- 加载库Ws2_32.lib

故榜首  --- 创建套接字 socket()

摆地摊  --- 绑定IP 192.168.1.2

等人来、做给他吃  --- 接消息 recvfrom() ; 发消息 sendto()

到点回家  --- 关闭套接字 closesocket() ; 卸载库 WSACleanup()



```c++
1.加载库
```

```c++
#include<winsock2.h>
#pragma comment(lib,"Ws2_32.lib")

WORD wVersionRequested;
WSADATA wsaData;
int err;

wVersionRequested = MAKEWORD(2, 2);//2.2版本号
err = WSAStartup(wVersionRequested, &wsaData);
if (err != 0) {//err等于0，说明加载成功
	printf("WSAStartup failed with error:%d\n", err);
}

if (LOBYTE(wsaData.wVersion) != 2 || HIBYTE(wsaData.wVersion) != 2) {//判断版本号是否为2.2
	printf("Could not find a usable version of Winsock.dll\n");
	WSACleanup();//卸载库
    system("pause");
	return 1;
}
```



```
2.创建套接字
```

```c++
SOCKET sock = INVALID_SOCKET;//非法
sock=socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);//三个参数分别代表：ipv4地址 使用udp协议 UDP协议
if (sock == INVALID_SOCKET) {//创建后依然非法
	printf("socket function failed with error=%d\n", WSAGetLastError());//打印错误码（工具->错误查找->输入错误码）
	WSACleanup();//卸载库
	system("pause");
	return 1;
}
else {
	printf("socket function succeeded\n");
}
```



```c++
3.绑定IP地址
```

``````c++
sockaddr_in service;
service.sin_family = AF_INET;//ipv4
service.sin_addr.s_addr = INADDR_ANY;//绑定任意网卡（从任意IP地址传来的数据都能接收到）
service.sin_port = htons(12345);//端口号（htons统一字节序）（接收端和发送端的端口号要相等）
//inet_addr 字符串转换成u_long类型
err = bind(sock, (SOCKADDR*)&service, sizeof(service));//绑定套接字和ip地址
if (err == SOCKET_ERROR) {//若有错误
	printf("bind failed with error %d\n", WSAGetLastError());
	closesocket(sock);
	WSACleanup();
	system("pause");
	return 1;
}
else {
	printf("bind returned success\n");
}
``````



```
4.接收消息
```

```c++
int nRecvNum = 0;//按字节流接收
char recvBuf[1024] = "";//接收的数据
int recvBufLen = 1024;//接收的大小
sockaddr_in addrClient = { 0 };//发送端的IP地址
int addrSize = sizeof(addrClient);
//套接字 接收的数据 接收数据的单位大小 标志位 发送端的IP地址 发送端IP地址的大小
nRecvNum = recvfrom(sock,recvBuf,recvBufLen,0,(SOCKADDR*)&addrClient, &addrSize);
if (nRecvNum > 0) {//接收到了
	//打印接收数据
    cout << "IP:" << inet_ntoa(addrClient.sin_addr) << "say" << recvBuf << endl;
}
else if (nRecvNum == 0) {
	cout << "连接已断开" << endl;
}
else {
	printf("recvfrom failed with error %d\n", WSAGetLastError());
	closesocket(sock);
	WSACleanup();
	system("pause");
	return 1;
}
```



```
5.发送消息
```

```c++
char sendBuf[1024] = "";
gets_s(sendBuf);
//套接字 发送的数据 发送数据的大小 标准位 接收端的IP地址 接收端IP地址的大小
sendto(sock, sendBuf, sizeof(sendBuf), 0, (SOCKADDR*)&addrClient, addrSize);
```



```
6.关闭套接字、卸载库
```

```c++
err = closesocket(sock);
if (err == SOCKET_ERROR) {
	printf("closesocket failed with error%u\n", WSAGetLastError());
}
WSACleanup();
std::system("pause");
return 0;
```



C: [UDPclient1.cpp](CPP\UDPclient1.cpp) 

1. 加载库
2. 创建套接字
3. 发消息、收消息
4. 关闭套接字、卸载库



```
加载库和创建套接字和服务器端一样，关闭操作也一样（没有绑定IP地址操作）
```

```c++
//发送消息 接收消息

//定义服务端的IP地址，给其发送消息
sockaddr_in addrservice;
addrservice.sin_family = AF_INET;
addrservice.sin_addr.s_addr = inet_addr("192.168.244.1");//服务器端的IP地址
addrservice.sin_port = htons(12345);//端口号
int addrSize = sizeof(addrservice);

char sendBuf[1024] = "";//发送的数据
int nRecvNum = 0;//按字节流接收
char recvBuf[1024] = "";
int recvBufLen = 1024;

while (1) {
	//3.到店点餐--发送消息
	gets_s(sendBuf);
	sendto(sock, sendBuf, sizeof(sendBuf), 0, (SOCKADDR*)&addrservice, addrSize);

	//4.取餐--接收消息
	nRecvNum = recvfrom(sock, recvBuf, recvBufLen, 0, 0, 0);//自己主动发送的，不需要接收服务器端的IP地址
	if (nRecvNum > 0) {//接收到了
		//打印接收数据
		cout << "服务器: " << recvBuf << endl;
	}
	else if (nRecvNum == 0) {
		cout << "连接已断开" << endl;
		closesocket(sock);
		WSACleanup();
		std::system("pause");
		return 1;
	}
	else {
		printf("recvfrom failed with error %d\n", WSAGetLastError());
		closesocket(sock);
		WSACleanup();
		std::system("pause");
		return 1;
	}
}
```

![image-20221209131035830](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20221209131035830.png)







## 2.  ARP协议和DNS协议



一、

**单播**：一对一发送

**组播：**发给一些群组，群组在发给个人

**广播：**在一个范围内发送，该范围内的所有设备都能接收到



二、

**ARP协议**：地址解析协议（Address revolution protocol），是根据IP地址获取物理地址的一个TCP/IP协议。

**TCP/IP协议**：协议族，里面有很多协议。

```
ARP报头：
硬件类型（2字节 例：1以太网）、上层协议类型（2字节 IP协议：0x0800）、MAC地址（1字节）、上层协议类型的长度（1字节）、操作类型（2字节 1：ARP请求 2：ARP响应）
ARP报文格式：
源MAC（6字节）、源IP（4字节）、目的MAC（6字节）、目的IP（4字节）
```

**ARP协议通过IP地址获取MAC地址的过程**：假设PC1要给PC2发消息，PC1会首先通过中转（WIFI）广播发送一个ARP Requst（ARP请求），其中包含了PC2的IP地址；在该广播范围内的所有主机都会收到该请求报文，收到后会核对报文中的IP地址是否为自己的IP地址：若不是，将报文丢弃；若是，发送一个ARP Reply（ARP响应报文）给PC1，其中包含PC2的IP地址、MAC地址和PC1的IP地址、MAC地址。



三、

**ARP代理：**当发送端广播ARP请求时，本地网络上不会有主机回应（因为IP地址是外网的），此时路由器将会回应该请求，则发送源误认为路由器就是目的主机，会将报文全部转发给他，再由路由器转发报文到外网，则该路由器就被成为ARP代理。

**免费ARP：**在主机开机配置时，会发送一个目的IP地址为自己IP地址的ARP请求报文，该报文称为免费ARP，其作用如下：

1. 让主机确认本地网络上是否有与自己IP地址相同的主机，若有，则会返回一个错误报文。
2. 告诉整个广播域，目前某个IP地址所对应的MAC地址是什么——这个行为就像是在发宣传单，而宣传单是不需要回应的。若接收主机ARP缓存中本身就有发送源主机的IP-MAC对，则会更新，否则，会缓存发送元的IP-MAC对。



四、

**路由数据转发过程：**

![image-20221210093348761](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20221210093348761.png)



五、

**DNS协议（Domain name resolution）：**DNS服务器将好记的域名解析成IP地址

**域名：**www.baidu.com....



六、

**解析过程：**

​		例如要访问www.163.com，首先要知道他的IP地址。

​		网络客户端首先询问本地DNS服务器，看缓存中有没有www.163.com的记录，如果有，直接拿来用；如果没有，联系根服务器d.root-servers.net，询问域名对应的IP地址是多少。

​		根服务器会继续查找管理www.163.com的域服务器，该域名是由.com区域管理，将.com的服务器地址发给本地服务器。

​		询问.com域服务器，.com域服务器将163.com域服务器的地址发给本地服务器。

​		163.com域服务器经查询得知www.163.com域名对应的IP地址为1.1.1.1，将该IP地址发送给本地服务器。

​		本地服务器将该域名和对应的IP地址写入缓存，以便查找。然后将IP地址发送给客户端。



七、

- 查询域名对应的IP地址命令：nslookup

![image-20221210100744046](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20221210100744046.png)





## 3. 子网划分



一、

**IP地址分类：**

A类：1.0.0.0-127.255.255.255（0000 0001）  作用：大量主机、公网

B类：128.0.0.0-191.255.255.255（1000 0000） 作用：国际大公司、政府

C类：192.0.0.0-223.255.255.255（1100 0000） 作用：小公司、校园网、科研单位

D类：224.0.0.0-239.255.255.255（1110 0000） 作用：组播

E类：240.0.0.0-255.255.255.255（1111 0000） 作用：保留

**私网：**

A类：0.0.0.0-0.255.255.255 保留 

​		   127.0.0.0-127.255.255.255 系统回环测试

​		   10.0.0.0-10.255.255.255 政府预留

B类：127.16.0.0-127.31.255.255

C类：192.168.0.0-192.168.255.25



二、

**子网掩码：**又叫网络掩码、地址掩码、自网络遮罩，就是把子网络遮起来了，不让外界窥探到。

**主机号：**子网掩码为0的那些位

​		**例：**

```
IPv4 ：192.168.3.100（11000000 10101000 00000011 01100100）

子网掩码（默认）：255.255.255.0 （11111111 11111111 11111111 00000000）

二者按位与运算后：192.168.3.0 （11000000 10101000 00000011 00000000）

即该主机的网络地址（对外的IP地址）：网络号为192.168.3 、主机号为0（00000000）、真正主机号为100
```

**A类地址的默认子网掩码：**255.0.0.0

**B类地址的默认子网掩码：**255.255.0.0

**C类地址的默认子网掩码：**255.255.255.0



三、

**网关：**又称网间连接器、协议转换器。网间连接器就是**连接两个子网之间的设备或软件**；网关都是具有路由功能的IP地址，就是说网关必须要有路由功能，**默认的主机号都是0**（1？），这样的才是网关。比如说网络A的网关IP地址就应该是192.18.1.0，网络B的网关地址就应该是192.168.2.0。

![image-20221210104448346](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20221210104448346.png)



四、

**广播地址（直接广播地址）：**用于向网络中的**所有设备**进行广播。具有正常的网络部分号，而**主机号部分全为1**的IP地址成为广播地址。**发送广播地址数据，会将数据发送给该子网内的所有主机。**

- **可以给自己局域网的发，也可以给别的局域网发**

​		**例：**

```
上图网络A的网关是：192.18.1.0  广播地址是：192.18.1.255
当有主机IP地址192.18.1.255发送数据时，处于网络A中的所有主机都能收到该数据。
```

**有限广播地址**：指的是32位全是1（255.255.255.255）的IP地址，用于本网广播（当前主机所在的局域网）。

- **只能给自己所在的局域网发**

​		**例：**

```
当A中的主机给255.255.255.255发送数据时，网络A中的所有主机都能收到。
```



五、

**非默认子网掩码：**在默认子网掩码的基础上，后面0的前半部分变成n个1

**例：**

```
IPv4 ：C类网络地址   192.168.3.100（11000000 10101000 00000011 01100100）
默认子网掩码：255.255.255.0 （11111111 11111111 11111111 00000000）
非默认子网掩码：255.255.255.248（11111111 11111111 11111111 11111000）
二者按位与运算后：192.168.3.96 （11000000 10101000 00000011 01100000）

即该主机的网络地址（对外的IP地址）：网络号为192.168.96 、子网号为01100（位数看子网掩码和默认子网掩码的区别）、主机号为0（000）、真正主机号为4（100）
```



六、

**子网划分常见问题：**

1. **选定的子网掩码将创建多少个子网？**

​		2^x个，其中x是子网掩码借用的主机位数。如：192.168.10.32/28，其中这个28是网络号的意思。我们直到C类IP地址的默认子网掩码为255.255.255.0，C类IP的网络号应该是24位，故其借用了主机位4位来充当网络位。这个IP的实际子网掩码是255.255.255.240，将创建的子网个数就是2^4=16

2. **每个子网可包含多少台主机？**

​		2^y-2台，其中y是没被借用的主机位的位数。-2是因为：主机位全为0的部分是这个子网的网关，全为1的部分是这个子网的广播地址。

3. **有哪些合法的子网？**

​		算出子网的步长（增量）。一个例子是256-192=64，即子网掩码为192时，步长为64.从0开始不断增加，直到到达子网掩码值，中间的结果就是子网，即0、 64 、128、192

4. **每个子网的广播地址是什么？**

​		主机位全为1就是该子网的广播地址。一般我们这样计算：广播地址总是下一个子网前面的数。前面确定了子网为0、 64 、128、 192，例如，子网0的广播地址为63，因为下一个子网为64；子网64的广播地址时127，因为下一个子网为128，以此类推。请记住，最后一个子网的广播地址总是255。

5. **每个子网可包含那些主机地址？**

​		合法的主机地址位于两个子网之间，但全为0和全为1的地址除外。例如，如果子网号（网段号）为64，而广播地址为127，则合法的主机地址范围为65-126，即网关地址和广播地址之间的数字。



**练习题：**

1. 某主机的IP地址时210.33.5.68，子网掩码是255.255.255.128.求网络地址？

![image-20221210120822048](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20221210120822048.png)

2. 某A类网络20.0.0.0的子网掩码为255.224.0.0，请确定可以划分的子网个数，写出每个子网的子网号。

![image-20221210121355416](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20221210121355416.png)

3. 给C类网络211.168.10.0划分5个子网，需要几位网络号，子网掩码是多少，每个子网可容纳多少台主机？

![image-20221210120630857](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20221210120630857.png)

4. 某A类网络10.0.0.3的子网掩码为255.255.0.0；其广播地址是多少？

```c++
A类子网掩码：255.0.0.0
实际子网掩码：255.255.0.0
10.0.255.255
```

5. 在同一网段用什么通信？ 交换机
6. 在不同网段用什么通信？ 路由器





## ----- C/S发送广播数据实现

 [UDPserver2.cpp](CPP\UDPserver2.cpp)   [UDPclient2.cpp](CPP\UDPclient2.cpp) 

```c++
//直接广播地址
//将接收端的IP地址改为广播地址（其他不变）
addrservice.sin_addr.s_addr = inet_addr("192.168.1.255");//直接广播地址
//服务端只收不接 客户端只发不收

//有限广播地址：需要设置权限
//设置权限
BOOL bval = TRUE;
setsockopt(sock, SOL_SOCKET, SO_BROADCAST, (char*)&bval, sizeof(bval));
addrservice.sin_addr.s_addr = inet_addr("255.255.255.255");//有限广播地址
```





## 4. 以太网帧结构和IP协议格式



一、

**以太网帧结构：**

![image-20221211112540172](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20221211112540172.png)

**MTU：**一个网络包的最大长度，以太网中一般为1500字节。

**MSS**：除去IP和TCP头部之后，一个网络包所能容纳的TCP数据的最大长度

**以太网帧结构**=目标mac（6）+源mac（6）+类型（2）+数据（46-1500）+帧校验（4）

**数据（46-1500）MTU**=IP头（20）+TCP头（20+TCP选项）+用户数据MSS

**以太网帧的大小范围**64-1518 

**MSS最大大小**=1500-20（IP头）-20（TCP头）=1460



二、

**IP协议格式：**

![image-20221211115559979](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20221211115559979.png)





## 5. 关于socket的阻塞与非阻塞



一、

**阻塞：**一直等着接收消息

**非阻塞：**一边等着接收消息，一边还能发送消息

- 前面代码中用到的recvfrom就是阻塞的（默认）
- 非阻塞函数：牺牲内存，保证高效



二、

**将recvfrom设为非阻塞函数：**

```c++
u_long iMode =1;//0：阻塞    非0：非阻塞
err=ioctlsocket(sock,FIONBIO,&iMode);//sock设为非阻塞
if(err!=NO_ERROR){
    printf("ioctlsocket failed with erroe %d\n",err);
}
```



三、

**缓冲区**：系统会给运行的进程分配空间，创建一个套接字，系统就会分配两块缓冲区；分别是发送缓冲区和接收缓冲区。 

```c++
//获取两个缓冲区的大小(若一次发送的数据大于64KB，可能会造成丢失)
int nRecvBufSize = 0;
int nSendBufSize = 0;
int bufsize = sizeof(int);
getsockopt(sock, SOL_SOCKET, SO_RCVBUF, (char*)&nRecvBufSize, &bufsize);
getsockopt(sock, SOL_SOCKET, SO_SNDBUF, (char*)&nSendBufSize, &bufsize);
cout << "nRecvBufSize:" << nRecvBufSize << " nSendBufSize:" << nSendBufSize << endl;//65535:64KB
```



四、

**阻塞模式下的 sendto() ：**如果缓冲区没有足够的空间，就等待空间足够大后再把数据放入发送缓冲区。

**非阻塞模式下的sendto() ：**只要有数据要发送，就放入缓冲区，能放多少放多少，放完后立即返回（返回的是实际放入数据的大小）





## 6. UDP相关



一、

**UDP数据报的特点：**

1. UDP数据报，只要数据放入发送缓冲区就直接发送出去，然后从缓冲区中删除。
2. 数据不可拆分，如果只接到了一部分，剩下的也就直接丢弃了。
3. 接收端接收的范围不能少于发送端（报错），但可以大于发送端（无影响）。

```c++
char recvBuf[1024] = "";//接收
char sendBuf[1024] = "";//发送
```



二、

**UDP的特点：**

1. 面向非连接，可以是一对一，也可以是一对多（广播和组播）
2. 通讯方式：数据报文，数据包不可拆分
3. 传输效率高
4. 会丢包，没有校验，可能出现乱序







## -----基于TCP的C/S实现



![image-20221212160723341](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20221212160723341.png)



S： [TCPservice.cpp](CPP\TCPservice.cpp) 

1. 决 定做什么-加载库WSAStartup

2. 雇佣店长-加载套接字socket

3. 找地方-绑定IP bind

4. 搞宣传-监听listen

5. 客人进店-接受连接accept

6. 点单-接收消息recv

7. 上菜-发送消息send

8. 下班（店长、服务员）-关闭套接字closesocket

9. 关门-卸载库WSACleanup



```
1.加载库和UDP相同
2.加载套接字
```

```c++
SOCKET socklisten = INVALID_SOCKET;
socklisten = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);//后面两个参数指的是TCP
//判断错误同UDP
```



```
3.绑定IP和UDP一样
4.监听
```

```c++
err = listen(socklisten, 10);//10:等待连接的最大长度
//判断错误同UDP（err==....）
```



```
5.接受连接
```

```c++
sockaddr_in addClient;
int nAddClientSize = sizeof(addClient);
SOCKET sockClient = SOCKET_ERROR;
//每接收一个主机的连接，都要为其创建一个套接字
sockClient = accept(sockClient, (sockaddr*)&addClient, &nAddClientSize);
if (sockClient == INVALID_SOCKET) {
	printf("accept failed with error %d\n", WSAGetLastError());
	closesocket(socklisten);//关闭两个套接字
	closesocket(sockClient);
	WSACleanup();
	std::system("pause");
	return 1;
}
else {
	printf("accept returned success\n");
}

```



```
6.接收消息
```

```c++
//定义同UDP（不要最后两个参数，发送端的IP地址在接受链接的时候就获得了）
nRecvNum = recv(sockClient, recvBuf, recvBufLen, 0);
//错误判断同UDP（创建了几个套接字就关闭几个）
```



```
7.发送消息
```

```c++
//同
gets_s(sendBuf);
send(sockClient, sendBuf, sizeof(sendBuf), 0);
```



```
8.关闭套接字：同（创建了几个套接字就关闭几个
9.卸载库：同
```



C:  [TCPclient.cpp](CPP\TCPclient.cpp) 

加载库

创建套接字

连接

发送消息 接收消息

关闭套接字 卸载库

```c++
//连接
err=connect(sock,(SOCKADDR*)&addserver,sizeof(addserver));
```





## 7. TCP相关



一、

- 一个应用可能对应很多个端口号，但一个端口号只对应一个应用。

**TCP报文段：**TCP协议头+数据

![image-20221213142115383](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20221213142115383.png)

```
1.一行是32位四个字节，一共五行，TCP报文的大小是：20字节+可变部分

2.
URG：紧急标志位，置为1时：当前包很紧急，需赶紧处理；和紧急指针搭配使用
ACK：和确认好搭配使用，1：当前包是一个确认包
PSH：次紧急
RST：重新连接
SYN：建立连接
FIN：断开连接
```



二、

假设包的大小是20字节，序号从1开始，

**确认应答机制：**
		第一次发送seq(序号)+包的大小：1+20;对方收到后会返回(ack确认号)他们俩的和：21.
		下一次发送21+包的大小：21+20;返回41.
		41+20；61...

**超时重传：**

​		设定一个**超时时间**（假设为2秒），在客户端发送数据包后，若在2秒内**没有收到对方的应答**，则**重新发送上一个数据包。**（有两种情况：1.数据包丢失：重新发送  2.应答数据包丢失：对方第二次收到重复报文，重复的会被丢弃，回复一个确认应答）



三、

**三次握手建立连接：**（四次握手为第三步分两次发）

1. 一开始，客户端和服务端都处于CLOSE状态。先是服务端主动监听某个端口，处于LISTEN阶段。
2. 然后客户端主动发起连接SYN（只包含标志位，数据包大小为1），之后处于SYN-SEND状态。
3. 服务端收到发起的连接，返回SYN，并且ACK客户端的SYN，之后处于SYN-RECV阶段。
4. 客户端收到服务端发送的SYN和ACK后，发送ACK的ACK，之后处于ESTABLISHED状态，因为它一发一收就成功了。
5. 服务端收到ACK的ACK后，处于ESTABLISHED状态，因为它也一发一收了。
   - **为什么是三次握手？**
   - 只有经过三次握手才能确保双方收和发的关系是没有问题的。

![image-20221213150322053](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20221213150322053.png)



四、

**四次挥手断开连接**：

1. 主动方打算关闭连接，此时会发送一个TCP首部FIN标志位被置为1的报文，也即FIN报文，之后主动方进入FIN-WAIT-1状态。
2. 被动方收到该报文后，就向主动方发送ACK应答报文，接着被动方进入CLOSE_WAIT状态。
3. 主动方收到被动方的ACK应答报文后，之后进入FIN_WAIT_2状态。
4. 等待被动方处理完数据后，也想主动方发送FIN报文，之后被动方进入LAST_ACK状态。
5. 主动方收到被动方的FIN报文后，回一个ACK应答报文，之后进入TIME_WAIT状态。
6. 被动方收到了ACK应答报文后，就进入了CLOSED状态，至此被动方已经完全完成连接的关闭。
7. 主动方在经过 2MSL （报文在网络中的最大生存时间，即数据包一去一回的时间）一段时间后，自动进入CLOSED状态，至此主动方也完成连接的关闭。
   - **为什么是四次挥手？**
   - 被动关闭的一方并没有完成接收，不会马上断开，等待完成接收后，提出断开连接，所以回复确认和断开连接分两次，即四次挥手。
   - **为什么TIME_WAIT状态等待2MSL？**
   - MSL是报文最大生存时间，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。2MSL这段时间保证数据包可以一去一回，防止四次挥手的第四次数据包丢失后，无法重传数据包，导致服务器无法正常关闭。

![image-20221213153135897](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20221213153135897.png)





五、

**RTT（Round-Trip Time 往返时延）：**在计算机网络中它是一个重要的性能指标，表示从发送端发送数据开始，到发送端收到来自接收端的确认（接收端收到数据后便立即发送确认），总共经历的时延。

- RTT由三个部分决定：**连理的传播时间、末端系统的处理时间以及路由器的缓存中的排队和处理时间。**



**RTO（Retransmission Timeout 超时重传时间）：**TCP每发送一个报文段，就对此报文段设置一个超时重传计时器。此计时器设置的超时重传时间RTO应当略大于TCP报文段的平均往返时延RTT，一般可取RTO=2RTT。

- 但是，也可以根据具体情况人为调整RTO的值，例如可以设置此超时重传时间RTO=90秒。**当超过了规定的超时重传时间还未收到对此报文段的预期确认信息，则必须重新传输此TCP报文段。**





### TCP流量控制--滑动窗口



一、

**窗口**：TCP是没发送一个数据，都要进行一次确认应答。当上一个数据包收到了应答了，再发送下一个。缺点是效率较低。

**窗口大小：**指无需等待确认应答，而可以继续发送数据的**最大值**。

- **三次握手的时候，会交换窗口大小**。通常窗口的大小是由**接收方的窗口大小来决定**的。发送端发送的数据大小**不能超过接收方的窗口大小**，否则接收方就无法正常接收到数据。

<img src="C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20221214191612490.png" alt="image-20221214191612490" style="zoom:50%;" />

![image-20221214195821072](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20221214195821072.png)





二、

**流量控制：**所谓流量控制，主要是接收方传递信息给发送方，使其不要发送数据太快，是一种**端到端的控制**。主要的方式就是**返回的ACK中会包含自己的接收窗口的大小，并且利用大小来控制发送方的数据发送。**

![image-20221214201934979](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20221214201934979.png)



三、

**粘包问题：**TCP是数据流传输，是一种没有边界的，可以合并的传输数据方式。合并就要能拆开，拆不开就是粘包（在缓冲区里粘的）。

**解决方法：先发数据长度，然后再发数据包**（或 结束标志、定长数据包、采用tcp短连接，即连连接一次就断开）

![image-20221214204257087](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20221214204257087.png)



四、

**心跳机制：**

1. **应用场景：**在**长连接**下，有可能很长一段时间都没有数据往来。理论上说，这个连接时一直保持连接的，但是实际情况中，如果中间节点出现什么故障是难以知道的。更要命的是，有的节点（防火墙）会自动把一定时间之内没有数据交互的连接给断掉。在这个时候，就需要心跳包了，用于维持长连接，保活。

2. **心跳机制：**就是每隔几分钟发送一个固定信息给服务端，服务端收到后回复一个固定信息。如果服务端几分钟内没有收到客户端信息则视为客户端断开。

3. **心跳包的发送，通常有两种技术：**

（1）应用层自己实现的心跳包

（2）使用SO_KEEPALIVE 套接字选项



五、

**Nagle算法：**就是为了尽可能发送大块数据，避免网络中充斥着许多小数据块。

**Nagle算法的规则：**

1. 如果包长度达到MSS（最大报文段长度），则允许发送；
2. 如果该包含由FIN，则允许发送；
3. 设置了TCP_NODELAY选项，则允许发送；
4. 未设置TCP_CORK选项时，如哦所有发出去的小数据包（包长度小于MSS）均被确认，则允许发送；
5. 上述条件都未满足，单发生了超时（一般为200ms），则立即发送。

**Nagle算法默认是打开的，如果对于一些需要小数据包交换的场景的程序，比如，telnet或ssh这样的交互性比较强的程序，则需要关闭Nagle算法。**

**关闭Nagle算法的方法：**

```c++
int value=1;
setsockopt(sock,IPPROTO_TCP,TCP_NODELAY,(char*)&value)
```

**使用nagle算法，算法的思路是延时处理，满足以下条件中的一条才可以发送数据：**

1. 没有已发送未确认报文时，立即发送数据。
2. 存在未确认报文时，直到 没有已发送未确认奥文 或 数据长度达到MSS大小 时，再发送数据。

### **TCP拥塞控制**

一、

**拥塞控制：**

​		网络中的链路容量和交换节点中的缓存和处理机都有着工作的极限，**当网络的需求超过他们的工作极限时，就出现了拥塞**。在网络出现拥堵时，如果继续发送大量数据包，可能会导致数据包时延、丢失等，这时TCP就会**重新传输数据**，但是一重传就会导致网络的负担更重，于是会导致更大的延迟以及更多的丢包，这个情况就会进入**恶性循环**被不断地放大。

![image-20221216202857010](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20221216202857010.png)



二、

**四种拥塞控制算法：**

1. **慢开始**：发送端维持一个叫做拥塞窗口（cwnd）的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。当发送放让自己的发送窗口等于拥塞窗口，另外考虑到接收方的接收能力，发送窗口可能小于拥塞窗口。

   ```
   慢开始（拥塞避免）算法的思路就是，不要一开始就发生大量的数据，先探测一下网络的拥塞程度，也就是说由小到大逐渐增加拥塞窗口的大小。
   
   为了防止cwnd增长过大引起网络拥塞，还需设置一个慢开始门限ssthresh状态变量。ssthresh的用法如下：
   当cwnd<ssthresh时，使用慢开始算法。
   当cwnd>ssthresh时，改用拥塞控制算法。
   当cwnd=ssthresh时，慢开始算法与拥塞控制算法任意。
   
   拥塞控制算法让拥塞窗口缓慢增长，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd+1，而不是加倍。这样拥塞窗口按线性规律缓慢增长。
   ```

   ![image-20221216205331902](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20221216205331902.png)

   

2. **拥塞控制**：让拥塞窗口缓慢增长，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd+1，而不是加倍。这样拥塞窗口按线性规律缓慢增长。

![image-20221216205352450](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20221216205352450.png)



3. **快重传：**

![image-20221216210226625](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20221216210226625.png)



4. **快恢复：**

![image-20221216210247208](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20221216210247208.png)





### 总结



TCP协议：面向连接的，可靠的，基于字节流的传输方式。

```
面向连接指发送数据之前必须在双端建立连接，建立连接使用“三次握手”。

可靠传输：seq和ack

基于字节流的传输：粘包问题
解决方案：1.先包大小，再数据；2.加结束标志；3.固定包大小；4.短连接
```

为什么TCP是可靠的？

```
1.三次握手和四次挥手
2.重传和确认机制
3.合理的分段
4.校验重新排序
5.滑动窗口--流量控制
6.拥塞窗口--4种拥塞控制算法
```

TCP可以发送广播吗？

```
TCP是一对一传输的，理论上是不能发送广播的。
*可以使用多线程发送
```

TCP和UDP的区别？

![image-20221216211650808](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20221216211650808.png)



**服务器性能测试：**

**tcp最大连接数**

> 写一个服务器，创建循环，不断连接这个服务器；最大数：linux1021（1024-1，可以修改最大文件个数）。

**压力测试并发性能**

> 写很多个服务端，给服务端发请求包，看他每秒的读写性能如何。







## -----基于TCP的文件传送



```
//文件大小：int:2G, long long:8G
//服务端只接收不发送，客户端只发送不接收
```

 [packDef.h](CPP\packDef.h) 

```c++
//相关宏
#pragma once
#include<memory>

//发送文件

//协议头
#define _DEF_PROTOCAL_BASE (1000)
//文件信息请求
#define _DEF_PROTOCAL_FILE_INFO_RQ (_DEF_PROTOCAL_BASE+1)
//文件块
#define _DEF_PROTOCAL__FILE_BLOCK_RQ (_DEF_PROTOCAL_BASE+2)

#define _DEF_MAX_FILE_PATH (512)
#define _DEF_FILE_CONTENT_SIZE (8*1024)

//协议结构体
//文件信息请求：协议头、文件名、文件大小、文件的唯一表示id
struct STRU_FILE_INFO_RQ {
	STRU_FILE_INFO_RQ():nType(_DEF_PROTOCAL_FILE_INFO_RQ),szFileSize(0){
		memset(szFileId, 0, _DEF_MAX_FILE_PATH);
		memset(szFileName, 0, _DEF_MAX_FILE_PATH);
	}
	int nType;
	char szFileId[_DEF_MAX_FILE_PATH];
	char szFileName[_DEF_MAX_FILE_PATH];
	long long szFileSize;//int:2G, long long:8G
};

//文件块:协议头、文件块、块大小、文件的唯一表示ID
struct STRU_FILE_BLOCK_RQ {
	STRU_FILE_BLOCK_RQ() :nType(_DEF_PROTOCAL__FILE_BLOCK_RQ), nBlockSize(0) {
		memset(szFileId, 0, _DEF_MAX_FILE_PATH);
		memset(szFileContent, 0, _DEF_FILE_CONTENT_SIZE);
	}
	int nType;
	char szFileId[_DEF_MAX_FILE_PATH];
	char szFileContent[_DEF_FILE_CONTENT_SIZE];
	int nBlockSize;
};


//文件信息：文件标志id、文件名、文件路径、当前位置、总大小、文件指针
struct FileIfo {
	FileIfo() :szFileSize(0), nPos(0), pFile(NULL){
		memset(szFileId, 0, _DEF_MAX_FILE_PATH);
		memset(szFileName, 0, _DEF_MAX_FILE_PATH);
		memset(szFilePath, 0, _DEF_MAX_FILE_PATH);
	}
	char szFilePath[_DEF_MAX_FILE_PATH];
	char szFileId[_DEF_MAX_FILE_PATH];
	char szFileName[_DEF_MAX_FILE_PATH];
	long long szFileSize;//文件总大小
	long long nPos;//文件在什么位置
	FILE* pFile;//文件指针
};
```

 [TCPFileclient.cpp](CPP\TCPFileclient.cpp) 

```c++
//1.读取文件信息
//打开文件管理器
//使用多字节字符集
char FILE_PATH[1024] = "";
OPENFILENAMEA file = { 0 };
file.lStructSize = sizeof(file);
file.lpstrFilter = ("所有文件(*.*)\0*.*\0文本(*.txt)\0*.txt\0");//过滤器
file.lpstrFile = FILE_PATH;//保存文件完整路径的空间
file.nMaxFile = sizeof(FILE_PATH) / sizeof(*FILE_PATH);//空间可以写入的字符数
file.Flags = OFN_EXPLORER | OFN_FILEMUSTEXIST | OFN_PATHMUSTEXIST;
BOOL flag = GetOpenFileNameA(&file);
if (FALSE == flag) {
	return;
}
cout << file.lpstrFile << endl;//输出结果：文件完整路径
```

```c++
//2.发送文件信息请求
STRU_FILE_INFO_RQ rq;
string name = getFileName(file.lpstrFile);
strcpy_s(rq.szFileName, _DEF_MAX_FILE_PATH,name.c_str());
cout << rq.szFileName << endl;

//获取系统时间
SYSTEMTIME time;
GetLocalTime(&time);
sprintf(rq.szFileId, "%s_%02d_%02d_%02d_%02d", 
	rq.szFileName, time.wHour, time.wMinute, time.wSecond, time.wMilliseconds);
cout << rq.szFileId << endl;

//获取文件大小
FILE* pFile = NULL;
fopen_s(&pFile, file.lpstrFile, "rb");
fseek(pFile,0,SEEK_END);//将光标移到文件末尾
rq.szFileSize=_ftelli64(pFile);//64为操作系统_ftelli64，32位_ftell
fseek(pFile, 0, SEEK_SET);//将光标移到文件开头
cout << rq.szFileSize << endl;

senddATA(sock, (char*)&rq, sizeof(rq));
```

```C++
//3.发送文件块
STRU_FILE_BLOCK_RQ blockRq;
long long nPos = 0;
int nReadLen = 0;
while (1) {
	nReadLen = fread(blockRq.szFileContent, 1, _DEF_FILE_CONTENT_SIZE, pFile);
	blockRq.nBlockSize = nReadLen;
	strcpy(blockRq.szFileId, rq.szFileId);
	senddATA(sock, (char*)&blockRq, sizeof(blockRq));
	nPos += nReadLen;
	if (nPos>=rq.szFileSize|| nReadLen< _DEF_FILE_CONTENT_SIZE) {//触发退出条件
		fclose(pFile);
		break;
	}
	Sleep(1);
}
```

```c++
//发送文件函数
void senddATA(SOCKET sock, char* buf, int nLen) {
	//先发包大小（防止粘包）
	send(sock, (char*)&nLen, sizeof(int), 0);
	//再发包内容
	send(sock, (char*)buf, nLen, 0);
}
```

 [TCPFileservice.cpp](CPP\TCPFileservice.cpp) 

```c++
//为防止粘包，先接受包大小，再接收包数据
//6.先接收包大小
nRecvNum = recv(sockClient, (char*)&nPackSize, sizeof(int), 0);
if (nRecvNum > 0) {
	//再接收包内容
	nRecvNum = recv(sockClient, recvBuf, nPackSize, 0);
	if (nRecvNum > 0) {//接收到了
		//打印接收数据
		//cout << "IP:" << inet_ntoa(addClient.sin_addr) << "say:" << recvBuf << endl;
		//处理接收数据
		DealData(sockClient, recvBuf, nPackSize);
	}
}
```

```c++
//处理接收数据函数
void DealData(SOCKET sock, char* buf, int nLen) {
	//取出协议头
	int nType = *(int*)buf;
	switch (nType) {
	case _DEF_PROTOCAL_FILE_INFO_RQ:
		DealFileInfoRq(sock, buf, nLen);
		break;
	case _DEF_PROTOCAL__FILE_BLOCK_RQ:
		DealFileBlockRq(sock, buf, nLen);
		break;
	default:break;
	}
}
```

```c++
//处理文件信息
void DealFileInfoRq(SOCKET sock, char* buf, int nLen) {
	//1.拆包
	STRU_FILE_INFO_RQ* rq = (STRU_FILE_INFO_RQ*)buf;
	//2.弹出文件浏览窗口，选择保存文件的路径
	char FILE_PATH[1024] = "";
	OPENFILENAMEA file = { 0 };
	file.lStructSize = sizeof(file);
	file.lpstrFilter = ("所有文件(*.*)\0*.*\0");//过滤器
	file.lpstrFile = FILE_PATH;//保存文件完整路径的空间
	file.nMaxFile = sizeof(FILE_PATH) / sizeof(*FILE_PATH);//空间可以写入的字符数
	file.Flags = OFN_EXPLORER;
	strcpy_s(file.lpstrFile, 1024, rq->szFileName);//相对.exe同级
	BOOL flag = GetSaveFileNameA(&file);
	if (FALSE == flag) {
		//用户没有给保存路径，就给一个默认的保存路径
		strcpy_s(file.lpstrFile, 1024, rq->szFileName);//相对.exe同级
	}
	//3.保存filelfo，为接收文件块做准备
	FileIfo* info=new FileIfo;
	info->szFileSize = rq->szFileSize;
	info->nPos = 0;
	strcpy_s(info->szFileId, rq->szFileId);
	strcpy_s(info->szFileName, rq->szFileName);
	strcpy_s(info->szFilePath, file.lpstrFile);

	fopen_s(&info->pFile, info->szFilePath, "wb");

	cout << info->szFileId << endl;
	cout << info->szFileName << endl;
	cout << info->szFilePath << endl;
	cout << info->szFileSize << endl;

	//4.filelfo保存在map中
	if (m_mapIdToFileInfo.count(info->szFileId) <= 0) {
		m_mapIdToFileInfo[info->szFileId] = info;
	}
}
```

```c++
//处理文件块
void DealFileBlockRq(SOCKET sock, char* buf, int nLen) {
	//1.拆包
	STRU_FILE_BLOCK_RQ* rq = (STRU_FILE_BLOCK_RQ*)buf;
	//2.根据文件ID取出文件信息
	if (m_mapIdToFileInfo.count(rq->szFileId) <= 0) {
		return;
	}
	FileIfo* info = m_mapIdToFileInfo[rq->szFileId];
	int nRes = fwrite(rq->szFileContent, 1, rq->nBlockSize, info->pFile);
	info->nPos += nRes;
	cout << info->nPos << endl;
	//3.文件写完
	if (info->nPos >= info->szFileSize) {
		//关闭文件句柄
		fclose(info->pFile);
		//map中节点删除，回收空间
		m_mapIdToFileInfo.erase(info->szFileId);
		delete info;
		info = NULL;
	}
}
```











## 项目--飞Q

![image-20221216212655288](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20221216212655288.png)

![image-20221225101614799](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20221225101614799.png)



- 在同一个项目内include其他文件夹时不用写文件夹名的方法：

  ![image-20221220155735322](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20221220155735322.png)

```c
//正常
#include"mediator/INetMediator.h"
//项目->属性->vc++目录->包含目录编辑->写相对路径
#include"INetMediator.h"
```

![image-20221220160113301](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20221220160113301.png)



 [main.cpp](..\..\..\..\vsprj\网络\项目--非q\FeiQ\FeiQ\main.cpp) 

 [net](..\..\..\..\vsprj\网络\项目--非q\FeiQ\FeiQ\net) 

 [mediator](..\..\..\..\vsprj\网络\项目--非q\FeiQ\FeiQ\mediator) 



- **将vs的项目移到qt**

```c
//移动
在qt新建项目->右键在explorer中显示->将vs项目的文件夹（.cpp .h）拷贝到qt项目中->右键添加现有文件->将头文件和源文件都添加进来

//问题：qt中采用utf-8编码，所以vs拷贝过来的代码中的注释会变成乱码
解决方法：在文件夹中，将拷贝过来的文件全部采用utf-8编码格式另存一遍

//qt中设置设置包含目录（注：SOURCES源文件和HEADERS头文件中不能有重复文件，否则会报重定义）
在左侧打开.pro文件->写入如下代码
INCLUDEPATH += ./net
INCLUDEPATH += ./mediator

//加载库：qt加载库不使用vs的pragma comment
在左侧打开.pro文件->写入如下代码
LIBS += -lWs2_32
```

```c++
//1.获取主机名字                                                   
char hostName[100]="";                                       
if(SOCKET_ERROR!=gethostname(hostName,100)){                 
    //2.通过主机名字获取IP地址列表                                       
    int i=0;                                                 
    set<long>setIp;                                          
    struct hostent* remoteHost=gethostbyname(hostName);      
    while(remoteHost->h_addr_list[i]!=0){                    
        setIp.insert(*(u_long*)remoteHost->h_addr_list[i++]);
    }                                                        
    return setIp;                                            
}else{                                                       
    return set<long>();                                      
}                                                            
```



**总结**

![network_2_12_FeiQ项目总结](F:\笔记\Typora\my\网络\CPP\network_2_12_FeiQ项目总结.png)









# 三、数据库





## 1、 数据库介绍



一、什么是数据库？

​		**数据库**是“按照数据结构来组织、存储和管理数据的仓库”。是一个**长期存储在计算机内的、有组织的、可共享的、统一管理的大量数据的集合。**



二、数据库的由来？

​		规范化的本地存储

​		加密

​		共享



三、数据库的分类

**关系型数据库**：就是**二维表**，典型代表mysql 、oracle  、SQL Server

**非关系型数据库**：也叫NoSql，是**一维映射**key-value，典型代表redis、MongoDB



```
类型：
//字符串
//数据库中最多申请8000字节的字符空间
char(int)：固定长度
varchar(int)：随实际数据长度分配单元，一个字符占一个字节
nchar(int):随实际数据长度分配单元，一个字符占两个字节（unicode编码）
```





## --workbenck创建



![image-20221216224106369](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20221216224106369.png)

![image-20221216223951754](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20221216223951754.png)

**新建数据库：**

![image-20221216225054324](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20221216225054324.png)

![image-20221216225722005](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20221216225722005.png)

```
PK:主键	NN：不允许为空	UQ：唯一索引	B：二进制	UN：无符号数据类型
ZF：补齐小数点后的0		AI：自增长		G：表达式
```

![image-20221216231039656](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20221216231039656.png)





## --用户管理



![image-20221216231416064](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20221216231416064.png)



**创建新用户：**

![image-20221217143601947](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20221217143601947.png)



**设置权限：**

![image-20221217143918694](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20221217143918694.png)



**创建一个用户名为wsy的连接：**

![image-20221217144215897](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20221217144215897.png)



**使用user2连接，当对标的内容进行更改时，会报错；因为wsy这个用户只有查找权限。**

![image-20221217144420313](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20221217144420313.png)



**图标介绍：**

![image-20221217145002154](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20221217145002154.png)



- **若在root里面把用户删除了，在进入该用户的连接时，会一直让输入密码。可直接删除连接。**



## --sql语句1

![image-20221217145458760](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20221217145458760.png)



```mysql
#xxx（#号开头的为注释）
```

**临时授权：**

```mysql
#临时授权：grant 权限名 on 表名 to 用户名;
#此时wsy用户可以在myfirst1216数据库的test表中更新数据
grant update on myfirst1216.test to wsy;

#取消临时授权：revoke 权限名 on 表名 from 用户名;
revoke update on myfirst1216.test from wsy;
```

**命名规则：**

```mysql
#命名规则：数据库不区分大小写，一般都使用小写；最好不要使用特殊字符
#表名：t_xxx
#列名：f_xxx
```

**设置默认数据库：**

```mysql
#设置默认数据库：use 表名
use myfirst1216;
```

**创建表：**创建好后要在数据库哪里刷新一下refresh all

```mysql
#创建数据表：
#create table 表名(
#列名 类型 约束,
#列名 类型 约束,
#列名 类型 约束,
#...);

#建表约束：
#1、主键约束primary key :值唯一，不允许重复，一个表中只能有一列是主键（可以没有主键）
#2、唯一unique：值唯一，不允许重复，但是可以为空
#3、默认值default
#4、非空not null
#5、自增auto increment
#6、外键foreign key
#7、check校验（mysql无效）

create table studentInfo(
number int primary key,
name varchar(45) unique,
sex enum('男','女'),
age int default 18);



#mysql数据库一个表最多能存五百万行数据
#拷贝表：
#1.拷贝表的结构，但是没有数据
create table 表1 like 表2;
#2.拷贝表的数据，但是不会有主键和索引
create table 表1 as(select * from 表2);
#3.又有表结构，又有表数据
create table 表1 like 表2;
insert into 表1 select * from 表2;
```

- **假如项目中，需要的记录超过500万，比如用户信息表，需要一亿该怎么办？**

- > 水平分表，比如分为30个表，每个用户id%30，确定要存在哪个表中

- **随着业务增长，现在至少两亿用户，但之前的分表是30个表，此时该怎么办？**

- > 数据迁移，比如从30分表变为80分表，将原来各个表中的id通过%80确定目标数据表，拷贝数据到新表，可以通过拷贝数据表的方式拷贝。**一致性hash（能做到一部分拷贝，一部分不拷贝；在分布式中用于动态添加和删除节点）**完美解决问题。



**删除表：**

```mysql
#删除数据表drop table 表名;
drop table studentinfo;
```

**修改表**：

```mysql
#修改表 alter table 表名;
#增加一列 alter table 表名 add column 列名 类型 约束;
alter table studentinfo add column school int;
#修改列属性 alter table 表名 modify 列名 类型 约束;
alter table studentinfo modify school varchar(45);
#删除列alter table 表名 drop 列名;
alter table studentinfo drop school;
```



**查询数据：**

````mysql
#查询语句 select 列名(*代表所有列) from 表名;
select * from studentinfo;
select name from studentinfo;
#给列起临时名字
select name 名字, age 年龄 from studentinfo;
````

**插入数据：**

```mysql
#插入数据 insert into 表名 values(值);插入所有列
#插入数据 insert into 表名(列名1,列名2...) values(值);插入某些列
insert into studentinfo values(4,'哈哈','男',20);#如果主键是自增的，这样插入不成功，要使用字段
insert into studentinfo(number,name,sex) values(5,'嘿嘿','女');
```

**修改数据：**

```mysql
#修改数据 update 表名 set 列名=值;(正常使用场景需要加条件)Edit->Preferences->SQL Editor->safe updates(不勾)->重新连接
#查询条件：查询语句 where 条件;
update studentinfo set age=18;
update studentinfo set age=28 where name='张三';
```

**删除数据：**

```mysql
#删除数据 delete from 表名 where 条件;
delete from studentinfo where name='张三';
```

**条件查询：**

```mysql
#条件查询 ：
#1.相等 大于 小于 where 列名=值; where 列名>值; where 列名<值;
select * from studentinfo where age>=18;
#2.不相等 where 列名!=值;(!=只有mysql能用)或者where 列名<>值;
select * from studentinfo where age!=20;
#3.或者 用or连接两个条件
select *from studentinfo where sex='女'or age =20;
#4.并且 用and连接两个条件
select *from studentinfo where sex='女'and age =20;
#5.介于之间 between and
select * from studentinfo where number between 1 and 3;
#6.范围内 in
select * from studentinfo where number in(1,2,3);
#7.不在范围内 not in
select * from studentinfo where number not in(1,2,3);
```

**模糊查询：**

```mysql
#模糊查询 where 列名 like 模糊表达式;
#模糊表达式：
#%：匹配任意0到多个字符 张%（姓张的所有同学）
#_：匹配任意1个字符 张_(姓张的两个字的同学)
select * from studentinfo where name like '哈_';
```





## 2、数据库范式



一、

**什么是范式？**

​		要想设计一个好的关系，必须使关系满足一定的约束条件，此约束已经形成了规范，按照这种规范可以使设计简洁、结构明晰，不会因为插入删除更新数据导致异常。



二、

**常见名词：**

属性 --- 特征 --- 表中的一列 --- 字段

元组：表中的一行叫做一个元组

码：表中唯一确定一个元组的属性。码不止一个，叫这些为候选码

主码：从候选码挑选出来一个主要确定这一行的属性

主属性：只要再任何一个候选码中出现过，这个属性就叫主属性

非主属性：没有在任何一个候选码中出现过



三、

第一范式（1NF）属性不可分

```
属性：姓名 手机号 性别（符合第一范式）
属性：姓名 联系方式 性别（不符合第一范式，联系方式可分为手机号和座机号）
解决方式：不符合范式的属性拆分成多个属性
```

第二范式（2NF）不存在组合关键字中的某些字段决定非关键字段。（组合关键字不可分）

问题：数据冗余，更新异常，插入异常

```
主属性1 主属性2 ，列1 列2 列3 列4 
非主键列全部依赖于主键 ，符合第二范式
非主键列全部依赖于部分主键 ，不符合第二范式
非主键列部分依赖于全部主键 ，不符合第二范式
非主键列部份依赖于部分主键 ，不符合第二范式
解决方式：将一个大表拆分成几个小表

例：选课课表 selectcourse（学号，姓名，年龄，课程名称，成绩，学分）
分析：姓名年龄依赖于学号，学分依赖于课程名称
修改方案：
学生：学号，姓名，年龄
课程：课程名称，学分
选课：学号，课程名称，成绩
```

第三范式（3NF）不存在依赖传递

```
关键字段->非关键字段1->非关键字段2

例：学生关系（学号，姓名，年龄，所在学院，学院地点，学院电话）
分析：所在学院依赖于学号，学院地点依赖于所在学院
修改方案：
学生单独一个表，学院单独一个表
```

BCNF范式：不存在关键字段决定关键字段（相互决定的字段）



四、

第二范式和第三范式的区别：

非主键列全部依赖于主键，符合第二范式，在此基础上，若非主属性中存在传递依赖，则不符合第三范式。







## --sql语句2



**分页查询**

```mysql
#分页查询
#语法：limit a,b;  a是从哪个开始偏移，b是个数（limit是mysql的关键字 sqlserver不支持）
#limit a; #表示从0开始，取a个
#索引从0开始计算
select *from studentinfo limit 2,3;
```

**聚合函数**

```mysql
#聚合函数
#count：查个数
select count(*)from studentinfo;#所有列的行数
select count(name)from studentinfo;#所有列的行数
#sum:求和
select sum(age) from studentinfo where age>18;
#min:求最小值
select min(age)from studentinfo;
#max:求最大值
select max(age)from studentinfo;
#avg:求平均值
select avg(age)from studentinfo;
```

**组合查询**

```mysql
#分组查询
#语法：group by 分组的依据 having 条件;
#按年龄分组，算出每组的总年龄
select sex,sum(age)from studentinfo group by sex;
#显示分组后总年龄大于50的
select sex,sum(age) sum from studentinfo group by sex having sum>50;
#分组排序：order by 排序根据 asc（升序）/desc（降序）;
#如果不写排序规则，就是升序排序
select sex,sum(age) sum from studentinfo group by sex order by sum;
select sex,sum(age) sum from studentinfo group by sex order by sum desc;
```

- where和having的区别：
- where的条件是查询之前就存在的，having的条件是查询以后计算出来的

**联合查询**

```mysql
#联和查询：把查询结果拼到一起
#语法：一次的查询结果 union all 另一次的查询结果;
select count(*)from studentinfo where sex='男'
union all
select count(*)from studentinfo where sex='女';
```

**练习**

```mysql
#练习
#1.查询每门课程被选修的学生数
select C,count(S) from sc group by C;
#2.查询至少选修两门课程的学生学号
select S from sc group by S having count(C)>=2;
#3.求这些学生对应的学生信息
#select查询结果可以作为一列或是一个结果集出现在另一个查询语句中
select *from studentinfo where S in(select S from sc group by S having count(C)>=2);
#4.选秀课程少于2门课的学生信息
select * from studentinfo where S not in(select S from sc group by S having count(C)>=2);
select * from studentinfo where S in(select S from sc group by S having count(C)<2);
#5.查询选修了全部课程的学生信息
select * from studentinfo where S in (select S from sc group by S having count(C)=(select count(C) from course));
#6.查询没有选修全部课程的学生信息
select * from studentinfo where S not in (select S from sc group by S having count(C)=(select count(C) from course));
#7.查询学过“张三”老师课程的同学的信息
select * from studentinfo where S in(
select S from sc where C in (
select C from course where T in(
select T from teacher where name='张三')));
#8.查询没有学过张三老师课程的学生
select * from studentinfo where S not in(
select S from sc where C in (
select C from course where T in(
select T from teacher where name='张三')));
#9.查询每个同学01课程的成绩和个人信息
select *,(select score from sc where C='01' and sc.S=student.S)01课程成绩
from student where S in(
select S from sc where C='01')
#10.查询01课程分数 > 02课程分数的同学的学生信息
#学号和01课程分数 学号和02课程分数 比较出符合条件的学号
#(1)
select *,
(select score from sc where C='01'and sc.S=student.s)01score,
(select score from sc where C='02'and sc.S=student.s)02score
from student having 01score>02score;
#(2)把select查询结果作为一个新的表出现
select * from(
select *,
(select score from sc where C='01'and sc.S=student.s)01score,
(select score from sc where C='02'and sc.S=student.s)02score
from student )newtable where newtable.01score>newtable.02score;
#11.查询同时存在01课程和02课程的学生的信息
#判断非空：is not null
select *,
(select score from sc where C='01'and sc.S=student.s)01score,
(select score from sc where C='02'and sc.S=student.s)02score
from student having 01score is not null and 02score is not null;
```

**视图**

```mysql
#视图：有一个或者多个表到处的临时表，不需要满足范式要求
#视图创建好以后就会长久存在于数据库中，查询语句就可以通过使用视图来代替
#创建视图 create view 视图名 as (select 语句)
create view myview as(
select * from(
select *,
(select score from sc where C='01'and sc.S=student.s)01score,
(select score from sc where C='02'and sc.S=student.s)02score
from student )newtable where newtable.01score>newtable.02score);
#使用视图
select * from myview;
#删除视图
drop view myview;
#视图的优缺点
#优点：减少网络流量，保证sql语句不会有问题，更安全
#缺点：视图并没有提高查询效率
```



## --sql语句3



**多表查询**

```mysql
#多表查询
#内联 表1 inner join 表2 on 连接条件
#查询每名同学的信息、选修的课程和分数
select student.*,C,score from student inner join sc on student.S=sc.S;
#左联 表1 left join 表2 on 连接条件
#以左边表为基础
select student.*,C,score from student left join sc on student.S=sc.S;
#右联 表1 right join 表2 on 连接条件
#以右边表为基础
select student.*,C,score from student right join sc on student.S=sc.S;
#笛卡尔积 select * from 表1,表2 where 表1.属性=表2.属性
select * from student,sc where student.S=sc.S;
#总结
#内联：不含空结果，取的是两个条件的交集
#左联：以左侧的表1为基础，匹配行，如果没有相应的，属性就为空
#右联：以右侧的表2为基础，匹配行，如果没有相应的，属性就为空
#笛卡尔积：先排列组合，再按照条件取交集。写法简单但是效率低，结果与内联一致
```

**练习**

```mysql
#练习
#1.查询成绩高于60分的学生信息
select student.*,C,score from student inner join sc on student.S=sc.S where score>60;
#2.查询每个学生的总成绩以及学生信息
select student.*,sum(score) from student inner join sc on student.S=sc.S group by student.S;
#3.查询总成绩大于200的学生信息
select student.*,sum(score) total from student inner join sc on student.S=sc.S group by student.S having total>200;
#4.查询总成绩最低的学生信息
#有些数据库是支持top语句的
select student.* from student inner join sc on student.S=sc.S group by student.S order by sum(score) limit 0,1;
#select student.*,sum(score) total from student inner join sc on student.S=sc.S group by student.S having total=min(total);
#5.查询学过张三老师授课的学生信息
select student.* from student 
inner join sc on sc.S=student.S 
inner join course on course.C=sc.C
inner join teacher on course.T=teacher.C 
where teacher.name='张三';
```

**去重**

```mysql
#去重:去掉单列重复或者多列组合重复
#语法：select distinct 列名 from 表名;
#单列重复
select distinct S from sc;
#多列组合重复：1,2 1,2算重复（组合起来相等）
select distinct S,C from sc;
```

**函数**

```mysql
#函数：function
#创建函数：create function 函数名(参数1 类型,参数2 类型...)
#返回值：returns 返回值类型
#函数体:
#begin
#	函数内容
#end//
#定义变量：declare 变量名 类型 default 初始值;//定义局部变量
#设置值：set 变量名=值；
#分隔符：重定义结束符（分隔符）delimiter 分隔符

#
set global log_bin_trust_function_creators=TRUE;
#

#定义函数 求和
delimiter //
create function mysum(a int,b int)
returns int
begin
	declare c int default 0;
    set c=a+b;
    return c;
end//
delimiter ;

#调用函数 select 函数名(变量列表...)
select mysum(2,4);

#删除函数
#直接删除 drop function 函数名;
drop function mysum;
#判断是否存在后删除 drop function if exists 函数名;
drop function if exists mysum;
```

**变量**

```mysql
#变量
#局部变量:只能在函数中定义 变量名 类型;
#会话变量 ：@变量名
set @a=mysum(2,4);
#全局变量:也叫系统变量，超级权限root才能操作，一直有效(不建议自己更改或添加)
#查看全局变量
show global variables;
select @@global.performance_schema;
select @@performance_schema;
#查看变量 select 变量名;
select @a;
```

**选择**

```mysql
#选择
#if选择
#if(a>b)then 执行语句;(可以是多条执行语句)
#elseif(a=b) then 执行语句;
#else 执行语句;
#end if;
#例子：定义一个函数，判断传入的值是否大于0
drop function if exists judge;
delimiter //
create function judge(a int)
returns varchar(45)
begin
	declare c varchar(45) default "";
	if(a>0)then set c="大于0";set c="大于02";
    elseif(a=0) then set c="等于0";
    else set c="小于0";
    end if;
    return c;
end//
delimiter ;
select judge(5);
select judge(0);
select judge(-1);

#case选择
#1.
#case 变量 when 值1 then 执行语句;
#		   when 值2 then 执行语句;
#		   when 值3 then 执行语句;
#end case;
drop function if exists judge;
delimiter //
create function judge(a int)
returns varchar(45)
begin
	declare c varchar(45) default '';
	case a when 0 then set c='等于0';
		   when 10 then set c='等于10';
	end case;
    return c;
end//
delimiter ;
select judge(0);
select judge(10);

#2.
#case when 条件1 then 执行语句;
#	  when 条件2 then 执行语句;
#	  when 条件3 then 执行语句;
#end case;
drop function if exists judge;
delimiter //
create function judge(a int)
returns varchar(45)
begin
	declare c varchar(45) default '';
	case when a=0 then set c='等于0!';
		 when a=10 then set c='等于10!';
	end case;
    return c;
end//
delimiter ;
select judge(0);
select judge(10);
```

**循环**

```mysql
#循环
#while循环：
#while 条件
#do
#	多条可执行语句;
#end while;
#例子：计算1+2+3+...+n
drop function if exists mynsum;
delimiter //
create function mynsum(n int)
returns int
begin
	declare c int default 1;
	declare num int default 0;
	while c<=n
    do
		set num=num+c;
         set c=c+1;
	end while;
    return num;
end//
delimiter ;
select mynsum(10);

#其他循环：mysql没有for循环，右repeat和loop循环
```





## 3、存储过程



一、

​		存储过程（Stored Procedure）是在大型数据库系统中，一组为了完成特定功能的SQL语句集，它存储在数据库中，一次编译后永久有效，用户通过指定存储过程的名字并给出参数（如果该存储过程带有参数）来执行它。

- 存储过程时数据库中的一个重要对象。在数据量特别庞大的情况下利用存储过程能达到倍速的效率提升。



二、

优点：

1. 减少网络流量。存储过程直接在服务器端运行，减少了与客户机的交互
2. 增强了代码的重用性和共享性
3. 加快系统运行速度
4. 使用灵活





## --sql语句4



**存储过程**

```mysql
#存储过程 procedure
#创建存储过程 :
#delimiter //
#create procedure 过程名(参数1 类型,参数2 类型...)
#begin
#	执行语句
#	...
#end//
#delimiter ;
#存储过程没有返回值，可以通过参数进行传递，
#参数可以定义为IN|OUT|INOUT三种，不定义的默认是输入参数
delimiter //
create procedure mypro()
begin
	select * from studentinfo;
end//
delimiter ;

#执行存储过程 call 存储过程名字(参数列表);
call mypro();

#删除存储过程 drop procedure 存储过程名字;
drop procedure mypro;
```

**函数和存储过程的区别：**

1. 函数是操作数据的，是在select语句中使用的，函数中不允许有select语句；存储过程中可以有sql语句。
2. 存储过程没有返回值，可以通过in out inout参数返回；函数有返回值



**题**：

```mysql
#1.青蛙爬井，井深10m，白天向上爬5m，夜晚向下滑4m，问多少天爬出井，使用函数实现
set global log_bin_trust_function_creators=TRUE;
drop function if exists frogCrimb;
delimiter //
create function frogCrimb(height int)
returns int
begin
	declare h int default 5;
	declare d int default 1;
    while h<height
	do
#晚上滑4
        set h=h-4;
##第二天
        set d=d+1;
##向上爬5
        set h=h+5;
	end while;
    return d;
end//
delimiter ;
    
select frogCrimb(20);


#2.查询数据量比较大时需要分页，写一个分页的存储过程，查student表。输入参数当前是第几页和每页显示几行
drop procedure if exists limitpro;
delimiter //
create procedure limitpro(page int,count int)
begin
	declare offset int default 0;
    declare rowcount int default 0;
    declare maxPage int default 0;
#查询所有数据个数
    select count(S) into rowcount from studentinfo;
#最大可以显示的页数
	if (rowcount % count = 0) then set maxPage=rowcount/count;
    else set maxPage=floor(rowcount/count)+1;
    end if;
#判断输入页数和最大页数
	if(page<1) then set page=1;
    end if;
    if (page>maxPage) then set page=maxPage;
    end if;
#计算偏移量
    set offset=(page-1)*count;
    select * from studentinfo limit offset,count;
end//
delimiter ;

call limitpro(4,3);
```

**将查询结果写入变量**

````mysql
#将行数写入roecount变量
select count(S) into rowcount from studentinfo;
````

**向下取整函数**

```mysql
#数据库中小数给整数赋值时四舍五入（c语言是舍弃小数）
floor(7/3);
```







## 4、触发器



一、

触发器：是一种特殊的存储过程，当指定事件发生时，系统自动调用。

如何触发：再修改表数据、插入、删除数据时触发

应用场景：如当在学生表中删除一名学生信息时，在选课表中的该名学生也要被删除，此时就要用到触发器。



## --sql语句5



**触发器**

```mysql
#触发器
#创建触发器
#delitimer //
#create trigger  触发器名字
#after/before 操作
#on 表名
#for each row  #影响每一行
#begin
#	执行操作
#end//
#delimiter ;
#删除触发器
#drop trigger if exists 触发器名


#定义删除操作的触发器
drop trigger if exists mydel;
delimiter //
create trigger mydel
after delete
on studentinfo
for each row
begin
	delete from sc where sc.S=old.S;
    #old表示原始数据，一般是删除之前的数据
    #new表示新增加的数据，添加/修改之后的数据
end//
delimiter ;    

#执行删除函数前运行（只本次登录生效）
set sql_safe_updates=0; 
delete from studentinfo where S='2';


#定义插入数据的触发器
drop trigger if exists myinsert;
delimiter //
create trigger myinsert
after insert
on studentinfo
for each row
begin
	insert into sc values(new.S,'01',0);
end//
delimiter ;

insert into studentinfo(S,name) values('20','狗不理');


#定义修改操作的触发器
drop trigger if exists myupdate;
delimiter //
create trigger myupdate
after update
on studentinfo
for each row
begin
	update sc set S=new.S;
end//
delimiter ;

update studentinfo set S='50' where S='20';
```







## 5、事务



一、

什么是事务？

​		数据库事务时作为单个逻辑工作单元执行的一系列sql操作，操作要求要么都执行，要么都不执行。



应用场景：

​		如张三给李四转钱，张三钱数减少，李四钱数增加。这两条语句要么都执行，要么都不执行。



二、

特性：

1. 原子性；事务时最小工作单元，不可再分，要么都执行，要么都不执行。

2. 一致性；数据库的完整性约束不能被破坏。

   > 要分析事务的底层，需要明确mysql所使用的锁的情况
   >
   > 锁是计算机协调多个进程或者是多个线程并发访问某一资源的机制。
   >
   > 数据库争抢资源，访问限制->锁，保证并发访问的一致性和有效性。
   >
   > **mysql涉及的三种锁：**
   >
   > 1. 表级锁：锁表，开销小，加锁快，不会死锁，锁定粒度大，并发效率低，锁冲突概率较高。
   > 2. 行级锁：锁行，开销大，加锁慢，可能死锁，锁粒度小，并发效率高，锁冲突概率较小。
   > 3. 页面锁：粒度介于表锁和行锁，并发一般，开销和速度也是介于表和行的。
   >
   > **不同引擎关于锁的模式：**
   >
   > **MyISAM：**
   >
   > 只有表锁；有两种模式：表共享锁（table read lock），表独占锁（table write lock）；读锁锁定，不会影响其他读的，但是会影响写；写锁，又影响其他写，有影响其他读。
   >
   > MyISAM不支持事务，使用显示的锁定表LOCK-UNLOCK
   >
   > ```mysql
   > LOCK tables orders read local,order_detail read local;#显示表锁
   > select SUM(total) from orders;
   > select SUM(subtotal) from order_detail;
   > UNLOCK tables;
   > #两个表，如果想同一时刻查询查看是否向相等，可以显式使用表锁。
   > ```
   >
   > MyISAM锁的调度：读和写是互斥的，加入一个进程请求MyISAM表的读锁，另一个进程请求同一个MyISAM表的写锁，mysql是怎么处理的？**写优先，即使在等待队列里边读的进程排在前面。写的进程排在后面，也会先去执行写锁。**
   >
   > 
   >
   > **InnoDB：**
   >
   > InnoDB和MyISAM最大的不同：1.支持事务 2.采用行锁
   >
   > 事务日志--重做日志和回滚日志
   >
   > **重做日志：**采用的方式是预写日志方式。也就是写数据之前先写日志。存储的是执行语句。（重写日志缓存和重写日志文件）；
   >
   > 当开始一个事务的时候，会记录该事务日志序列号；
   >
   > 当事务执行时，先往InnoDB引擎日志缓存里插入事务日志（执行语句）。
   >
   > 当事务提交时，必须先将写入磁盘。
   >
   > **回滚日志：**存储的是执行语句存储引擎的日志缓存，存储于重做日志相反的语句。如：重做日志是insert，回滚日志是delete...

3. 隔离性；并行执行的事务是隔离的，保证多个事务互不影响。

4. 持久性；持久保存到本地	事务->提交	数据发生改变时永久的。

   > 数据库的持久性除了文件缓存到本地之外。有一套机制可以恢复数据库。
   >
   > **mysql InnoDB引擎 通过回滚日志，将所有已经完成或存储在磁盘没完成的事务进行回滚，然后redo重做日志里面的全部重新执行一遍，恢复数据。**





## --sql语句6



**事务**

```mysql
#事务
#语法：
#start transaction;
#执行语句1;
#执行语句2;
#...
#commit;		#提交，生效
#rollback;		#回滚，不生效

create table bank
(
name varchar(45),
money int not null
CHECK (money>=0)	#约束，校验，但是mysql不支持
);	

insert into bank values('张三','100');
insert into bank values('李四','100');
select * from bank;

#开启事务
start transaction;
update bank set money=money+50 where name='张三';
update bank set money=money-50 where name='李四';
select * from bank;
#执行上述三条语句后，用其他用户登录数据库后，数据并未更改（临时操作）
commit;
rollback;
```



## 6.索引



一、**什么是索引？**

​		它是一种数据结构，映射结构，根据key找到value；如果不使用索引，mysql要查询就要从第一个开始逐个去查（全表查询）。



**二、为什么要使用索引？**

​		为了缩短查询的时间，就像书本的目录一样。

- 数据量和数据结构有很大的关系
- mysql索引有使用b+树的，有使用hash表的
- 为什么要使用b+树？**hash表占用的内存很大；b+树不用全量加载数据O(logn)**
- 为什么不使用b树？**b+树适合范围查找（数据都在叶子节点，并被链表串起来）**
- hash表**适合多次查询O(1)**



**三、mysql用索引是不是一定就好？优缺点？**

优点：方便查询，缩短查找的时间

缺点：1.创建索引，那么维护索引就需要消耗时间，数据量越多，维护成本越高。

​			2.索引要占空间，会影响表的最大存储量。

​			3.对表中的数据进行增加和删除修改，索引要动态维护，会降低数据维护速度。

优化：1.对于经常更新的表，避免为他建立过多的索引。

​			2.数据量小的表不用创建索引。

​			3.一个列的值可能只是那么集中。并且有大量相同的。比如性别就不需要创建索引了。



**四、索引分类**

单列（普通）索引index

唯一索引（主键索引primary key，唯一索引unique）

多列索引（组合索引 也叫联合索引）

全文索引fultext

空间索引



**五、创建索引**

```mysql
#index(属性名)->单列索引(创建表时添加)
create table s{
	id int primary key,
	name char(20),
	age int,
	email varchar(30),
	index(name)
}
#创建表后添加 
create index name on s1(name);
#删除索引
drop index name on s1;
```



**六、索引和引擎**

mysql常见的引擎：MyISAM InnoDB Memory/heap等

B+树：MyISAM InnoDB

hash表：Memory/heap

- InnoDB存储引擎有一个特殊功能”自适应哈希索引“，当某个索引值被使用的非常频繁时，会在B+树索引之上再创建一个哈希索引，这样就让B+树索引具有哈希索引的一些优点，比如：快速的哈希查找（例如：对网址的索引）



**七、聚簇索引和非聚簇索引**

**聚簇索引**是节点聚合数据，也就是在存节点的位置直接存数据（InnoDb的默认存储结构）

- 如果使用非主键元素进行查找，会发生回表查询（先通过非主键的辅助索引找到主键，再通过主键的聚簇索引找到目标数据）。

**优点：**1.数据访问更快，因为聚簇索引将索引和数据保存在同一B+树中，因此从聚簇索引中获取数据比非聚簇索引更快；

​			2.聚簇索引对于主键的排序查找和范围查找速度非常快。

**缺点：**1.插入速度严重依赖于插入顺序，按照主键的顺序插入时最快的方式，否则将影响性能。

​			2.对于InnoDB表，一般都会定义一个自增的ID列为主键，更新主键的代价很高，因此将会导致被更新的行移动；因此，对于InnoDB表，我们一般定义主键为不可更新。

​			3.二级索引访问需要两次索引查找，第一次找到主键值，第二次根据主键值找到行数据（回表）



**非聚簇索引**是节点存储地址，间接寻址找实际存储的数据（MyISAM的默认存储结构）不需要回表，因为存的是地址，直接去那个地址就能拿到全部数据。

一般情况下**主键**会默认创建聚簇索引或非聚簇索引，且一张表只允许**存在一个**聚簇索引或非聚簇索引。



**八、组合索引的最左前缀原则**

```mysql
#如何触发组合索引-->最左前缀原则
create table t_user(a,b,c,d index(b,c,d));#查询
select* from t_user where b=12 and c=13 and d=14;#就会触发组合索引
#想要出发组合索引，查询语句中必须包含组合索引中的第一个字段，即必须包含b
```

- 如何知道触发的情况？**可以看查询的次数，使用关键字explain**

- ```mysql
  explain select * from t_user where id;
  #会显示10列信息，根据key知道到底用了什么索引
  ```

![image-20230407145433209](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20230407145433209.png)







## 7.其他



**一、数据发生并发问题产生错误的类型：**脏读、不可重复读、幻读

1. 脏读：读取数据时错误的，不能用。两个事务在执行时，事务B读到了事务A未成功提交的数据。

​		产生原因：没加锁

2. 不可重复读：读取的数据两次不一样（不一定算错误）

​		产生原因：读数据没有一致锁定到提交，可以修改

3. 幻读：读取的数据不一致

​		产生原因：通过insert delete改变表，使结果集不一样





**二、数据库隔离等级**：读未提交，读已提交吗，可重复读，串行化

1. **读未提交（read uncommited）**在读数据时不会检查或使用任何锁。

在隔离等级中，可以读取没有提交的数据

- 会发生脏读，相当于没有并发控制



2. **读已提交（read commit）**（大多数的数据库默认的隔离等级：sql server、oracle）

只读取提交的数据并等待其他事务释放排他锁，读数据的共享锁在读操作之后会立即释放。（共享锁在读后释放，排他锁在事务结束后释放）

- 不可重复度，可以解决脏读



3. **可重复读（repeatable read）**（mysql的默认隔离等级）

只读取提交的数据，并等待其他事务释放排他锁。读取数据的共享锁在在事务结束时释放。（共享锁和排他锁都在事务结束后释放）

- 共享锁时行锁
- 可以解决不可重复读，但是不能解决幻读

> 事务一：读a，读b，读a；
>
> 事务二：改写b，改写a；
>
> 可重复读就是死锁；读已提交不会死锁

- mysql的默认隔离等级时可重复读，通过多版本并发控制MVCC

- > 对于快照读，InnoDB使用MVCC解决幻读
  >
  > 对于当前读，InnoDB通过间隙锁（锁一个范围）解决幻读



4. **串行化**：

   可以用来解决幻读问题，强制事务排列执行，不可能发生冲突，解决幻读。

   实质是锁定受影响的数据范围，阻止新数据插入查询所涉及的范围。

![image-20230409125012113](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20230409125012113.png)





**三、杂记**

1. MyISAM InnoDB区别：行锁

   关于InnoDB的使用的行锁：用索引取查数据的时候才会用行锁，锁定key，其他默认的情况使用表锁

2. 页面锁，是特定的引擎使用的，锁定多行

3. 排他锁是在事务提交之后释放





**四、MVCC多版本并发控制**

- 和MVCC对应的是LBCC（基于锁的并发控制）

**MVCC最大优势：**读不加锁，认为读写不冲突，在读多写少的情况下，读写不冲突十分重要，可以极大的增强系统的并发能力。

**思路**：MVCC是一个乐观锁，处理并发的时候，比较乐观的看待并发问题。认为一般情况没有数据冲突，只有在数据修改的时候才会出现冲突，只需要判断先后有没有修改，如果没有修改，不需要管理，如果又修改，就认为又并发的冲突，此次读写失败，尝试下一次读写。

**乐观锁的一种实现方式：**CAS机制（compare and swap）比较然后交换，就是空间没有改写，可以操作，被其他的线程改写过，此次操作失败；进入下一次操作，再继续判断（无锁编程）。





**五、快照读和当前读**

1. 快照读：一致性非锁定读取，使用普通select语句读取，读取快照版本，通过MVCC的ReadView实现（快照读的前提是隔离级别不是串行级别，串行级别下的快照读会退化成当前读）之所以出现快照读的情况，是基于提高并发性能的考虑，再很多情况下，避免了加锁操作，降低了开销。
   - 快照都可能读到的并不一定是数据的最新版本，可能是之前的历史版本。
2. 当前读：像 select lock in share mode(共享锁),select for update;update,insert,delete（排他锁）这些操作都是一种当前读。
   - 为什么叫当前读？
   - 就是它读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁。





**六、MVCC怎么实现**

实现MVCC依靠隐藏列，undo log 以及ReadView来实现。

1. 隐藏列：

   > DB_TRX_ID 记录插入或更新该行，最后一个事务的事务ID，没执行一个事务+1。
   >
   > DB_ROLL_PTR 指向修改该行对应的回滚日志的指针。
   >
   > DB_ROW_ID 单调递增的行ID

2. **undo log**：改动的数据都保存再undo log中，同时里面又保存事务的id，可以用于生成快照读，同样回滚可以实现数据恢复。

3. **Read View**： sql语句执行前都可以得到一个ReadView，它是一个副本，主要用来知道哪些事务可以看到数据，哪些不可以。

![image-20230409130625477](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20230409130625477.png)

- 这个读本中保存的是系统中当前不应该被本事务看到的其他事务id列表

**ReadView的几个重要属性：**

- trx_ids：当前系统活跃（未提交）事务版本号合集
- low_limit_id：创建当前read view时当前系统活跃的事务最大版本号
- up_limit_id：创建当前read view时系统活跃的事务最小版本号
- creator_trx_id：创建当前read view的事务版本号

**read view匹配条件：**

1. 数据事务ID小于up_limit_id，则显示

   数据事务ID小于活跃事务的最小ID，说明该数据是在所有活跃事务开启之前就已经存在的，显示。

2. 数据事务ID大于low_limit_id，则不显示

   数据事务ID大于活跃事务的最大ID，说明该数据是在所有活跃事务开始之后才创建的，不予显示。

3. 数据事务ID大于up_limit_id并且小于low_limit_id

   用数据事务ID于trx_ids集合中的事务ID进行匹配。如果事务ID不存在于活跃ID集合（说明事务已经commit了），或者数据事务ID等于creatoe_trx_id（说明该数据就是当前事务修改的），满足上面条件的，则可以显示。

4. 不满足read view条件的时候，从undo log里面获取

   不满足，从undo log里面获取数据的历史版本，然后回头再来和read view条件匹配，知道找到一条满足条件的历史数据，或者找不到则返回空结果。





**七、MVCC执行过程：**

1. 获取事务版本号
2. 获得read view
3. 查询的数据 与read view事务版本号进行匹配
4. 不符合readview 从undo log 中获取历史版本数据
5. 返回符合规则的数据





**八、InnoDB存储引擎有三种行锁的算法：**

1. record lock :单个行记录上的锁

2. gap lock：间隙锁，锁定索引记录的间隙，确保索引记录的间隙不变（范围锁定）不包含记录本身。

   > 需要条件：事务隔离级别再可重复读及以上
   >
   > 默认的情况下，InnoDB工作再可重复读的隔离级别，这个时候时可以触发间隙锁的。
   >
   > 当我们用范围条件而不是相等条件检索数据，并请求共享锁或排他锁时，InnoDB会对符合条件的已有索引项加锁；对于key，再条件范围内但并不存在的记录叫做间隙，会对这个间隙加锁。
   >
   > where id>100
   >
   > 数据1 2 ... 101加锁的项：101以上加锁，就是间隙锁。

3. next_key lock：行锁和间隙锁组合起来

   > 使用next_key lock避免幻读



**九、MySQL rr解决幻读了吗？**

sql标准中规定，并不能消除幻读，但是mysql innodb是可以的，快照读借助MVCC，当前读借助next_key lock，解决幻读（rr，间隙锁默认开启的）











## vs连接数据库



1. 打开下面的mysql命令行软件，输入status查看mysql信息（通过安装路径找到mysql.h头文件）

![image-20221230194626001](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20221230194626001.png)



2. 在vs项目的包含目录中添加mysql的include文件的路径

![image-20221230195050542](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20221230195050542.png)



3. 在mysql的lib文件夹下，找到libmysql.lib和libmysql.dll；将libmysql.dll拷贝到和.exe文件在同一目录下。将lib文件夹的路径添加到vs项目的库目录中。

   ![image-20221230195620367](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20221230195620367.png)

   

   ![image-20221230195419139](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20221230195419139.png)

   

![image-20221230195759513](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20221230195759513.png)

4. vs使用x64调试器（如果没有：新建平台）



**将CMySql.h和CMySql.cpp导入进项目，主函数包含头文件，即可使用，用法如下：**

 [CMySql.h](CPP\CMySql.h) 

 [CMySql.cpp](CPP\CMySql.cpp) 

 [main.cpp](CPP\main.cpp) 





## 项目--IM



**feiQ 项目**：基于UDP协议，局域网的聊天软件

**QQ / 微信/游戏/抖音/boss都有聊天功能，都可以叫做IM系统：**广域网，基于TCP协议



注册、登录、添加好友、开始聊天、下线

添加功能：特别关注/好友分组/删除好友、文件传输、朋友圈/QQ空间、按照标签推荐好友、语音/视频、打卡功能、漂流瓶/纸飞机、双人/多人对战功能（飞机大战、五子棋、跳一跳）



**广域网通讯软件功能分析：**

1. 注册：

   （1）TCP与服务器连接

   （2）注册信息发送给服务器，校验后写入数据库

2. 登录

   （1）客户端与服务端建立TCP连接：服务器校验用户登录信息

   （2）获取好友列表：服务器查询数据库，把好友信息发给客户端

   （3）通知其他在线好友：服务器通知所有好友某个好友已上线；收到通知的客户端把对应的好友显示变亮。

3. 添加好友

4. 聊天：把数据发给服务器，由服务器转发

   （1）1对1聊天：文字聊天；视频聊天

   （2）群组聊天

5. 发文件

6. 下线

   （1）断开与服务器的TCP连接

   （2）将下线成员在列表中变灰：服务器通知所有在线好友某个好友已下线；收到通知的客户端把对应的好友显示变灰。

7. 远程监控

8. 其他功能



**类图：**

![image-20221230225400867](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20221230225400867.png)

![image-20221230225750101](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20221230225750101.png)



```C
bool TcpSeverNet::SendData(long lSendIP, char* buf, int nlen)
{
	//lSendIP里面装的是SOCKET
	if (send(lSendIP, (char*)&nlen, sizeof(int), 0) <= 0)return false;
	if (send(lSendIP, buf, nlen, 0) <= 0)return false;
}

```



```
数据库表：
用户信息表：自增的用户id，手机号，昵称，密码，头像，签名
好友关系表：A用户的id，B用户的id（Aid Bid,Bid Aid）
```



优化点：

1. 用户昵称没有校验唯一性
2. 重登录限定，删除好友
3. 异常场景处理：来不及发送下线请i去，服务器中的map项没有回收

解决方法：1. 客户端连接的时候，判断map里面如果有id,那就更新对应的socket	

​					2. 增加心跳机制，每隔一段时间，发送一个包确认对方是否在线，如果对方不在线，把socket从map中删除

4. 服务器是在windows平台下，简单的同步阻塞多线程模型，一个看客户端一个接收线程（进程的空间时有限的，线程不能无限制创建。当客户端达到一定数量的时候，程序就会崩溃，因为空间不够用。32位windows，线程0-4G，其中0-2G是应用程序内存空间，2-4G是系统内核空间，进程可用空间是2G，线程栈默认是1M，理论上只能创建2048个线程，2000个用户就要崩溃的了）

解决方案：1. linux下多路复用网络IO模型



扩展点:

单双人对战游戏（飞机大战、五子棋、跳一跳、你画我猜、俄罗斯方块、贪吃蛇对战）、音视频聊天、发文件、设置标签、根据标签推荐好友、漂流瓶/纸飞机



自己写项目：

游戏大厅、视频播放软件、音乐播放软件、网盘、









# 四、linux基础





## 1、命令



### 1、shell常见命令

```c
//解决vi中上下箭头输入字母
sudo apt-get remove vim-common
sudo apt-get install vim
//解决Taglist:Exuberant ctags (http://ctags.sf.net)not found in PATH.Plugin is not loaded.
sudo apt-get install ctags
//vim报错
sudo apt-get install vim-gui-common
//安装tree命令
sudo apt-get install tree
```



**常用快捷键+命令：**

```c++
//清屏:clear 或 Ctrl+l快捷键
//删除光标前一个字：Backspace
//删除光标所在字：Delete 或 Ctrl+b
//将光标移到行首：Ctrl+a 或 Ctrl+Home
//将光标移到行尾：Ctrl+e 或 Ctrl+End
//查看之前执行过的命令：向上箭头（只能查看当前用户执行过的命令）
//查看历史命令：history（只能查看当前用户执行过的命令）
//创建文件夹：mkdir 文件夹名
//查看“帮助文档”，命令参数等：man 命令（man ls）
//结束当前命令：Ctrl+c
//挂起当前命令：Ctrl+z
//解压缩：tar xzvf xxx.tar.gz
```

**shell ：**命令解析器，根据输入的命令执行相应命令

**查看当前系统下有哪些shell：**

```c++
//cat命令：查看文件内容
cat/etc/shells
```

**查看当前系统正在使用的shell:**

```c++
echo $SHELL
```

```c++
//echo:输出内容（SHELL是一个变量）
//输出hello到终端
echo "hello"
```





### 2、目录和文件



- 目录：文件夹

**向文件中输入：**

```c++
//将hello替换到当前路径的a.txt文件里，如果没有该文件，将创建一个后添加插入进去
echo "hello" > a.txt
```

**查看文件夹：**

```c
//白色：普通文件 蓝色：文件夹 绿色：可执行文件 红色：压缩文件
ls

//查看隐藏文件
ls -a
//前面时.的是隐藏文件

//递归显示文件夹及文件夹里面的文件夹
ls -R

//按照树形结构显示文件(如果没有tree命令，可用sudo apt-get-install tree下载)
tree

//打印当前文件的绝对路径
pwd

//查看详细信息
ls -l
//显示的命令信息中，开头是由10个字符构成的字符串

//第一个字符表示文件类型
- ：普通文件
d ：目录（文件夹）
l ：符号链接(相当于快捷键，进入前一个文件相当于进入了后面的)
b ：块设备文件
c ：字符设备文件
s ：socket文件，网络套接字
p ：管道

//后面的9个字符表示文件的访问权限，分为3组，每组3位。
//rwxrw-r-x可记为：0765(0：八进制 、7：4+2+1 、6：4+2 、5：4+1)
//第一组表示文件属主的权限
//第二组表示同组用户的权限
//第三组表示其他用户的权限
r ：读
w ：写
x ：可执行。对于目录，表示进入权限
s ：当文件被执行时，把该文件的UID或6ID赋予执行进程的UID（用户ID）或6ID（组ID）
t ：设置标志位。如果拥有者或文件属主删除。
- ：没有相应位置的权限

//查看某命令在哪个文件夹下
which ls
```

![image-20230101181114431](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20230101181114431.png)

**进入某路径：**

```c
//到根路径
cd/
//到主目录
cd 或 cd~
//到根目录的etc文件
cd / etc
//向上爬一层
cd ..
//向上两层
cd ../..
```

**联想：**

```c
//如果某文件名字太长，没记住怎么拼，可以输入前几个字母后按Tab键（多按几次）；
//如果本路径下只有一个以输入字母开头的文件，会自动补齐后面的字母。
```

**新建文件夹：**

```c
mkdir 文件名
//可以一次创建多个文件
mkdir aa bb cc
//一次创建带子文件夹的文件，需要在结尾加上-p
mkdir dd/ee/ff -p
```

**删除文件/文件夹：**

```c
//只能用来删除文件夹，且文件夹必须为空
rmdir cc
//删除多个文件夹
rmdir aa bb
//删除普通文件
rm a
//删除非空文件夹
rm -r dd
rm -rf dd(没有询问，直接删除)
//删除以a开头的所有文件
rm -rf a*
//删除所有文件
rm -rf *
```

**创建文件：**

```c++
//可以不加后缀
touch a1
//创建多个文件
touch a2 a3 a4
//如果创建了一个同名文件：不会覆盖原本内容，但会改变修改时间
echo "h" > a1
cat a1		//h
touch a1
cat a1		//h
```

**修改文件/文件夹：**

```c
//mv 文件 已存在的文件：覆盖已存在的文件
//mv 文件 已存在的文件夹：移动到文件夹下
//mv 文件 不存在的文件：重命名文件
//mv 文件夹 已存在的文件：不允许，会报错
//mv 文件夹 已存在的文件夹：移动到文件夹下
//mv 文件夹 不存在的文件夹：重命名文件夹


//将a1文件移动到aa文件夹里面
mv a1 aa
//将a2的名字改为ss（如果目标文件夹不存在，会修改前面文件的名字）
mv a2 ss
//将文件夹改名
mv aa ff
//将文件夹移动到其他文件夹下
mv bb cc
```

**复制文件：**

```c
//复制文件：将a1的值复制到b1中，若b1有数据，直接覆盖；若没有b1，创建一个b1，复制数据进去
cp a1 b1
//复制文件夹:将a1文件夹拷贝到cc文件夹中
cp aa cc -r
```

**查看文本：**

```c
//Fn+上下箭头可以翻页
//Fn+左右箭头可以到文本开头和末尾

//分行显示文本信息（回车可看下一行，退出后终端保留文本）：按Ctrl+c或q中止显示
more a.txt
//分行显示文本信息（回车可看下一行,退出后终端不保留文本信息）：同上
less a.txt
//查看前五行
head -5 a.txt
//查看后五行
tail -5 a.txt
```

**编辑文本：**

```c
//进入文本：如果有，直接打开；如果没有，创建后打开
vi a.txt
//输入
按i/o/a
//退出
先按Esc退出编辑模式
//保存并退出
:qw
//不保存退出
:q!
//没有改变文本，直接退出
:q
```

**链接：**有两种，一种是硬链接：建立时，链接文件和被链接文件必须位于同一个文件系统中，并且不能建立指向目录的硬链接。另一种时符号链接：没有硬链接的限制，也叫软链接

```c
//硬链接:ls -l详情页面的第二列是硬链接个数；此时test.cc和a1指向同一个文本，只有当所有指向该文本的文件都被删除后，文本才被删除
ln test.cc a1

//软链接：a1指向了test.cc，若删除test.cc，则a1不可用；若此时test.cc还有一个硬链接，那么文本文件不会被删除。
ln -s test.cc a1
//删除test.cc后，a1不可用。在此基础上，再创建一个test.cc，a1就可用了；但之前的test.cc的硬链接还是指向之前的文本。
```

**计算文件：**

```c
//使用wc命令，若不给文件名，或给的文件名是“-”，则wc指令会从标准输入设备读取数据
//显示bytes数
wc -c或-bytes或-chars 文件名
//显示列数
wc -l或-lines 文件名
//显示字数
wc -w或-words 文件名
//查看本目录下所有文件的行数
wc -l ./*
```

**数据显示格式：**

```c
od -tcx a
//-t指定数据的显示格式，主要参数：
c:ASCII字符或反斜杠序列
d:有符号的十进制数
f:浮点数
o:八进制（系统默认值为02）
u:无符号十进制数
x:十六进制数
```

**查看某个目录的大小：**

```c
//以M为单位
du -hm aa
//以B为单位
du =hb aa
//以K为单位，4K的整数倍
du -hk ./*
```

**查看磁盘使用情况：**

```
df
df -h
```





### 3、文件属性和用户用户组



**帮助文档：**

```c
//q退出
man ls
man cat
```

**查看当前登录用户：**

```
whoami
```

**更改文件目录访问权限：**

```c
//临时提升用户权限至root权限：只该条生效
sudo 命令

/文字设定法
chmod [who] [+|-|=] [mode]文件名
//who
u:表示"用户(user)"，即文件或目录的所有者
g:表示"同组(group)用户"，即与文件属主有相应组ID的所有用户
o:表示"其他(other)用户"，
a:表示"所有(all)用户"，
//。。。。。

//八进制数字法
//为aa文件赋rw-rw-rw-
chmod 666 aa
```

**更改文件目录的用户或组：**

```c
//若想将某一文件的所属住转到root下，需使用sudo
chown
//将a2改到root所属主root用户下
sudo chown root:root a2
//将aa文件夹（及其子目录文件）改到root root
sudo chown root:root aa -R
```





### 4、查找与检索



**文件名查找：**

```c
//在当前路径下（及子目录）查找a2,单引号双引号都行
find . -name 'a2'
//在当前路径查找所有a开头的文件
find . -name 'a*'
//查找.txt文件
find . -name "*.txt"
```

**文件内容检索：**

```c
grep
//可在指定文件中搜索特定内容，并将内容行输出到标准输出；若不指定文件名，则从标准输入获取
-c:只输出匹配行的计数
-i:不区分大小写（只是用于单字符）
-h:查询多文件时不显示文件名
-l:查询多文件时只输出包含匹配字符的文件名
-n:显示匹配行及行号
-s:不显示不存在或五匹配文本的错误信息
-v:显示不包含匹配文本的所有行
-R:连同子目录中所有文件一起查找

//在所有文件中查找"ret"
grep "ret" ./ -R
//获取行数
grep "ret" test.cc -n
//多文件不显示文件名
grep "e" test.cc a.txt -nh
或grep "e" test.cc a.txt -n -h
```





### 5、安装卸载软件



**apt_get**

```c
//更新原服务器列表
studo vi /etc/apt/sources.list
//更新完服务器列表后需要更新下源
sudo apt-get update 更新源
sudo apt-get install package 安装包
sudo apt-get remove package 删除包
sudo apt-cache search package 搜索安装包
sudo apt-cache show package 获取包的相关信息，如说明、大小、版本等
sudo apt-get install package ---reinstall 重新安装包
sudo apt-get -f install 修复安装
sudo apt-get remove package -purge 删除包，包括配置文件等
sudo apt-get buile-dep package 安装相关的编译环境
sudo apt-get upgrade 更新已安装的包
sudo apt-get dist-upgrade 升级系统
sudo apt-cache depends package 了解使用该包依赖哪些包
sudo apt-cache rdepends package 查看改包被哪些包依赖
sudo apt-get source package 下载该包的源代码
sudo apt-get clean && sudo apt-get autoclean 清理无用的包
sudo apt-get check 检查是否有损坏的依赖
```

**deb包安装**

```c
//安装deb软件包命令
sudo dpkg -I XXX.deb
//删除软件包命令
sudo dpkg -r XXX.deb
//连同配置文件一起删除命令
sudo dpkg -r -purge XXX.deb
//查看软件包信息命令
sudo dpkg -info XXX.deb
//查看拷贝详情命令
sudo dpkg -L XXX.deb
//查看系统中易安装软件包信息命令
sudo dpkg -l
//重新配置软件包命令
sudo dpkg -reconfigure xxx
```

**源码安装**

```
1.解压缩源代码包
2.cd dir
3../configure检测文件是否确实，创建Makefile，检测编译环境
4.make编译源码，生成库和可执行程序
5.sudo make install 把库和可执行程序，安装到系统路径下
```





### 6、磁盘管理



**挂载U盘**

```c
//1.检测存储设备名称
sudo fdisk -l
//2.挂载存储设备sdbl到挂载点/mnt目录
sudo mount /dev/sbdl /mnt
//3.访问/mnt
//4.卸载/mnt
sudo umount /mnt
```







### 7、用户管理



**创建用户：**

```c
sudo useradd -s /bin/bash -g colin -d /home/colin -m colin
//新建一个用户pzh，该用户的登录shell是/bin/sh，他属于group用户组，同时属于adm和root用户组，其中group用户组是其主组
sudo useradd -s /bin/sh -g group -G adm,root pzh
//新建用户shi，shell时bin/bash，在home/aaa目录下
sudo useradd -s /bin/bash -d /home/aaa -m aaa
    
//指定新用户登录时shell类型
-s
//指定所属组，该组必须已经存在
-g
//指定附属组，该组必须已经存在
-G
//用户家目录
-d
//用户家目录不存在时，自动创建该目录
-m
```

**设置用户组：**

```
sudo groupadd colin
```

**设置密码：**

```
sudo passwd aaa
```

**切换用户：**

```c
//su+用户名
su aaa
```

**为新增加的用户配置sudo权限：**

```
1.切回之前的用户（wang）
2.cd /etc
3.cd sudoers.d/
4.sudo vi aaa(创建一个和新用户的名字一样的文件)
5.输入  1 aaa ALL=(ALL)ALL （aaa是用户名）
6.保存并退出
```

**切换到root用户：**

```
sudo su
```

**删除用户：**

```
sudo userdel -r aaa
```







###  8、进程管理



**查看当前在线用户：**

```c
who
//不适用任何选项时：
login name 登录用户名
terminal line 使用终端设备
login time 登录系统时间

//更详细
who -uH
```

**监控后台进程：**

```c
ps
    
//常用a u x
-e 显示所有进程
-f 全格式
-h 不显示标题
-l 长格式
-w 宽输出
a 显示终端上的所有进程
r 只显示正在运行的程序
x 显示没有控制终端的进程
u 以用户为主显示进程
    
//标头介绍
USER 用户名
UID 用户ID
PID 进程ID
PPID 父进程的ID
SID 会话ID
%CPU 进程的CPU占用率
%MEM 进程的内存占用率
VSZ 进程所使用的虚存的大小
RSS 进程使用的驻留集大小或者是事迹内存的大小
TTY 与进程关联的终端
STAT 进程的状态：进程状态使用字符表示的
START 进程启动时间和日期
TIME 进程使用的总CPU时间
COMMAND 正在执行的命令行命令
NI 优先级
PRI 进程优先级编号
WCHAN 进程正在睡眠的内核函数名称，该函数的名称是从/root/system.map文件中获得的
FLAGS 与进程相关的数字标识
```

**显示后台作业：**

```c
//显示当前shell下正在运行那些作业
cat
//按下Ctrl+z挂起当前进程(将cat命令挂起)
jobs 查看作业
//+-号代表优先级
```

**后台/挂起作业移到前台运行：**

```c
fg
//进入到挂起作业1的命令
fg 1
```

**挂起进程后台运行：**

```c
bg
//把挂起进程1后台运行
bg 1
```

**进程发送信号：**

```c
kill
//查看信号编号
kill -l
//杀死5414进程:15号信号也可以杀死进程，但挂起状态的进程不处理15号命令
kill -SIGKILL 5414 或 kill -9 5414
```

**查看当前环境变量：**

```c
env
//配置当前用户环境变量
vim /etc/profile
//配置系统环境变量，配置时需要root权限
export PATH=$PATH:新路径
```





### 9、网络管理



**ifconfig**

```c
//查看网卡信息
ifconfig
//关闭网卡
sudo ifconfig ens33 down
//开启网卡ens33
sudo ifconfig ens33 up
//给网卡ens33配置临时IP
sudo ifconfig ens33 IP
```

**ping**

```c
//查看网络上的主机是否在工作
ping [选项] 主机名/IP地址
//选项
-c 数目，在发送指定数目的包后停止
-d 设定SO_DEBUG的选项
-f 大量且快速的送网络封包给一台机器，看他的回应
-I 秒数，设定间隔几秒送一个网络封包给一台机器，预设值是一秒一次
-l 次数，在指定次数内，以最快的方式发送封包到指定机器
-q 不显示任何传送封包的信息，只显示最后的结果
-r 不经由网关而直接发送封包到一台机器，通常是查看本机的网络接口是否有问题
-s 字节数，指定发送的数据字节数，预设值是56，加上8字节的ICMP头，一共是64ICMP数据字节
```

**nslookup**

```c
//查询IP和其对应的域名
nslookup name
```

**figure**

```c
//查询用户的信息
figure [-lmsp] user [user@host...] 
```





### 10、其他命令



**翻页**

```
shift+pageup
shift+pagedown
```

**看手册**

```c
man
//若有同名函数，要在名字前加数字(2 系统函数 3 库函数)
man 2 read
```

**设置指定别名**

```c
//将value字符串起个别名叫name，以后在命令行输入name,shell自动将其解释为value
alias [-p] name=value
alias ls='ls --color=auto'
alias rm='rm -i'
```

**查看当前时间**

```
date
```

**权限掩码**

```c
//文件的默认权限是666 文件夹的默认权限是777
//在创建时，文件/夹的权限是默认权限去除掩码上的权限得出的
umask 查看
umask 0023 修改成0023
```

**创建终端**

```c
//创建终端标签
Ctrl+Shift+t
//切换标签
Alt+标签页（n=1）
Alt+1
//新开终端
Ctrl+Shift+n
```







### 11、关机重启



**关机**

```
poweroff
```

**shutdown**

```c
关机
//参数
-t 设定在切换至不同的runlevel之前，警告和删除二讯号之间的延迟时间
-k 仅送出警告讯息文字，但不是真的要shutdown
-r shutdown之后重新开机
-h shutdown之后关机
-n 不经过init，由shutdown指令本身来做关机动作
-f 重新开机时，跳过fsck指令，不检查档案系统
-F 重新开机时，强迫做fsck检查
-c 将已经正在shutdown的动作取消

//例子
//立刻重新开机
shutdown -r now
//立刻关机
shutndown -h now
//发出警告信息，但不真的关机
shutdown -k now 'hi'
//10:42分关机
shutsown -h 10:42 'hello'
```

**重启**

```
reboot
```

**查看内核版本**

```
uname -a
```

**查看发行版信息**

```
lsb_release -a
```

**查看空闲内存**

```
free -m
```







### 12、VIM



- 文本编辑



**vim基础操作**

```c
//进入插入模式
i 插入光标前一个字符
I 插入行首
a 插入光标后一个字符
A 插入行末
o 向下新开一行，插入行首
O 向上新开一行，插入行首

//进入命令模式
ESC

//移动光标
h 左移
j 下移
k 上移
l 右移
M 光标移动到中间行 
L 光标移动到屏幕最后一行行首
G 移动到指定行，行号 -G
w 向后一次移动一个字
b 向前一次移动一个字
{ 按段移动 上移
} 按段移动 下移
Ctrl+d 向下翻半屏
Ctrl+u 向上翻半屏
Ctrl+f 向下翻一屏
Ctrl+b 向上翻一屏
gg 光标移动到文件开头
G 光标移动到文件末尾

//删除命令
x 删除光标后一个字符
X 删除光标前一个字符
dd 删除光标所在行（n dd 删除n行）
D 删除光标后本行所有内容，包含光标所在字符
d0 删除光标前本行所有内容，不包含光标所在字符 
dw 删除光标开始位置的字，包含光标所在字符

//撤销命令
u 一步一步撤销 
U 一次性撤销当前所作的所有操作 
Ctrl+r 反撤销

//重复命令
. 重复上一步操作的命令

//复制粘贴
yy 复制当前行（n yy复制n行）
p 在光标所在位置向下新开辟一行，粘贴

//查找命令
str查找
n 下一个
N 上一个

//查看man page
光标移动到函数上，Shift+k
光标移动到函数上，3 Shift+k 查看第三章(库函数？)的manpage

//查看宏定义
-d 必须包含宏所在的头文件

//代码排版
gg=G 代码自动缩进排版
    
//代码界面查看函数声明
数字+K
```

**vim分屏操作**

```c
//分屏操作
:sp 上下分屏，后可跟文件名
:vsp 左右分屏，后可跟文件名
:Ctrl+w+w 在多个窗口切换

//退出
:q
:qw
:q!
```







### 13、gcc



- 文本编译

**gcc**

```c
-c 查看gcc版本号（gcc -v）
-I 指定头文件目录（I和头文件之间没有空格）
-c 只编译，生成.o文件，不进行链接
-g 包含调试信息 -On n=0~3 编译优化，n越大优化的越多
-Wall 提示更多警告信息
-D 编译时定义宏（D和宏之间没有空格）
-E 生成预处理文件
-M 生成.c文件与头文件依赖关系以用于makefile，包括系统库的头文件
-MM 生成.c文件与头文件依赖关系以用于makefile，不包括系统库的头文件

//编译myc.c myfun.c和include路径下的头文件，生成可执行文件myapp
gcc myc.c myfun.c -I./include -o myapp
//执行可执行文件
./myapp
//生成包含调试信息的可执行文件
gcc myc.c myfun.c -I./include -g -o myapp
//执行包含调试信息的可执行文件
gdb myapp
输入list可查看代码（liat 1从第1行开始；list 5以第5行为中间行；每次10行）
输入start开始调试（断点在main函数的第一行）
输入n调试下一行代码（逐步）
输入s可调试下一个代码（逐过程：若该步位函数，进入到函数体内部）
输入continue继续
输入run开始调试（手动下断点，若没有下，直接结束）
输入quit退出调试模式
```

**toolchain**

```
ar 打包生成静态库
as 汇编器
ld 链接器
nm 查看目标文件中的符号
objcopy 将原目标文件中的内容复制到新的目标文件中，可以通过不同的命令选项调整目标文件的格式
objdump 用于生成反汇编文件
ranlib 为静态库文件创建索引，相当于ar命令的s选项
readelf 姐夫ELP文件头（ELF二进制文件：linux下的可执行程序）
```







### 14、编译原理



1. 预处理：包括头文件展开、宏替换等#开头的命令的执行，生成.i文件（由预处理器完成），参数-E

2. 编译：预处理后的文件编译成汇编语言，生成.s文件（由编译器完成），参数-S

3. 汇编：将汇编语言变成机器语言，生成.o文件（Windows下是.obj）文件（由汇编器完成），参数-c

4. 链接：将目标语言、静态库和动态库生成可执行文件（由链接器完成），参数-o（如果不加上面的选项，默认生成可执行文件。如果加-E/S/c生成对应的文件。-o用来指明目标文件名，如果不加-o，生成a.out）

```
gcc myc.c -Iinclude -E -o myc.i
gcc myc.c -Iinclude -S -o myc.s
gcc myc.c -Iinclude -c
```





### 15、gdb调试



```c
//生成包含调试信息的可执行文件
gcc myc.c myfun.c -I./include -g -o myapp
//执行包含调试信息的可执行文件
gdb myapp
输入list可查看代码（liat 1从第1行开始；list 5以第5行为中间行；每次10行）
输入start开始调试（断点在main函数的第一行）
输入n调试下一行代码（逐步）
输入s可调试下一个代码（逐过程：若该步位函数，进入到函数体内部）
输入continue继续
输入run开始调试（手动下断点，若没有下，直接结束）
输入quit退出调试模式
//调试过程中获取某变量值
print *(&a) 或 p a
//每次调试直接显示想知道的变量值(监视)
display a
display b
//结束监视 数字为序号
undisplay 1
undisplay 2
//下断点
break+行号 或 b+行号
//查看所有断点信息
info breakpoints
//执行自定义断点
run
//执行下一个断点
continue
//禁用断点 数字为序号（只是禁用，没有删除）
disable 1
//恢复断点
enable 1
```





### 16、静态库、动态库





​		首先使用-fPIC或-fpic创建目标文件(.o)，-fPIC和-fpic表示位置无关代码（相对路径），然后使用以下格式创建库：

```c
gcc -fPIC -c a.c
gcc -fPIC -c b.c

//生成add.c des.c mul.c sub.c的.o文件
gcc -fpic -c add.c des.c mul.c sub.c


//生成静态库：将上面生成的四个.o文件放到一个静态库libmath.a里面
ar rcs libmath.a add.o des.o mul.o sub.o
//查看库内符号
nm libmath.a
//编译main.c、头文件和静态库，生成可执行文件myapp
gcc main.c -Iinclude libmath.a -o myapp


//每个共享库有三个文件名:real name,sonmame,linker name
//real name:真正的库文件名，包含完整的共享库版本号
//soname:符号链接的名字，只包含共享库的主版本号
//linker name:只在编译链接时使用
//生成动态库gcc -share -Wl,-soname,your_soname -o library_name file_list library_list
gcc -shared -Wl -o libmyab.so a.o b.o
gcc -shared -Wl,-soname,libmyab.so.1 -o libmyab.so.1.0.1 *.o
//共享库加载
//1.修改/etc/ld.so.conf，添加共享库路径
sudo vi /etc/ld.so.conf（写入/home/wang/play/testlib/lib）
//2.更新查找共享库的路径
sudo ldconfig -v
//3.测试程序是否可找到共享库
ldd a.out
//编译main.c、头文件和动态库，生成可执行文件myapp1
gcc main.c -Iinclude libmyab.so.1 -o myapp1
//修改库内容：先修改库文件的代码，然后用-fpic重新生成.o文件，然后重新生成动态库（用新生成的动态库替换之前的动态库，即移到同一目录下），然后直接执行可执行程序即可（不需要再次编译）
```







### 17、makefile文件



- 是一个项目管理工具，没有ui，只有命令行
- 创建文件：文件名必须是makefile或Makefile



**makefile的优势：**

1. 可以便捷的编译管理代码（不用每次都写复杂的编译命令）
2. 大大节省编译时间，减少编译成本
3. 重用性极强，可以重复使用管理编译不同的工程



**makefile三要素：**

1. 目标：完成编译，生成可执行文件。
2. 依赖：大多数情况下，为源码文件或资源文件
3. 命令：使用gcc命令完成工程编译，生成最终目标



**格式:**(第一行的#version...是注释)

目标：依赖

​	命令

![image-20230107114944966](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20230107114944966.png)



**执行makefile:**

```
make
```



**改变应用程序入口（不在main函数进）**

```c
gcc -nostartfiles -e 实际入口函数的名字 main.c -o main
//从main.c文件的myentry函数开始执行
gcc -nostartfiles -e myentry main.c -o main

//vs改变程序入口
#pragma comment("linker","实际入口函数的名字");
```

![image-20230107115801227](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20230107115801227.png)



**makefile变量**

变量：经典的键值对形式，等号左边是key，右边是value

1. 用户自定义变量：

   无需指定类型，默认存储字符串；变量名可以由大小写字母、数字、下划线构成，一般用大写字母定义，不允许以数字开头。

   查看变量：$(变量名)

   ![image-20230107125458813](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20230107125458813.png)

2. 特殊变量（makefile内置变量）

​	$@ 表示目标名，随着目标的变化而变化

​	$^ 获取当前目标的所有依赖项

​	$< 依赖项中的第一项

![image-20230107125904827](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20230107125904827.png)





**内置函数：**

1. wildcard文件名处理函数：遍历文件夹，获取到所有.c后缀的文件名并返回，可以赋值给变量

```bash
src=$(wildcard *.c)
```

2. patsubst字符串处理函数：可以对字符串进行处理和替换，替换后返回结果，可以赋值给变量

```bash
//将所有的.c文件替换成.o文件，结果返回给dfile
dfile=$(patsubst %.c,%.o,$(arc))
```

3. 内建语法：

```bash
%.o:%.c
	gcc ...
```

![image-20230107131029346](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20230107131029346.png)





**创建变量**

```bash
TARGET=app#用于存储目标名
CC=gcc#编译器版本
INCLUDE_PATH=../include#存储头文件路径
INSTALL_PATH=/user/bin/#安装位置
LIBRARY_PATH=../lib#存放静态库或共享库位置
CFLAGS=-I$(INCLUDE_PATH) -c -g Wall#编译选项
RM=sudo rm -rf
//$(RM) $(INSTALL_PATH)$(TARGET):sudo rm -rf /user/bin/app
COPY=sudo cp
```

![image-20230107132506208](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20230107132506208.png)





**功能目标：**

```c
clean:
	rm -rf *.o $(TARGRT)
output:
	echo "hello"
install:
	sudo cp $(TARGRT) $(INSTALL_PATH)
distclean:
	sudo rm $(INSTALL_PATH)$(TARGET) -rf
	
//使用：(如果文件中只有一个功能目标，直接make即可)
make clean
make output
...
```







## 2、文件IO



![image-20230108122419600](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20230108122419600.png)

![network_4_05_Linux文件_open函数](F:\笔记\Typora\my\网络\CPP\network_4_05_Linux文件_open函数.png)



### **main函数的参数**

```c
int main(int argc,char* argv[]){}
argc:参数个数
argv:存储参数

//终端
./app aaa
执行app可执行文件，将aaa作为参数传进去，文件名为第一个参数（argv[0]），aaa为第二个参数（argv[1]）,个数argc=2
```



### **文件描述符**

```c
//一个进程默认打开三个文件描述符，新打开的文件返回文件描述符表中未使用的最小文件描述符
STDIN_FILENO 0 //标准输入
STDOUT_FILENO 1 //标准输出
STDERR_FILENO 2 //标准出错
```



### **打开关闭文件函数open/close**

```c
//打开文件
//查看open函数详情：终端->man 2 open
#include<sys/types.h>
#include<sys/stat.h>
#include<fcntl.h>

int open(const char* pathname,int flags);
int open(const char* pathname,int flags,mode_t mode);
//flags:
//必选项：以下三个常数中必须指定一个，且仅允许指定一个。
O_RDONLY 只读打开 
O_WRONLY 只写打开 
O_RDWR 可读可写打开
//可选项：
O_APPEND 表示追加。如果文件已有内容，这次打开文件所写的数据附加到文件的末尾而不覆盖原来的内容。 
O_CREAT 若此文件不存在则创建它。使用此选项时需要提供第三个参数mode，表示该文件的访问权限。 
O_EXCL 如果同时指定了O_CREAT，并且文件已存在，则出错返回。 
O_TRUNC 如果文件已存在，并且以只写或可读可写方式打开，则将其长度截断（Trun-cate）为0字节。 
O_NONBLOCK 对于设备文件，以O_NONBLOCK方式打开可以做非阻塞I/O（Nonblock I/ O），非阻塞I/O在下一节详细讲解。

//关闭文件
#include<unistd.h>
int close(int fd);

//实现重定向的功能
例如，首先调用close关闭文件描述符1，然后调用open打开一个常规文件，则一定会返回文件描述符1，这时候标准输出就不再是终端，而是一个常规文件了，再调用printf就不会打印到屏幕上，而是写到这个文件中了。
```

![image-20230108221144115](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20230108221144115.png)





### **读写函数read/write**

```c
//读
//read函数从打开的设备或文件中读取数据
//返回值：成功读取的字节数，出错返回-1
#include<unistd.h>
ssize_t read(int fd,void *buf,size_t count);

//写
//write函数向打开的设备或文件中写数据
//返回值：成功写入的字节数，出错返回-1
#include<unistd.h>
ssize_t write(int fd,void *buf,size_t count);
```

![image-20230108222841805](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20230108222841805.png)





### **错误码**

```c
#include<errno.h>
//错误码
printf("%d",errno);
//错误信息
perror("错误信息");

#include<string.h>
//可将错误信息转换成字符串
printf("%s",strerror(errno));
```

![image-20230109172149679](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20230109172149679.png)

![image-20230109172219820](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20230109172219820.png)





### **阻塞和非阻塞**

```c
阻塞读终端
//STDIN_FILENO为标准输入
从标准输入读取，写入到标准输出
```

![image-20230109174008600](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20230109174008600.png)

```c
非阻塞读终端
//在open一个设备时制定了O_NONBLOCK标志，read/write就不会阻塞。
//以read为例，如果设备暂时没有数据可读，就返回-1，同时设置errno为EWOULDBLOCK或EAGAIN；即并没有发生错误，只是还没有读到数据
//终端目录/dev/tty
```

![image-20230109175727547](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20230109175727547.png)





### **改变已打开文件的属性**

```c
//fcntl
#include<fcntl.h>
#include<unistd.h>
int fcntl(int fd,int cmd);
int fcntl(int fd,int cmd,long arg);
int fcntl(int fd,int cmd,struct flock* lock);
//获取文件属性
int flags = fcntl(STDIN_FILENO,F_GETFL);
//在原属性的基础上加非阻塞标志
flags |= O_NONBLOCK;
//设置文件属性
fcntl(STDIN_FILENO,F_GETFL,flags);
```

![image-20230109181038369](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20230109181038369.png)





### **最大打开文件个数**

```c
//查看当前系统允许打开最大文件个数
cat /proc/sys/fs/file-max
//查看进程最大打开文件个数
ulimit -a
//改变进程最大打开文件个数(当前进程，重启失效)
ulimit -n 4069
//只打开了4066个文件的原因：由三个被占用了：标准输入、输出、出错
```

![image-20230109182906252](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20230109182906252.png)

![image-20230109182930947](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20230109182930947.png)







### 移动当前读写位置

```c
//lseek
//成功：返回新的偏移量，失败：返回1
//偏移量允许超过文件末尾，该种情况下会延长文件，空的部分读出来都是0
#include<sys/types.h>
#include<unistd.h>
off_t lseek(int fd,off_t offset,int whence);

//从头移到尾：返回文件大小
lseek(fd,0,SEEK_END);
//从头向后偏移5个字节
lseek(fd,5,SEEK_SET);
```

![image-20230109185226019](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20230109185226019.png)







## 3、文件系统



文件系统：操作系统用于明确存储设备（磁盘（磁盘一个扇区是512字节）、固态硬盘等）或者是分区上的文件的方法和数据结构。

- 即存储设备上组织文件的方法



文件系统分为三个部分：

1. 文件系统的接口
2. 对对象操作和管理的软件集合
3. 对象及其属性



windows : NTFS

linux : ext4 , ext2

![image-20230110095802160](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20230110095802160.png)





### stat



```c
//获取文件属性
#include <sys/types.h> 
#include <sys/stat.h> 
#include <unistd.h>

//终端 查看文件属性
stat main.c
//若查询文件是软链接，获得的属性是链接的文件的属性
int stat(const char *path, struct stat *buf); 
int fstat(int fd, struct stat *buf);
//若查询文件是软链接，获得的属性是软链接本身的属性
int lstat(const char *path, struct stat *buf);
struct stat {
         dev_t   st_dev;       /* ID of device containing file */ 
         ino_t   st_ino;        /* inode number */ 
         mode_t   st_mode;       /* protection */ 
         nlink_t   st_nlink;     /* number of hard links */ 
         uid_t   st_uid;        /* user ID of owner */ 
         gid_t   st_gid;         /* group ID of owner */ 
         dev_t   st_rdev;         /* device ID (if special file) */ 
         off_t   st_size;          /* total size, in bytes */ 
         blksize_t   st_blksize;   /* blocksize for file system I/O */
         blkcnt_t   st_blocks;    /* number of 512B blocks allocated */ 
         time_t   st_atime;       /* time of last access */ 
         time_t   st_mtime;       /* time of last modification */ 
         time_t   st_ctime;       /* time of last status change */
};
```

![image-20230110102340608](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20230110102340608.png)





### access



```c
//检查进程是否可以访问文件
#include <unistd.h>
int access(const char *pathname, int mode);

//参数mode
R_OK 是否有读权限 
W_OK 是否有写权限 
X_OK 是否有执行权限 
F_OK 测试一个文件是否存在
```

![image-20230110103254230](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20230110103254230.png)





### chmod



```c
//改变文件权限
//mode_t是十进制数
//八进制444（只读）转十进制为292
#include <sys/stat.h> 
int chmod(const char *path, mode_t mode); c
int fchmod(int fd, mode_t mode);
```

![image-20230110103932608](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20230110103932608.png)

![image-20230110110452846](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20230110110452846.png)

![image-20230110110517842](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20230110110517842.png)





### chown,utime,truncate



 ```c
 //chown 改变用户所属组
 #include <unistd.h>
 int chown(const char *path, uid_t owner, gid_t group)c; 
 int fchown(int fd, uid_t owner, gid_t group); 
 int lchown(const char *path, uid_t owner, gid_t group);
 
 //utime()改变访问时间、修改时间
 
 //truncate 将文件截断为某长度
 #include <unistd.h> 
 #include <sys/types.h>
 int truncate(const char *path, off_t length); 
 int ftruncate(int fd, off_t length);
 ```





### link



```c
//创建一个硬链接
//当rm删除文件时，只是删除了目录下的记录项和把inode硬链接计数减1，当硬链接计数减为0时，才会真正的删除文件。
#include <unistd.h>
int link(const char *oldpath, const char *newpath);

//创建一个软链接
int symlink(const char *oldpath, const char *newpath);

//读链接所指向的文件名字，不读文件内容
ssize_t readlink(const char *path, char *buf, size_t bufsiz);

//删除文件链接
int unlink(const char *pathname);
```





### rename,chdir,getcwd,pathconf



```c
//rename 文件重命名
#include <stdio.h> 
int rename(const char *oldpath, const char *newpath);

//chdir 改变当前进程的工作目录（和cd一个作用）
#include <unistd.h>
int chdir(const char *path); 
int fchdir(int fd);

//getcwd获取当前进程的工作目录（pwd）
#include <unistd.h> 
char *getcwd(char *buf, size_t size);

//pathconf 获取文件名路径的配置选项
#include <unistd.h>
long fpathconf(int fd, int name); 
long pathconf(char *path, int name);
```





### 目录操作



**mkdir**

```c++
//创建目录
#include <sys/stat.h> 
#include <sys/types.h>
int mkdir(const char *pathname, mode_t mode);
```

**rmdir**

```c
//删除目录
#include <unistd.h> 
int rmdir(const char *pathname);
```

**opendir/fdopenr**

```c
//打开目录
#include <sys/types.h> 
#include <dirent.h>
DIR *opendir(const char *name); 
DIR *fdopendir(int fd);
```

**readdir**

```c
//读取目录
#include <dirent.h>
struct dirent *readdir(DIR *dirp);
struct dirent { 
ino_t d_ino;                  /* inode number */ 
off_t d_off;                   /* offset to the next dirent */ 
unsigned short d_reclen;     /* length of this record */ 
unsigned char d_type;        /* type of file; not supported by all file system types */ 
char d_name[256];           /* filename */ 
};
```

**rewinddir**

```c
//把目录指针恢复到起始位置
#include <sys/types.h>
#include <dirent.h>
void rewinddir(DIR *dirp);
```

**telldir/seekdir**

```c
//跳转到指定位置
#include <dirent.h> 
long telldir(DIR *dirp);
#include <dirent.h> 
void seekdir(DIR *dirp, long offset);
```

**closedir**

```c
//关闭目录
#include <sys/types.h> 
#include <dirent.h>
int closedir(DIR *dirp);
```

```c
//判断是否为文件夹
struct stat st_buf;
stat("路径",&st_buf);
//S_IFMT 掩码
//S_IFDIR 文件夹
if((st_buf.st_mode&S_IFMT)==S_IFDIR)cout<<"是文件夹";
//递归打印目录
```

![image-20230111123912919](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20230111123912919.png)

![image-20230111123946729](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20230111123946729.png)

![image-20230111124016578](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20230111124016578.png)





**虚拟文件系统**

```c
#include <unistd.h>
int dup(int oldfd); 
int dup2(int oldfd, int newfd);
//实现重定向
将标准输出的数据输出到指定文件，即printf()的内容会放在文件中（只在进程内生效，控制台是一个进程，应用程序是一个进程）
```

![image-20230111130911934](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20230111130911934.png)







## 4、shell脚本



脚本（script）：使用描述性语言依据格式编写的可执行文件。

包括：js jsp php sql shell python lua



### shell脚本的流程



1. 创建一个shell脚本文件，文件后缀是.sh
2. 文件中写入命令，保存退出
3. 脚本不需要编译，但需要给脚本配置一个执行权限：sudo chmod 0775 xxx.sh
4. 直接执行显示结果





### shell脚本语法

注释：#



**第一行是固定的：声明终端版本**

```c
#!/bin/bash
```

![image-20230111132326170](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20230111132326170.png)

![](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20230111132251033.png)





#### **变量：**

一、**临时变量：**

1. 不存在类型，默认都是字符串
2. 为了防止与命令重名，变量名都大写
3. 变量实际上是符号名和符号值，是一对key-value
4. 等号两侧不允许有空格
5. 读取变量使用$变量或者${变量}（可以避免冲突）
6. 三个常用符号： "双引号"、'单引号'、``(反引号)

​	双引号：字符串，但是可以识别特殊字符及其作用

​	单引号：字符串，但是不能识别特殊字符及其作用

​	反引号：可以包含命令，并且执行命令返回结果，结果可以被变量接收

![image-20230112104740820](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20230112104740820.png)

![image-20230112104727149](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20230112104727149.png)



**二、永久变量（环境变量）**

1. 可以通过env命令查看（输出永久变量和输出临时变量一样（echo"..."））

   ![image-20230112105434786](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20230112105434786.png)



**三、位置变量**

1. 位置变量一共有九个：$1 $2 $3...$9，也可以写成${1}...
2. 位置变量用于命令传参，可以帮助程序获取到外部数据

![image-20230112105558820](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20230112105558820.png)

![image-20230112105544429](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20230112105544429.png)



**四、特殊变量**

1. $*：获取所有命令参数（一次获取所有$1 $2 $3...$9，可以分着用）
2. $. ：获取参数个数，类似于argc
3. $! ：获取上一次执行后台命令的PID，为空就是没有执行后台命令
4. $? ：获取上一个命令的返回值
5. $$ ：获取当前进程的PID，shell脚本也是一个进程

![image-20230112110037880](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20230112110037880.png)





#### **常用命令：**

1. read ：读取用户的标准输入，例如：read USERDATA
2. expr ：做四则运算，乘法需要转义\\\*，如果需要赋值给变量，可以使用反引号

![image-20230112110819304](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20230112110819304.png)

![image-20230112111156494](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20230112111156494.png)

3. test ：测试命令，shell脚本判断真假使用

```c
//1.字符串判断
test str1 = str2		#等号两端要有空格，判断字符串是否相等，相等返回真
test str1 != str2		#等号两端要有空格，判断字符串是否不等，不等返回真
test -n str1		    #判断字符串是否不为空，不为空返回真
test -z str1		    #判断字符串是否为空，为空返回真

//2.数字判断
test num1 -eq num2 		#判断相等
test num1 -ne num2 		#判断不相等
test num1 -ge num2 		#判断大于等于
test num1 -gt num2 		#判断大于
test num1 -le num2 		#判断小于等于
test num1 -lt num2 		#判断小于

//3.文件判断
test -a/e filename 		#判断文件是否存在
test -d filename 		#判断文件是否是目录
test -f filename 		#判断文件是否是普通文件
test -c filename 		#判断文件是否是字符设备文件
test -b filename 		#判断文件是否是块设备
test -r filename 		#判断文件是否是读权限
test -w filename 		#判断文件是否是写权限
test -x filename 		#判断文件是否是执行权限

//4.逻辑或与
逻辑与：test xx -a yy
逻辑或：test xx -o yy
```





#### 流程：

1. 选择

```c
//1.if选择
//语法：

if test 判断表达式
		then 
			执行语句
elif test 判断表达式		
	then
			执行语句
else
		执行语句
fi  #结束标志

注：test 判断表达式，也可以写成[ 判断表达式 ]，中括号两端必须有空格
例：test -d ${FILENAME}    ->{ -d ${FILENAME} }



//2.多项选择（case多项选择）
//语法：

case ${变量} in 
	变量1)
		执行语句
		;;		#跳出
	变量2)
		执行语句
		;;		#跳出
	变量3)
		执行语句
		;;		#跳出
esac	#表示结束
```

![image-20230112114442469](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20230112114442469.png)



2. 循环

```c
//1.for循环
//语法:for((条件))
for VAR in $1 $2 $3 $4 $5 $6		#循环从传参取值
do
	执行语句
done

注：break表示本次循环结束，continue进入下一次循环


//2.while循环
//语法：
while 条件
do
	执行语句
done


//3.死循环
while :
do
	执行语句
done

while true
do
	执行语句
done

for(;;)
```

![image-20230112120400751](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20230112120400751.png)

![image-20230112120414880](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20230112120414880.png)



![image-20230112120555309](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20230112120555309.png)



![image-20230112120846928](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20230112120846928.png)

![image-20230112120909488](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20230112120909488.png)





#### **函数：**

```
//语法：
函数名()
{
	执行语句
	return int;  #如果不写return,会以最后一条命令的运行结果作为返回值
}
//调用函数:放在反引号里面执行，可以把返回结果赋值给变量
```

![image-20230112121546517](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20230112121546517.png)

![image-20230112121600149](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20230112121600149.png)







## 5、linux正则表达式



**正则表达式**：规则表达式，regular expression,regex、regexp、RE

- 实现定义好的一些特定字符、以及这些特定字符的组合，组成一个“规则字符串”，用来对字符串进行过滤

**作用**：过滤、匹配、提取

**精髓**：描述数据的关键信息，根据关键信息进行匹配和提取

**数据规则**：正则表达式是批量匹配与提取的技术，使用者必须先观察数据集，分析出数据规则和特征，根据规则和特征编辑出对应的正则语句进行匹配。

```c
grep:grep '正则表达式' filename

*  ：表示前面的子表达式出现0-n次。（aa*:a+0或n个a）（ab*:a+0或n个b）
() : 表示把多个字符组合成一个表达式，需要转义\(\) 。例：\(aa\)*:0-n个aa
+  : 匹配前面的子表达式出现1-n次，需要转义\+ 。 
.  : 匹配除了\r,\n之外的任意其他字符。例：a..匹配以a开头的三个字符，.*匹配任意字符包括空行
?  : 匹配前面的子表达式0-1次，需要转义\? 。
/*
	默认的正则表达式匹配模式是贪婪匹配模式，可以通过?切换为非贪婪匹配模式
	贪婪匹配模式：尽可能多的去匹配
	非贪婪匹配模式：匹配到一个结果就立刻返回，尽可能少的去匹配
*/
^  : 以后面的字符为参考，匹配结果以该字符为行首。 例：^a 匹配以a为开头的行
$  : 以前面的字符为参考，匹配结果以该字符为行末。 例：a$ 匹配以a为末尾的行
^$ : 匹配所有空行，
//正则表达式是不能以符号作为互相参考的，^和$之间不能相互参考，只能以空格作为参考。那么就匹配一个以空格开头以空格结尾的行，也就是空行。
|  : 逻辑或，需要转义\| 。例：x\|y匹配的是x或y
[] : 表示字符集合，匹配所包含的任意一个字符。
	匹配小写字母[a-z] 
	匹配数字[0-9] 
	匹配大写字母[A-Z]
	负值字符集合[^xyz]，即非xyz
//n和m均为非负整数，n<=m,{}需要转义\{\}
{n}		: 匹配前一个字表达式出现n次
{n,}	: 表示前一个子表达式至少匹配n次
{n,m}	: 表示前一个子表达式至少匹配n次，最多匹配m次
```

![image-20230112202813896](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20230112202813896.png)

![image-20230112202841837](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20230112202841837.png)



**linux三个命令使用正则表达式**

```\
grep : grep [参数] 表达式 [文件]
参数：
-E : 扩展正则表达式，就不需要进行转义了 
-G : 基本正则表达式
-n : 打印行号和输出行
-h : 禁止输出文件名前缀
-i : 不区分大小写

awk : 可以使用域分隔，通过awk语法对特定数据进行格式化和提取

sed : 文件流处理，批处理文件比较方便，特别适合对多文件中相同的内容进行统计修改
```



**练习**

```c
//匹配手机号
简单的正则表达式：^1[3-8][0-9]{9}$
复杂的匹配表达式：^(13[0-9]|14[57]|15[0-9]|18[012356789])[0-9]{8}$
```



**正则表达式函数实现**

```c
#include<regex.h>
#include<sys/types>
int regcomp(regex_t *preg,const char *regex,int cflags);
int regexec(const regex_t* preg,const char *string,size_t nmatch,regmatch_t pmatch[],int eflags);
size_t regerror(int errcode,const regex_t *preg,char* errbuf,size_t errbuf_size);
void regfree(regex_t *preg);
```



**第一个参数是正则表达式，第二个参数是匹配文本，二者进行匹配**

![image-20230116112727067](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20230116112727067.png)



**获取匹配到的子字符串并打印**

![image-20230116115133190](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20230116115133190.png)
